<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Mechanics.MultiBody.Forces</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Mechanics.MultiBody.Forces</h1>
</div>
<h1 id="modelica.mechanics.multibody.forces"><a href="Modelica_Mechanics_MultiBody.html#Modelica.Mechanics.MultiBody">Modelica.Mechanics.MultiBody</a>.Forces</h1>
<p><strong>Components that exert forces and/or torques between frames</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>This package contains components that exert forces and torques between two frame connectors, e.g., between two parts.</p>
<h3 id="content">Content</h3>
<table>
<col width="35%" />
<col width="64%" />
<thead>
<tr class="header">
<th align="left"><strong><em>Model</em></strong></th>
<th align="left"><strong><em>Description</em></strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.WorldForce">WorldForce</a></td>
<td align="left"><dl>
<dt>External force acting at the frame to which this component is connected and defined by 3 input signals, that are interpreted as one vector resolved in frame world, frame_b or frame_resolve.</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/ArrowForce.png" alt="image12" /><p class="caption">image12</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.WorldTorque">WorldTorque</a></td>
<td align="left"><dl>
<dt>External torque acting at the frame to which this component is connected and defined by 3 input signals, that are interpreted as one vector resolved in frame world, frame_b or frame_resolve.</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/ArrowTorque.png" alt="image13" /><p class="caption">image13</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque">WorldForceAndTorque</a></td>
<td align="left"><dl>
<dt>External force and external torque acting at the frame to which this component is connected and defined by 3+3 input signals, that are interpreted as a force and as a torque vector resolved in frame world, frame_b or frame_resolve.</dt>
<dd><p><img src="../Resources/Images/MultiBody/Forces/ArrowForce.png" alt="image14" /> <img src="../Resources/Images/MultiBody/Forces/ArrowTorque.png" alt="image15" /></p>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Force">Force</a></td>
<td align="left"><dl>
<dt>Force acting between two frames defined by 3 input signals resolved in frame world, frame_a, frame_b or in frame_resolve.</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/ArrowForce2.png" alt="image16" /><p class="caption">image16</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Torque">Torque</a></td>
<td align="left"><dl>
<dt>Torque acting between two frames defined by 3 input signals resolved in frame world, frame_a, frame_b or in frame_resolve.</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/ArrowTorque2.png" alt="image17" /><p class="caption">image17</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.ForceAndTorque">ForceAndTorque</a></td>
<td align="left"><dl>
<dt>Force and torque acting between two frames defined by 3+3 input signals resolved in frame world, frame_a, frame_b or in frame_resolve.</dt>
<dd><p><img src="../Resources/Images/MultiBody/Forces/ArrowForce2.png" alt="image18" /> <img src="../Resources/Images/MultiBody/Forces/ArrowTorque2.png" alt="image19" /></p>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.LineForceWithMass">LineForceWithMass</a></td>
<td align="left"><dl>
<dt>General line force component with an optional point mass on the connection line. The force law can be defined by a component of Modelica.Mechanics.Translational</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/LineForceWithMass.png" alt="image20" /><p class="caption">image20</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses">LineForceWithTwoMasses</a></td>
<td align="left"><dl>
<dt>General line force component with two optional point masses on the connection line. The force law can be defined by a component of Modelica.Mechanics.Translational</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/LineForceWithTwoMasses.png" alt="image21" /><p class="caption">image21</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Spring">Spring</a></td>
<td align="left"><dl>
<dt>Linear translational spring with optional mass</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/Spring2.png" alt="image22" /><p class="caption">image22</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Damper">Damper</a></td>
<td align="left"><dl>
<dt>Linear (velocity dependent) damper</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Forces/Damper2.png" alt="image23" /><p class="caption">image23</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.SpringDamperParallel">SpringDamperParallel</a></td>
<td align="left">Linear spring and damper in parallel connection</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.SpringDamperSeries">SpringDamperSeries</a></td>
<td align="left">Linear spring and damper in series connection</td>
</tr>
</tbody>
</table>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_SourcesPackage.html#Modelica.Icons.SourcesPackage">Modelica.Icons.SourcesPackage</a> (Icon for packages containing sources).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="57%" />
<col width="42%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.WorldForceS.png" alt="image37" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.WorldForce">WorldForce</a></td>
<td align="left">External force acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.WorldTorqueS.png" alt="image38" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.WorldTorque">WorldTorque</a></td>
<td align="left">External torque acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorqueS.png" alt="image39" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque">WorldForceAndTorque</a></td>
<td align="left">External force and torque acting at frame_b, defined by 3+3 input signals and resolved in frame world, frame_b or in frame_resolve</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.ForceS.png" alt="image40" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Force">Force</a></td>
<td align="left">Force acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.TorqueS.png" alt="image41" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Torque">Torque</a></td>
<td align="left">Torque acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.ForceAndTorqueS.png" alt="image42" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.ForceAndTorque">ForceAndTorque</a></td>
<td align="left">Force and torque acting between two frames, defined by 3+3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.LineForceWithMassS.png" alt="image43" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.LineForceWithMass">LineForceWithMass</a></td>
<td align="left">General line force component with an optional point mass on the connection line</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMassesS.png" alt="image44" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMasses">LineForceWithTwoMasses</a></td>
<td align="left">General line force component with two optional point masses on the connection line</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.SpringS.png" alt="image45" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Spring">Spring</a></td>
<td align="left">Linear translational spring with optional mass</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.DamperS.png" alt="image46" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.Damper">Damper</a></td>
<td align="left">Linear (velocity dependent) damper</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.SpringDamperParallelS.png" alt="image47" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.SpringDamperParallel">SpringDamperParallel</a></td>
<td align="left">Linear spring and linear damper in parallel</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.SpringDamperSeriesS.png" alt="image48" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces.SpringDamperSeries">SpringDamperSeries</a></td>
<td align="left">Linear spring and linear damper in series connection</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Forces.InternalS.png" alt="image49" /> <a href="Modelica_Mechanics_MultiBody_Forces_Internal.html#Modelica.Mechanics.MultiBody.Forces.Internal">Internal</a></td>
<td align="left">Internal package, should not be used by user</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image50-modelica.mechanics.multibody.forces.worldforce"><img src="Modelica.Mechanics.MultiBody.Forces.WorldForceI.png" alt="image50" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.WorldForce</h1>
<p><strong>External force acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>The <strong>3</strong> signals of the <strong>force</strong> connector are interpreted as the x-, y- and z-coordinates of a <strong>force</strong> acting at the frame connector to which frame_b of this component is attached. Via parameter <strong>resolveInFrame</strong> it is defined, in which frame these coordinates shall be resolved:</p>
<table>
<col width="28%" />
<col width="71%" />
<thead>
<tr class="header">
<th align="left"><strong>Types.ResolveInFrameB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve input force in world frame (= default)</td>
</tr>
<tr class="even">
<td align="left">frame_b</td>
<td align="left">Resolve input force in frame_b</td>
</tr>
<tr class="odd">
<td align="left">frame_resolve</td>
<td align="left">Resolve input force in frame_resolve (frame_resolve must be connected)</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the force coordinates are with respect to the frame, that is connected to <strong>frame_resolve</strong>.</p>
<p>If force={100,0,0}, and for all parameters the default setting is used, then the interpretation is that a force of 100 N is acting along the positive x-axis of frame_b.</p>
<p>Note, the cut-torque in frame_b (frame_b.t) is always set to zero. Conceptually, a force and torque acts on the world frame in such a way that the force and torque balance between world.frame_b and frame_b is fulfilled. For efficiency reasons, this reaction torque is, however, not computed.</p>
<p>This force component is by default visualized as an arrow acting at the connector to which it is connected. The diameter and color of the arrow can be defined via variables <strong>diameter</strong> and <strong>color</strong>. The arrow points in the direction defined by the force signal. The length of the arrow is proportional to the length of the force vector using parameter <strong>N_to_m</strong> as scaling factor. For example, if N_to_m = 100 N/m, then a force of 350 N is displayed as an arrow of length 3.5 m.</p>
<p>An example how to use this model is given in the following figure:</p>
<p>This leads to the following animation</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_b">Interfaces.PartialOneFrame_b</a> (Base model for components providing one frame_b connector + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters">Parameters</h2>
<table>
<col width="45%" />
<col width="8%" />
<col width="13%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameB">ResolveInFrameB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which input force is resolved (1: world, 2: frame_b, 3: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">N_to_m</td>
<td align="left">world.defaultN_to_m</td>
<td align="left">Force arrow scaling (length = force/N_to_m) [N/m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">diameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of force arrow [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of arrow</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors">Connectors</h2>
<table>
<col width="54%" />
<col width="8%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">The input signals are optionally resolved in this frame</td>
</tr>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">force[3]</td>
<td align="left">x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame [N]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>model WorldForce 
  &quot;External force acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve&quot;

  import SI = Modelica.SIunits;
  extends Interfaces.PartialOneFrame_b;
  Interfaces.Frame_resolve frame_resolve if 
       resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve 
    &quot;The input signals are optionally resolved in this frame&quot;;
  Modelica.Blocks.Interfaces.RealInput force[3](each final quantity=&quot;Force&quot;, each final unit=
                   &quot;N&quot;) 
    &quot;x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame&quot;;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameB resolveInFrame=
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world 
    &quot;Frame in which input force is resolved (1: world, 2: frame_b, 3: frame_resolve)&quot;;
  parameter Real N_to_m(unit=&quot;N/m&quot;) = world.defaultN_to_m 
    &quot;Force arrow scaling (length = force/N_to_m)&quot;;
  input SI.Diameter diameter=world.defaultArrowDiameter 
    &quot;Diameter of force arrow&quot;;
  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.ForceColor 
    &quot;Color of arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  SI.Position f_in_m[3]=frame_b.f/N_to_m 
    &quot;Force mapped from N to m for animation&quot;;
  Visualizers.Advanced.Arrow arrow(
    diameter=diameter,
    color=color,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=f_in_m,
    r_head=-f_in_m) if world.enableAnimation and animation;

public 
  Internal.BasicWorldForce basicWorldForce(resolveInFrame=resolveInFrame);
protected 
  Interfaces.ZeroPosition zeroPosition if 
       not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve);
equation 
  connect(basicWorldForce.frame_b, frame_b);
  connect(basicWorldForce.force, force);
  connect(basicWorldForce.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, basicWorldForce.frame_resolve);
end WorldForce;</code></pre>
<hr />
<h1 id="image51-modelica.mechanics.multibody.forces.worldtorque"><img src="Modelica.Mechanics.MultiBody.Forces.WorldTorqueI.png" alt="image51" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.WorldTorque</h1>
<p><strong>External torque acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>The <strong>3</strong> signals of the <strong>torque</strong> connector are interpreted as the x-, y- and z-coordinates of a <strong>torque</strong> acting at the frame connector to which frame_b of this component is attached. Via parameter <strong>resolveInFrame</strong> it is defined, in which frame these coordinates shall be resolved:</p>
<table>
<col width="28%" />
<col width="71%" />
<thead>
<tr class="header">
<th align="left"><strong>Types.ResolveInFrameB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve input torque in world frame (= default)</td>
</tr>
<tr class="even">
<td align="left">frame_b</td>
<td align="left">Resolve input torque in frame_b</td>
</tr>
<tr class="odd">
<td align="left">frame_resolve</td>
<td align="left">Resolve input torque in frame_resolve (frame_resolve must be connected)</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the torque coordinates are with respect to the frame, that is connected to <strong>frame_resolve</strong>.</p>
<p>If torque={100,0,0}, and for all parameters the default setting is used, then the interpretation is that a torque of 100 N is acting along the positive x-axis of frame_b.</p>
<p>Note, the cut-force in frame_b (frame_b.f) is always set to zero. Conceptually, a force and torque acts on the world frame in such a way that the force and torque balance between world.frame_b and frame_b is fulfilled. For efficiency reasons, this reaction torque is, however, not computed.</p>
<p>This torque component is by default visualized as a <strong>double arrow</strong> acting at the connector to which it is connected. The diameter and color of the arrow can be defined via variables <strong>diameter</strong> and <strong>color</strong>. The double arrow points in the direction defined by the torque vector. The length of the double arrow is proportional to the length of the torque vector using parameter <strong>Nm_to_m</strong> as scaling factor. For example, if Nm_to_m = 100 Nm/m, then a torque of 350 Nm is displayed as an arrow of length 3.5 m.</p>
<p>An example how to use this model is given in the following figure:</p>
<p>This leads to the following animation</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_b">Interfaces.PartialOneFrame_b</a> (Base model for components providing one frame_b connector + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-1">Parameters</h2>
<table>
<col width="45%" />
<col width="8%" />
<col width="13%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameB">ResolveInFrameB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which input torque is resolved (1: world, 2: frame_b, 3: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">Nm_to_m</td>
<td align="left">world.defaultNm_to_m</td>
<td align="left">Torque arrow scaling (length = torque/Nm_to_m) [N.m/m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">diameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of torque arrow [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of arrow</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-1">Connectors</h2>
<table>
<col width="53%" />
<col width="8%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">The input signals are optionally resolved in this frame</td>
</tr>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">torque[3]</td>
<td align="left">x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame [N.m]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>model WorldTorque 
  &quot;External torque acting at frame_b, defined by 3 input signals and resolved in frame world, frame_b or frame_resolve&quot;

  extends Interfaces.PartialOneFrame_b;

  Interfaces.Frame_resolve frame_resolve if 
       resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve 
    &quot;The input signals are optionally resolved in this frame&quot;;
  Modelica.Blocks.Interfaces.RealInput torque[3](each final quantity=&quot;Torque&quot;, each final unit=
                   &quot;N.m&quot;) 
    &quot;x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame&quot;;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameB resolveInFrame=
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world 
    &quot;Frame in which input torque is resolved (1: world, 2: frame_b, 3: frame_resolve)&quot;;
  parameter Real Nm_to_m(unit=&quot;N.m/m&quot;) = world.defaultNm_to_m 
    &quot;Torque arrow scaling (length = torque/Nm_to_m)&quot;;
  input SI.Diameter diameter=world.defaultArrowDiameter 
    &quot;Diameter of torque arrow&quot;;
  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.TorqueColor 
    &quot;Color of arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  SI.Position t_in_m[3]=frame_b.t/Nm_to_m 
    &quot;Torque mapped from Nm to m for animation&quot;;
  Visualizers.Advanced.DoubleArrow arrow(
    diameter=diameter,
    color=color,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=t_in_m,
    r_head=-t_in_m) if world.enableAnimation and animation;
public 
  Internal.BasicWorldTorque basicWorldTorque(resolveInFrame=resolveInFrame);
protected 
  Interfaces.ZeroPosition zeroPosition if 
       not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve);
equation 
  connect(basicWorldTorque.frame_b, frame_b);
  connect(basicWorldTorque.torque, torque);
  connect(frame_resolve, basicWorldTorque.frame_resolve);
  connect(zeroPosition.frame_resolve, basicWorldTorque.frame_resolve);
end WorldTorque;</code></pre>
<hr />
<h1 id="image52-modelica.mechanics.multibody.forces.worldforceandtorque"><img src="Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorqueI.png" alt="image52" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.WorldForceAndTorque</h1>
<p><strong>External force and torque acting at frame_b, defined by 3+3 input signals and resolved in frame world, frame_b or in frame_resolve</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>The <strong>3</strong> signals of the <strong>force</strong> and <strong>torque</strong> connector are interpreted as the x-, y- and z-coordinates of a <strong>force</strong> and <strong>torque</strong> acting at the frame connector to which frame_b of this component is attached. Via parameter <strong>resolveInFrame</strong> it is defined, in which frame these coordinates shall be resolved:</p>
<table>
<col width="26%" />
<col width="73%" />
<thead>
<tr class="header">
<th align="left"><strong>Types.ResolveInFrameB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve input forceand torque in world frame (= default)</td>
</tr>
<tr class="even">
<td align="left">frame_b</td>
<td align="left">Resolve input force and torque in frame_b</td>
</tr>
<tr class="odd">
<td align="left">frame_resolve</td>
<td align="left">Resolve input force and torque in frame_resolve (frame_resolve must be connected)</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameB.frame_resolve, the force and torque coordinates are with respect to the frame, that is connected to <strong>frame_resolve</strong>.</p>
<p>If force={100,0,0}, and for all parameters the default setting is used, then the interpretation is that a force of 100 N is acting along the positive x-axis of frame_b.</p>
<p>Conceptually, a force and torque acts on the world frame in such a way that the force and torque balance between world.frame_b and frame_b is fulfilled. For efficiency reasons, this reaction torque is, however, not computed.</p>
<p>The force and torque are by default visualized as an arrow (force) and as a double arrow (torque) acting at the connector to which they are connected. The diameters and colors of the arrows can be defined via variables <strong>forceDiameter</strong>, <strong>torqueDiameter</strong>, <strong>forceColor</strong> and <strong>torqueColor</strong>. The arrows point in the directions defined by the force and torque vectors. The lengths of the arrows are proportional to the length of the force and torque vectors, respectively, using parameters <strong>N_to_m</strong> and <strong>Nm_to_m</strong> as scaling factors. For example, if N_to_m = 100 N/m, then a force of 350 N is displayed as an arrow of length 3.5 m.</p>
<p>An example how to use this model is given in the following figure:</p>
<p>This leads to the following animation</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialOneFrame_b">Interfaces.PartialOneFrame_b</a> (Base model for components providing one frame_b connector + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-2">Parameters</h2>
<table>
<col width="43%" />
<col width="8%" />
<col width="12%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameB">ResolveInFrameB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which input force and torque are resolved (1: world, 2: frame_b, 3: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">N_to_m</td>
<td align="left">world.defaultN_to_m</td>
<td align="left">Force arrow scaling (length = force/N_to_m) [N/m]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">Nm_to_m</td>
<td align="left">world.defaultNm_to_m</td>
<td align="left">Torque arrow scaling (length = torque/Nm_to_m) [N.m/m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">forceDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of force arrow [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">torqueDiameter</td>
<td align="left">forceDiameter</td>
<td align="left">Diameter of torque arrow [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">forceColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of force arrow</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">torqueColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of torque arrow</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-2">Connectors</h2>
<table>
<col width="53%" />
<col width="8%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">The input signals are optionally resolved in this frame</td>
</tr>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">force[3]</td>
<td align="left">x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame [N]</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">torque[3]</td>
<td align="left">x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame [N.m]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>model WorldForceAndTorque 
  &quot;External force and torque acting at frame_b, defined by 3+3 input signals and resolved in frame world, frame_b or in frame_resolve&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;
  extends Interfaces.PartialOneFrame_b;
  Interfaces.Frame_resolve frame_resolve if 
       resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve 
    &quot;The input signals are optionally resolved in this frame&quot;;
  Blocks.Interfaces.RealInput force[3](each final quantity=&quot;Force&quot;, each final unit=
                   &quot;N&quot;) 
    &quot;x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame&quot;;
  Blocks.Interfaces.RealInput torque[3](each final quantity=&quot;Torque&quot;, each final unit=
                   &quot;N.m&quot;) 
    &quot;x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame&quot;;

  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameB resolveInFrame=
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.world 
    &quot;Frame in which input force and torque are resolved (1: world, 2: frame_b, 3: frame_resolve)&quot;;

  parameter Real N_to_m(unit=&quot;N/m&quot;) = world.defaultN_to_m 
    &quot; Force arrow scaling (length = force/N_to_m)&quot;;
  parameter Real Nm_to_m(unit=&quot;N.m/m&quot;) = world.defaultNm_to_m 
    &quot; Torque arrow scaling (length = torque/Nm_to_m)&quot;;
  input SI.Diameter forceDiameter=world.defaultArrowDiameter 
    &quot; Diameter of force arrow&quot;;
  input SI.Diameter torqueDiameter=forceDiameter &quot; Diameter of torque arrow&quot;;
  input Types.Color forceColor=Modelica.Mechanics.MultiBody.Types.Defaults.ForceColor 
    &quot; Color of force arrow&quot;;
  input Types.Color torqueColor=Modelica.Mechanics.MultiBody.Types.Defaults.TorqueColor 
    &quot; Color of torque arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  SI.Position f_in_m[3]=frame_b.f/N_to_m 
    &quot;Force mapped from N to m for animation&quot;;
  SI.Position t_in_m[3]=frame_b.t/Nm_to_m 
    &quot;Torque mapped from Nm to m for animation&quot;;
  Visualizers.Advanced.Arrow forceArrow(
    diameter=forceDiameter,
    color=forceColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=f_in_m,
    r_head=-f_in_m) if world.enableAnimation and animation;
  Visualizers.Advanced.DoubleArrow torqueArrow(
    diameter=torqueDiameter,
    color=torqueColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=t_in_m,
    r_head=-t_in_m) if world.enableAnimation and animation;
public 
  Internal.BasicWorldForce basicWorldForce(resolveInFrame=resolveInFrame);
  Internal.BasicWorldTorque basicWorldTorque(resolveInFrame=resolveInFrame);
protected 
  Interfaces.ZeroPosition zeroPosition if 
       not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameB.frame_resolve);
equation 
  connect(basicWorldForce.frame_b, frame_b);
  connect(basicWorldForce.force, force);
  connect(basicWorldTorque.frame_b, frame_b);
  connect(basicWorldTorque.torque, torque);
  connect(basicWorldForce.frame_resolve, frame_resolve);
  connect(basicWorldTorque.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, basicWorldTorque.frame_resolve);
  connect(zeroPosition.frame_resolve, basicWorldForce.frame_resolve);
end WorldForceAndTorque;</code></pre>
<hr />
<h1 id="image53-modelica.mechanics.multibody.forces.force"><img src="Modelica.Mechanics.MultiBody.Forces.ForceI.png" alt="image53" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.Force</h1>
<p><strong>Force acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>The <strong>3</strong> signals of the <strong>force</strong> connector are interpreted as the x-, y- and z-coordinates of a <strong>force</strong> acting at the frame connector to which frame_b of this component is attached. Via parameter <strong>resolveInFrame</strong> it is defined, in which frame these coordinates shall be resolved:</p>
<table>
<col width="29%" />
<col width="70%" />
<thead>
<tr class="header">
<th align="left"><strong>Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve input force in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve input force in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve input force in frame_b (= default)</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve input force in frame_resolve (frame_resolve must be connected)</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = ResolveInFrameAB.frame_resolve, the force coordinates are with respect to the frame, that is connected to <strong>frame_resolve</strong>.</p>
<p>If force={100,0,0}, and for all parameters the default setting is used, then the interpretation is that a force of 100 N is acting along the positive x-axis of frame_b.</p>
<p>Note, the cut-torque in frame_b (frame_b.t) is always set to zero. Additionally, a force and torque acts on frame_a in such a way that the force and torque balance between frame_a and frame_b is fulfilled.</p>
<p>An example how to use this model is given in the following figure:</p>
<p>This leads to the following animation (the yellow cylinder characterizes the line between frame_a and frame_b of the Force component, i.e., the force acts with negative sign also on the opposite side of this cylinder, but for clarity this is not shown in the animation):</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-3">Parameters</h2>
<table>
<col width="43%" />
<col width="9%" />
<col width="12%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which input force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">N_to_m</td>
<td align="left">world.defaultN_to_m</td>
<td align="left">Force arrow scaling (length = force/N_to_m) [N/m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">forceDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of force arrow [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">connectionLineDiameter</td>
<td align="left">forceDiameter</td>
<td align="left">Diameter of line connecting frame_a and frame_b [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">forceColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of force arrow</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">connectionLineColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of line connecting frame_a and frame_b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-3">Connectors</h2>
<table>
<col width="54%" />
<col width="8%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">The input signals are optionally resolved in this frame</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">force[3]</td>
<td align="left">x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame [N]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>model Force 
  &quot;Force acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve&quot;

  import SI = Modelica.SIunits;
  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  Interfaces.Frame_resolve frame_resolve if 
       resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve 
    &quot;The input signals are optionally resolved in this frame&quot;;
  Modelica.Blocks.Interfaces.RealInput force[3](each final quantity=&quot;Force&quot;, each final unit=
                   &quot;N&quot;) 
    &quot;x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame&quot;;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrame=
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_b 
    &quot;Frame in which input force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;
  parameter Real N_to_m(unit=&quot;N/m&quot;) = world.defaultN_to_m 
    &quot; Force arrow scaling (length = force/N_to_m)&quot;;
  input SI.Diameter forceDiameter=world.defaultArrowDiameter 
    &quot; Diameter of force arrow&quot;;
  input SI.Diameter connectionLineDiameter=forceDiameter 
    &quot; Diameter of line connecting frame_a and frame_b&quot;;
  input Types.Color forceColor=Modelica.Mechanics.MultiBody.Types.Defaults.ForceColor 
    &quot; Color of force arrow&quot;;
  input Types.Color connectionLineColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot; Color of line connecting frame_a and frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  SI.Position f_in_m[3]=frame_b.f/N_to_m 
    &quot;Force mapped from N to m for animation&quot;;
  Visualizers.Advanced.Arrow forceArrow(
    diameter=forceDiameter,
    color=forceColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=f_in_m,
    r_head=-f_in_m) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape connectionLine(
    shapeType=&quot;cylinder&quot;,
    lengthDirection=basicForce.r_0,
    widthDirection={0,1,0},
    length=Modelica.Math.Vectors.length(basicForce.r_0),
    width=connectionLineDiameter,
    height=connectionLineDiameter,
    color=connectionLineColor,
    specularCoefficient=specularCoefficient,
    r=frame_a.r_0) if world.enableAnimation and animation;

public 
  MultiBody.Forces.Internal.BasicForce basicForce(resolveInFrame=resolveInFrame);
protected 
  MultiBody.Interfaces.ZeroPosition zeroPosition if 
       not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve);
equation 
  connect(basicForce.frame_a, frame_a);
  connect(basicForce.frame_b, frame_b);
  connect(force, basicForce.force);
  connect(basicForce.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, basicForce.frame_resolve);
end Force;</code></pre>
<hr />
<h1 id="image54-modelica.mechanics.multibody.forces.torque"><img src="Modelica.Mechanics.MultiBody.Forces.TorqueI.png" alt="image54" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.Torque</h1>
<p><strong>Torque acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p>The <strong>3</strong> signals of the <strong>torque</strong> connector are interpreted as the x-, y- and z-coordinates of a <strong>torque</strong> acting at the frame connector to which frame_b of this component is attached. Via parameter <strong>resolveInFrame</strong> it is defined, in which frame these coordinates shall be resolved:</p>
<table>
<col width="29%" />
<col width="70%" />
<thead>
<tr class="header">
<th align="left"><strong>Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve input torque in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve input torque in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve input torque in frame_b (= default)</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve input torque in frame_resolve (frame_resolve must be connected)</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = ResolveInFrameAB.frame_resolve, the torque coordinates are with respect to the frame, that is connected to <strong>frame_resolve</strong>.</p>
<p>If torque={100,0,0}, and for all parameters the default setting is used, then the interpretation is that a torque of 100 N.m is acting along the positive x-axis of frame_b.</p>
<p>Note, the cut-forces in frame_a and frame_b (frame_a.f, frame_b.f) are always set to zero and the cut-torque at frame_a (frame_a.t) is the same as the cut-torque at frame_b (frame_b.t) but with opposite sign.</p>
<p>An example how to use this model is given in the following figure:</p>
<p>This leads to the following animation (the yellow cylinder characterizes the line between frame_a and frame_b of the Torque component, i.e., the torque acts with negative sign also on the opposite side of this cylinder, but for clarity this is not shown in the animation):</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-4">Parameters</h2>
<table>
<col width="43%" />
<col width="9%" />
<col width="12%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which input force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">Nm_to_m</td>
<td align="left">world.defaultNm_to_m</td>
<td align="left">Torque arrow scaling (length = torque/Nm_to_m) [N.m/m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">torqueDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of torque arrow [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">connectionLineDiameter</td>
<td align="left">torqueDiameter</td>
<td align="left">Diameter of line connecting frame_a and frame_b [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">torqueColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of torque arrow</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">connectionLineColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of line connecting frame_a and frame_b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-4">Connectors</h2>
<table>
<col width="53%" />
<col width="8%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">The input signals are optionally resolved in this frame</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">torque[3]</td>
<td align="left">x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame [N.m]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>model Torque 
  &quot;Torque acting between two frames, defined by 3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve&quot;

  import SI = Modelica.SIunits;
  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  Interfaces.Frame_resolve frame_resolve if 
       resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve 
    &quot;The input signals are optionally resolved in this frame&quot;;

  Modelica.Blocks.Interfaces.RealInput torque[3](each final quantity=&quot;Torque&quot;, each final unit=
                   &quot;N.m&quot;) 
    &quot;x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame&quot;;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrame=
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_b 
    &quot;Frame in which input force is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;
  parameter Real Nm_to_m(unit=&quot;N.m/m&quot;) = world.defaultNm_to_m 
    &quot; Torque arrow scaling (length = torque/Nm_to_m)&quot;;
  input SI.Diameter torqueDiameter=world.defaultArrowDiameter 
    &quot; Diameter of torque arrow&quot;;
  input SI.Diameter connectionLineDiameter=torqueDiameter 
    &quot; Diameter of line connecting frame_a and frame_b&quot;;
  input Types.Color torqueColor=Modelica.Mechanics.MultiBody.Types.Defaults.TorqueColor 
    &quot; Color of torque arrow&quot;;
  input Types.Color connectionLineColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot; Color of line connecting frame_a and frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  SI.Position t_in_m[3]=frame_b.t/Nm_to_m 
    &quot;Torque mapped from Nm to m for animation&quot;;
  Visualizers.Advanced.DoubleArrow torqueArrow(
    diameter=torqueDiameter,
    color=torqueColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=t_in_m,
    r_head=-t_in_m) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape connectionLine(
    shapeType=&quot;cylinder&quot;,
    lengthDirection=basicTorque.r_0,
    widthDirection={0,1,0},
    length=Modelica.Math.Vectors.length(
                         basicTorque.r_0),
    width=connectionLineDiameter,
    height=connectionLineDiameter,
    color=connectionLineColor,
    specularCoefficient=specularCoefficient,
    r=frame_a.r_0) if world.enableAnimation and animation;

public 
  Internal.BasicTorque basicTorque(resolveInFrame=resolveInFrame);
protected 
  Interfaces.ZeroPosition zeroPosition if 
       not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve);
equation 
  connect(basicTorque.frame_a, frame_a);
  connect(basicTorque.frame_b, frame_b);
  connect(basicTorque.torque, torque);
  connect(basicTorque.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, basicTorque.frame_resolve);
end Torque;</code></pre>
<hr />
<h1 id="image55-modelica.mechanics.multibody.forces.forceandtorque"><img src="Modelica.Mechanics.MultiBody.Forces.ForceAndTorqueI.png" alt="image55" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.ForceAndTorque</h1>
<p><strong>Force and torque acting between two frames, defined by 3+3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p>The <strong>3</strong> signals of the <strong>force</strong> connector and the <strong>3</strong> signals of the <strong>torque</strong> connector are interpreted as the x-, y- and z-coordinates of a <strong>force</strong> and of a <strong>torque</strong> acting at the frame connector to which frame_b of this component is attached. Via parameter <strong>resolveInFrame</strong> it is defined, in which frame these coordinates shall be resolved:</p>
<table>
<col width="27%" />
<col width="72%" />
<thead>
<tr class="header">
<th align="left"><strong>Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve input force/torque in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve input force/torque in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve input force/torque in frame_b (= default)</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve input force/torque in frame_resolve (frame_resolve must be connected)</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = ResolveInFrameAB.frame_resolve, the force and torque coordinates are with respect to the frame, that is connected to <strong>frame_resolve</strong>.</p>
<p>If force={100,0,0}, and for all parameters the default setting is used, then the interpretation is that a force of 100 N is acting along the positive x-axis of frame_b.</p>
<p>Note, a force and torque acts on frame_a in such a way that the force and torque balance between frame_a and frame_b is fulfilled.</p>
<p>An example how to use this model is given in the following figure:</p>
<p>This leads to the following animation (the yellow cylinder characterizes the line between frame_a and frame_b of the ForceAndTorque component, i.e., the force and torque acts with negative sign also on the opposite side of this cylinder, but for clarity this is not shown in the animation):</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-5">Parameters</h2>
<table>
<col width="41%" />
<col width="9%" />
<col width="12%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which input force and torque are resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">N_to_m</td>
<td align="left">world.defaultN_to_m</td>
<td align="left">Force arrow scaling (length = force/N_to_m) [N/m]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">Nm_to_m</td>
<td align="left">world.defaultNm_to_m</td>
<td align="left">Torque arrow scaling (length = torque/Nm_to_m) [N.m/m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">forceDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of force arrow [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">torqueDiameter</td>
<td align="left">forceDiameter</td>
<td align="left">Diameter of torque arrow [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">connectionLineDiameter</td>
<td align="left">forceDiameter</td>
<td align="left">Diameter of line connecting frame_a and frame_b [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">forceColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of force arrow</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">torqueColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of torque arrow</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">connectionLineColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of line connecting frame_a and frame_b</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-5">Connectors</h2>
<table>
<col width="53%" />
<col width="8%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">force[3]</td>
<td align="left">x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame [N]</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">torque[3]</td>
<td align="left">x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame [N.m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">The input signals are optionally resolved in this frame</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>model ForceAndTorque 
  &quot;Force and torque acting between two frames, defined by 3+3 input signals and resolved in frame world, frame_a, frame_b or frame_resolve&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;
  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;

  Blocks.Interfaces.RealInput force[3](each final quantity=&quot;Force&quot;, each final unit=
                   &quot;N&quot;) 
    &quot;x-, y-, z-coordinates of force resolved in frame defined by resolveInFrame&quot;;
  Blocks.Interfaces.RealInput torque[3](each final quantity=&quot;Torque&quot;, each final unit=
                   &quot;N.m&quot;) 
    &quot;x-, y-, z-coordiantes of torque resolved in frame defined by resolveInFrame&quot;;
  Interfaces.Frame_resolve frame_resolve if 
       resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve 
    &quot;The input signals are optionally resolved in this frame&quot;;

  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrame=
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_b 
    &quot;Frame in which input force and torque are resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;
  parameter Real N_to_m(unit=&quot;N/m&quot;) = world.defaultN_to_m 
    &quot;Force arrow scaling (length = force/N_to_m)&quot;;
  parameter Real Nm_to_m(unit=&quot;N.m/m&quot;) = world.defaultNm_to_m 
    &quot;Torque arrow scaling (length = torque/Nm_to_m)&quot;;
  input SI.Diameter forceDiameter=world.defaultArrowDiameter 
    &quot;Diameter of force arrow&quot;;
  input SI.Diameter torqueDiameter=forceDiameter &quot; Diameter of torque arrow&quot;;
  input SI.Diameter connectionLineDiameter=forceDiameter 
    &quot;Diameter of line connecting frame_a and frame_b&quot;;
  input Types.Color forceColor=Modelica.Mechanics.MultiBody.Types.Defaults.ForceColor 
    &quot;Color of force arrow&quot;;
  input Types.Color torqueColor=Modelica.Mechanics.MultiBody.Types.Defaults.TorqueColor 
    &quot;Color of torque arrow&quot;;
  input Types.Color connectionLineColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot;Color of line connecting frame_a and frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  SI.Position f_in_m[3]=frame_b.f/N_to_m 
    &quot;Force mapped from N to m for animation&quot;;
  SI.Position t_in_m[3]=frame_b.t/Nm_to_m 
    &quot;Torque mapped from Nm to m for animation&quot;;
  Visualizers.Advanced.Arrow forceArrow(
    diameter=forceDiameter,
    color=forceColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=f_in_m,
    r_head=-f_in_m) if world.enableAnimation and animation;
  Visualizers.Advanced.DoubleArrow torqueArrow(
    diameter=torqueDiameter,
    color=torqueColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=t_in_m,
    r_head=-t_in_m) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape connectionLine(
    shapeType=&quot;cylinder&quot;,
    lengthDirection=basicForce.r_0,
    widthDirection={0,1,0},
    length=Modelica.Math.Vectors.length(
                         basicForce.r_0),
    width=connectionLineDiameter,
    height=connectionLineDiameter,
    color=connectionLineColor,
    specularCoefficient=specularCoefficient,
    r=frame_a.r_0) if world.enableAnimation and animation;

public 
  Internal.BasicForce basicForce(resolveInFrame=resolveInFrame);
  Internal.BasicTorque basicTorque(resolveInFrame=resolveInFrame);
protected 
  Interfaces.ZeroPosition zeroPosition if 
       not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve);
equation 
  connect(basicForce.frame_a, frame_a);
  connect(basicForce.frame_b, frame_b);
  connect(basicTorque.frame_b, frame_b);
  connect(basicTorque.frame_a, frame_a);
  connect(basicForce.force, force);
  connect(basicTorque.torque, torque);
  connect(basicTorque.frame_resolve, frame_resolve);
  connect(basicForce.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, basicTorque.frame_resolve);
  connect(zeroPosition.frame_resolve, basicForce.frame_resolve);
end ForceAndTorque;</code></pre>
<hr />
<h1 id="image56-modelica.mechanics.multibody.forces.lineforcewithmass"><img src="Modelica.Mechanics.MultiBody.Forces.LineForceWithMassI.png" alt="image56" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.LineForceWithMass</h1>
<p><strong>General line force component with an optional point mass on the connection line</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p>This component is used to exert a <strong>line force</strong> between the origin of frame_a and the origin of frame_b by attaching components of the <strong>1-dimensional translational</strong> mechanical library of Modelica (Modelica.Mechanics.Translational) between the two flange connectors <strong>flange_a</strong> and <strong>flange_b</strong>. Optionally, there is a <strong>point mass</strong> on the line connecting the origin of frame_a and the origin of frame_b. This point mass approximates the <strong>mass</strong> of the <strong>force element</strong>. The distance of the point mass from frame_a as a fraction of the distance between frame_a and frame_b is defined via parameter <strong>lengthFraction</strong> (default is 0.5, i.e., the point mass is in the middle of the line).</p>
<p>In the translational library there is the implicit assumption that forces of components that have only one flange connector act with opposite sign on the bearings of the component. This assumption is also used in the LineForceWithMass component: If a connection is present to only one of the flange connectors, then the force in this flange connector acts implicitly with opposite sign also in the other flange connector.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-6">Parameters</h2>
<table>
<col width="41%" />
<col width="9%" />
<col width="12%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animateLine</td>
<td align="left">true</td>
<td align="left">= true, if a line shape between frame_a and frame_b shall be visualized</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">animateMass</td>
<td align="left">true</td>
<td align="left">= true, if point mass shall be visualized as sphere provided m &gt; 0</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m</td>
<td align="left">0</td>
<td align="left">Mass of point mass on the connetion line between the origin of frame_a and the origin of frame_b [kg]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">lengthFraction</td>
<td align="left">0.5</td>
<td align="left">Location of point mass with respect to frame_a as a fraction of the distance from frame_a to frame_b [1]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left">if animateLine = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeType">ShapeType</a></td>
<td align="left">lineShapeType</td>
<td align="left">&quot;cylinder&quot;</td>
<td align="left">Type of shape visualizing the line from frame_a to frame_b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">lineShapeWidth</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Width of shape [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">lineShapeHeight</td>
<td align="left">lineShapeWidth</td>
<td align="left">Height of shape [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeExtra">ShapeExtra</a></td>
<td align="left">lineShapeExtra</td>
<td align="left">0.0</td>
<td align="left">Extra parameter for shape</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">lineShapeColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of line shape</td>
</tr>
<tr class="odd">
<td align="left">if animateMass = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">massDiameter</td>
<td align="left">world.defaultBodyDiameter</td>
<td align="left">Diameter of point mass sphere</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">massColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of point mass</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">s_small</td>
<td align="left">1.E-10</td>
<td align="left">Prevent zero-division if distance between frame_a and frame_b is zero [m]</td>
</tr>
<tr class="even">
<td align="left">If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_a</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_a.R is fixed (to directly connect line forces)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_b</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_b.R is fixed (to directly connect line forces)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-6">Connectors</h2>
<table>
<col width="50%" />
<col width="5%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_b</td>
<td align="left">1-dim. translational flange (connect force of Translational library between flange_a and flange_b)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_a</td>
<td align="left">1-dim. translational flange (connect force of Translational library between flange_a and flange_b)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>model LineForceWithMass 
  &quot;General line force component with an optional point mass on the connection line&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;
  extends Interfaces.PartialTwoFrames;
  Modelica.Mechanics.Translational.Interfaces.Flange_a flange_b 
    &quot;1-dim. translational flange (connect force of Translational library between flange_a and flange_b)&quot;;
  Modelica.Mechanics.Translational.Interfaces.Flange_b flange_a 
    &quot;1-dim. translational flange (connect force of Translational library between flange_a and flange_b)&quot;;


  parameter Boolean animateLine=true 
    &quot;= true, if a line shape between frame_a and frame_b shall be visualized&quot;;
  parameter Boolean animateMass=true 
    &quot;= true, if point mass shall be visualized as sphere provided m &gt; 0&quot;;
  parameter SI.Mass m(min=0)=0 
    &quot;Mass of point mass on the connetion line between the origin of frame_a and the origin of frame_b&quot;;
  parameter Real lengthFraction(
    unit=&quot;1&quot;,
    min=0,
    max=1) = 0.5 
    &quot;Location of point mass with respect to frame_a as a fraction of the distance from frame_a to frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter Types.ShapeType lineShapeType=&quot;cylinder&quot; 
    &quot;Type of shape visualizing the line from frame_a to frame_b&quot;;
  input SI.Length lineShapeWidth=world.defaultArrowDiameter &quot;Width of shape&quot;;
  input SI.Length lineShapeHeight=lineShapeWidth &quot;Height of shape&quot;;
  parameter Types.ShapeExtra lineShapeExtra=0.0 &quot;Extra parameter for shape&quot;;
  input Types.Color lineShapeColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot;Color of line shape&quot;;
  input Real massDiameter=world.defaultBodyDiameter 
    &quot;Diameter of point mass sphere&quot;;
  input Types.Color massColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot;Color of point mass&quot;;
  parameter SI.Position s_small=1.E-10 
    &quot;Prevent zero-division if distance between frame_a and frame_b is zero&quot;;
  parameter Boolean fixedRotationAtFrame_a=false 
    &quot;=true, if rotation frame_a.R is fixed (to directly connect line forces)&quot;;
  parameter Boolean fixedRotationAtFrame_b=false 
    &quot;=true, if rotation frame_b.R is fixed (to directly connect line forces)&quot;;

  SI.Distance length 
    &quot;Distance between the origin of frame_a and the origin of frame_b&quot;;
  SI.Position r_rel_0[3] 
    &quot;Position vector from frame_a to frame_b resolved in world frame&quot;;
  Real e_rel_0[3](each final unit=&quot;1&quot;) 
    &quot;Unit vector in direction from frame_a to frame_b, resolved in world frame&quot;;

protected 
  SI.Force fa &quot;Force from flange_a&quot;;
  SI.Force fb &quot;Force from flange_b&quot;;
  SI.Position r_CM_0[3](stateSelect=StateSelect.avoid) 
    &quot;Position vector from world frame to point mass, resolved in world frame&quot;;
  SI.Velocity v_CM_0[3](stateSelect=StateSelect.avoid) 
    &quot;First derivative of r_CM_0&quot;;
  SI.Acceleration ag_CM_0[3] &quot;der(v_CM_0) - gravityAcceleration&quot;;

  Visualizers.Advanced.Shape lineShape(
    shapeType=lineShapeType,
    color=lineShapeColor,
    specularCoefficient=specularCoefficient,
    length=length,
    width=lineShapeWidth,
    height=lineShapeHeight,
    lengthDirection=e_rel_0,
    widthDirection=Frames.resolve1(frame_a.R, {0,1,0}),
    extra=lineShapeExtra,
    r=frame_a.r_0) if world.enableAnimation and animateLine;

  Visualizers.Advanced.Shape massShape(
    shapeType=&quot;sphere&quot;,
    color=massColor,
    specularCoefficient=specularCoefficient,
    length=massDiameter,
    width=massDiameter,
    height=massDiameter,
    lengthDirection=e_rel_0,
    widthDirection={0,1,0},
    r_shape=e_rel_0*(length*lengthFraction - massDiameter/2),
    r=frame_a.r_0) if world.enableAnimation and animateMass and m &gt; 0;
equation 
  assert(noEvent(length &gt; s_small), &quot;
The distance between the origin of frame_a and the origin of frame_b
of a LineForceWithMass component became smaller as parameter s_small
(= a small number, defined in the \&quot;Advanced\&quot; menu). The distance is
set to s_small, although it is smaller, to avoid a division by zero
when computing the direction of the line force. Possible reasons
for this situation:
- At initial time the distance may already be zero: Change the initial
  positions of the bodies connected by this element.
- Hardware stops are not modeled or are modeled not stiff enough.
  Include stops, e.g., stiff springs, or increase the stiffness
  if already present.
- Another error in your model may lead to unrealistically large forces
  and torques that would in reality destroy the stops.
- The flange_b connector might be defined by a pre-defined motion,
  e.g., with Modelica.Mechanics.Translational.Position and the
  predefined flange_b.s is zero or negative.
&quot;);

  // Determine relative position vector between the two frames
  r_rel_0 = frame_b.r_0 - frame_a.r_0;
  length = Modelica.Math.Vectors.length(
                         r_rel_0);
  flange_a.s = 0;
  flange_b.s = length;
  e_rel_0 = r_rel_0/Frames.Internal.maxWithoutEvent(length, s_small);

  // Determine translational flange forces
  if cardinality(flange_a) &gt; 0 and cardinality(flange_b) &gt; 0 then
    fa = flange_a.f;
    fb = flange_b.f;
  elseif cardinality(flange_a) &gt; 0 and cardinality(flange_b) == 0 then
    fa = flange_a.f;
    fb = -fa;
  elseif cardinality(flange_a) == 0 and cardinality(flange_b) &gt; 0 then
    fa = -fb;
    fb = flange_b.f;
  else
    fa = 0;
    fb = 0;
  end if;

  /* Force and torque balance of point mass
     - Kinematics for center of mass CM of point mass including gravity
       r_CM_0 = frame_a.r0 + r_rel_CM_0;
       v_CM_0 = der(r_CM_0);
       ag_CM_0 = der(v_CM_0) - world.gravityAcceleration(r_CM_0);
     - Power balance for the connection line
       (f1=force on frame_a side, f2=force on frame_b side, h=lengthFraction)
       0 = f1*va - m*ag_CM*(va+(vb-va)*h) + f2*vb
         = (f1 - m*ag_CM*(1-h))*va + (f2 - m*ag_CM*h)*vb
       since va and vb are completely indepedent from other
       the paranthesis must vanish:
         f1 := m*ag_CM*(1-h)
         f2 := m*ag_CM*h
     - Force balance on frame_a and frame_b finally results in
         0 = frame_a.f + e_rel_a*fa - f1_a
         0 = frame_b.f + e_rel_b*fb - f2_b
       and therefore
         frame_a.f = -e_rel_a*fa + m*ag_CM_a*(1-h)
         frame_b.f = -e_rel_b*fb + m*ag_CM_b*h
  */
  if m &gt; 0 then
    r_CM_0 = frame_a.r_0 + r_rel_0*lengthFraction;
    v_CM_0 = der(r_CM_0);
    ag_CM_0 = der(v_CM_0) - world.gravityAcceleration(r_CM_0);
    frame_a.f = Frames.resolve2(frame_a.R, (m*(1 - lengthFraction))*ag_CM_0
       - e_rel_0*fa);
    frame_b.f = Frames.resolve2(frame_b.R, (m*lengthFraction)*ag_CM_0 -
      e_rel_0*fb);
  else
    r_CM_0 = zeros(3);
    v_CM_0 = zeros(3);
    ag_CM_0 = zeros(3);
    frame_a.f = -Frames.resolve2(frame_a.R, e_rel_0*fa);
    frame_b.f = -Frames.resolve2(frame_b.R, e_rel_0*fb);
  end if;

  // Provide appropriate equations, if direct connections of line forces
  if fixedRotationAtFrame_a then
    Connections.root(frame_a.R);
    frame_a.R = Frames.nullRotation();
  else
    frame_a.t = zeros(3);
  end if;

  if fixedRotationAtFrame_b then
    Connections.root(frame_b.R);
    frame_b.R = Frames.nullRotation();
  else
    frame_b.t = zeros(3);
  end if;
end LineForceWithMass;</code></pre>
<hr />
<h1 id="image57-modelica.mechanics.multibody.forces.lineforcewithtwomasses"><img src="Modelica.Mechanics.MultiBody.Forces.LineForceWithTwoMassesI.png" alt="image57" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.LineForceWithTwoMasses</h1>
<p><strong>General line force component with two optional point masses on the connection line</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<p>This component is used to exert a <strong>line force</strong> between the origin of frame_a and the origin of frame_b by attaching components of the <strong>1-dimensional translational</strong> mechanical library of Modelica (Modelica.Mechanics.Translational) between the two flange connectors <strong>flange_a</strong> and <strong>flange_b</strong>. Optionally, there are <strong>two point masses</strong> on the line connecting the origin of frame_a and the origin of frame_b. These point masses approximate the <strong>masses</strong> of the <strong>force element</strong>. The locations of the two point masses are defined by their (fixed) distances of L_a relative to frame_a and of L_b relative to frame_b, respectively.</p>
<p>In example <a href="Modelica_Mechanics_MultiBody_Examples_Elementary.html#Modelica.Mechanics.MultiBody.Examples.Elementary.LineForceWithTwoMasses">MultiBody.Examples.Elementary.LineForceWithTwoMasses</a> the usage of this line force element is shown and is compared with an alternative implementation using a <a href="Modelica_Mechanics_MultiBody_Joints_Assemblies.html#Modelica.Mechanics.MultiBody.Joints.Assemblies.JointUPS">MultiBody.Joints.Assemblies.JointUPS</a> component. The composition diagram of this example is displayed in the figure below.</p>
<p>The animation view at time = 0 is shown in the next figure. The system on the left side in the front is the animation with the LineForceWithTwoMasses component whereas the system on the right side in the back is the animation with the JointUPS component. Both implementations yield the same result. However, the implementation with the LineForceWithTwoMasses component is simpler.</p>
<p>In the translational library there is the implicit assumption that forces of components that have only one flange connector act with opposite sign on the bearings of the component. This assumption is also used in the LineForceWithTwoMasses component: If a connection is present to only one of the flange connectors, then the force in this flange connector acts implicitly with opposite sign also in the other flange connector.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-7">Parameters</h2>
<table>
<col width="41%" />
<col width="9%" />
<col width="12%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animate</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">animateMasses</td>
<td align="left">true</td>
<td align="left">= true, if point masses shall be visualized provided animate=true and m_a, m_b &gt; 0</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m_a</td>
<td align="left">0</td>
<td align="left">Mass of point mass a on the connetion line between the origin of frame_a and the origin of frame_b [kg]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m_b</td>
<td align="left">0</td>
<td align="left">Mass of point mass b on the connetion line between the origin of frame_a and the origin of frame_b [kg]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">L_a</td>
<td align="left">0</td>
<td align="left">Distance between point mass a and frame_a (positive, if in direction of frame_b) [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">L_b</td>
<td align="left">L_a</td>
<td align="left">Distance between point mass b and frame_b (positive, if in direction of frame_a) [m]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Cylinder at frame_a if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">cylinderDiameter_a</td>
<td align="left">world.defaultForceWidth</td>
<td align="left">Diameter of cylinder at frame_a [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">cylinderLength_a</td>
<td align="left">2*L_a</td>
<td align="left">Length of cylinder at frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color_a</td>
<td align="left">{155,155,155}</td>
<td align="left">Color of cylinder at frame_a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left">Cylinder at frame_b if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">diameterFraction</td>
<td align="left">0.8</td>
<td align="left">Diameter of cylinder at frame_b with respect to diameter of cylinder at frame_a</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">cylinderLength_b</td>
<td align="left">2*L_b</td>
<td align="left">Length of cylinder at frame_b [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color_b</td>
<td align="left">{100,100,100}</td>
<td align="left">Color of cylinder at frame_b</td>
</tr>
<tr class="odd">
<td align="left">if animation = true and animateMasses = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">massDiameterFaction</td>
<td align="left">1.7</td>
<td align="left">Diameter of point mass spheres with respect to cylinderDiameter_a</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">massColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of point masses</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">s_small</td>
<td align="left">1.E-10</td>
<td align="left">Prevent zero-division if distance between frame_a and frame_b is zero [m]</td>
</tr>
<tr class="even">
<td align="left">If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_a</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_a.R is fixed (to directly connect line forces)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_b</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_b.R is fixed (to directly connect line forces)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-7">Connectors</h2>
<table>
<col width="50%" />
<col width="5%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_b</td>
<td align="left">1-dim. translational flange (connect force of Translational library between flange_a and flange_b)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_a</td>
<td align="left">1-dim. translational flange (connect force of Translational library between flange_a and flange_b)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>model LineForceWithTwoMasses 
  &quot;General line force component with two optional point masses on the connection line&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;

  extends Interfaces.PartialTwoFrames;
  Modelica.Mechanics.Translational.Interfaces.Flange_a flange_b 
    &quot;1-dim. translational flange (connect force of Translational library between flange_a and flange_b)&quot;;
  Modelica.Mechanics.Translational.Interfaces.Flange_b flange_a 
    &quot;1-dim. translational flange (connect force of Translational library between flange_a and flange_b)&quot;;


  parameter Boolean animate=true &quot;= true, if animation shall be enabled&quot;;
  parameter Boolean animateMasses=true 
    &quot;= true, if point masses shall be visualized provided animate=true and m_a, m_b &gt; 0&quot;;
  parameter SI.Mass m_a(min=0)=0 
    &quot;Mass of point mass a on the connetion line between the origin of frame_a and the origin of frame_b&quot;;
  parameter SI.Mass m_b(min=0)=0 
    &quot;Mass of point mass b on the connetion line between the origin of frame_a and the origin of frame_b&quot;;
  parameter SI.Position L_a=0 
    &quot;Distance between point mass a and frame_a (positive, if in direction of frame_b)&quot;;
  parameter SI.Position L_b=L_a 
    &quot;Distance between point mass b and frame_b (positive, if in direction of frame_a)&quot;;
  input SI.Diameter cylinderDiameter_a=world.defaultForceWidth 
    &quot; Diameter of cylinder at frame_a&quot;;
  parameter SI.Length cylinderLength_a=2*L_a &quot; Length of cylinder at frame_a&quot;;
  input Types.Color color_a={155,155,155} &quot; Color of cylinder at frame_a&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  input Real diameterFraction=0.8 
    &quot; Diameter of cylinder at frame_b with respect to diameter of cylinder at frame_a&quot;;
  parameter SI.Length cylinderLength_b=2*L_b &quot; Length of cylinder at frame_b&quot;;
  input Types.Color color_b={100,100,100} &quot; Color of cylinder at frame_b&quot;;
  input Real massDiameterFaction=1.7 
    &quot; Diameter of point mass spheres with respect to cylinderDiameter_a&quot;;
  input Types.Color massColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot; Color of point masses&quot;;
  parameter SI.Position s_small=1.E-10 
    &quot; Prevent zero-division if distance between frame_a and frame_b is zero&quot;;
  parameter Boolean fixedRotationAtFrame_a=false 
    &quot;=true, if rotation frame_a.R is fixed (to directly connect line forces)&quot;;
  parameter Boolean fixedRotationAtFrame_b=false 
    &quot;=true, if rotation frame_b.R is fixed (to directly connect line forces)&quot;;

  SI.Distance length 
    &quot;Distance between the origin of frame_a and the origin of frame_b&quot;;
  SI.Position r_rel_0[3] 
    &quot;Position vector from frame_a to frame_b resolved in world frame&quot;;
  Real e_rel_0[3](each final unit=&quot;1&quot;) 
    &quot;Unit vector in direction from frame_a to frame_b, resolved in world frame&quot;;

protected 
  SI.Force fa &quot;Force from flange_a&quot;;
  SI.Force fb &quot;Force from flange_b&quot;;
  SI.Position r_CM1_0[3](stateSelect=StateSelect.avoid) 
    &quot;Position vector from world frame to point mass 1, resolved in world frame&quot;;
  SI.Position r_CM2_0[3](stateSelect=StateSelect.avoid) 
    &quot;Position vector from world frame to point mass 2, resolved in world frame&quot;;
  SI.Velocity v_CM1_0[3](stateSelect=StateSelect.avoid) 
    &quot;der(r_CM_1_0) - velocity of point mass 1&quot;;
  SI.Velocity v_CM2_0[3](stateSelect=StateSelect.avoid) 
    &quot;der(r_CM_2_0) - velocity of point mass 2&quot;;
  SI.Acceleration ag_CM1_0[3] &quot;der(v_CM1_0) - gravityAcceleration(r_CM1_0)&quot;;
  SI.Acceleration ag_CM2_0[3] &quot;der(v_CM2_0) - gravityAcceleration(r_CM2_0)&quot;;
  SI.Force aux1_0[3] &quot;Auxiliary force 1&quot;;
  SI.Force aux2_0[3] &quot;Auxiliary force 2&quot;;

  input SI.Length cylinderDiameter_b=cylinderDiameter_a*diameterFraction;
  input SI.Length massDiameter=cylinderDiameter_a*massDiameterFaction;
  parameter Boolean animateMasses2=world.enableAnimation and animate and animateMasses and m_a &gt; 0 and m_b &gt; 0;
  Visualizers.Advanced.Shape cylinder_a(
    shapeType=&quot;cylinder&quot;,
    color=color_a,
    specularCoefficient=specularCoefficient,
    length=cylinderLength_a,
    width=cylinderDiameter_a,
    height=cylinderDiameter_a,
    lengthDirection=e_rel_0,
    widthDirection={0,1,0},
    r=frame_a.r_0) if world.enableAnimation and animate;

  Visualizers.Advanced.Shape cylinder_b(
    shapeType=&quot;cylinder&quot;,
    color=color_b,
    specularCoefficient=specularCoefficient,
    length=cylinderLength_b,
    width=cylinderDiameter_b,
    height=cylinderDiameter_b,
    lengthDirection=-e_rel_0,
    widthDirection={0,1,0},
    r=frame_b.r_0) if world.enableAnimation and animate;

  Visualizers.Advanced.Shape sphere_a(
    shapeType=&quot;sphere&quot;,
    color=massColor,
    specularCoefficient=specularCoefficient,
    length=massDiameter,
    width=massDiameter,
    height=massDiameter,
    lengthDirection=e_rel_0,
    widthDirection={0,1,0},
    r_shape=e_rel_0*(L_a - massDiameter/2),
    r=frame_a.r_0) if animateMasses2;

  Visualizers.Advanced.Shape sphere_b(
    shapeType=&quot;sphere&quot;,
    color=massColor,
    specularCoefficient=specularCoefficient,
    length=massDiameter,
    width=massDiameter,
    height=massDiameter,
    lengthDirection=-e_rel_0,
    widthDirection={0,1,0},
    r_shape=-e_rel_0*(L_b - massDiameter/2),
    r=frame_b.r_0) if animateMasses2;
equation 
  assert(noEvent(length &gt; s_small), &quot;
The distance between the origin of frame_a and the origin of frame_b
of a LineForceWithTwoMasses component became smaller as parameter s_small
(= a small number, defined in the \&quot;Advanced\&quot; menu). The distance is
set to s_small, although it is smaller, to avoid a division by zero
when computing the direction of the line force. Possible reasons
for this situation:
- At initial time the distance may already be zero: Change the initial
  positions of the bodies connected by this element.
- Hardware stops are not modeled or are modeled not stiff enough.
  Include stops, e.g., stiff springs, or increase the stiffness
  if already present.
- Another error in your model may lead to unrealistically large forces
  and torques that would in reality destroy the stops.
- The flange_b connector might be defined by a pre-defined motion,
  e.g., with Modelica.Mechanics.Translational.Position and the
  predefined flange_b.s is zero or negative.
&quot;);

  // Determine relative position vector between the two frames
  r_rel_0 = frame_b.r_0 - frame_a.r_0;
  length = Modelica.Math.Vectors.length(
                         r_rel_0);
  flange_a.s = 0;
  flange_b.s = length;
  e_rel_0 = r_rel_0/Frames.Internal.maxWithoutEvent(length, s_small);

  // Determine translational flange forces
  if cardinality(flange_a) &gt; 0 and cardinality(flange_b) &gt; 0 then
    fa = flange_a.f;
    fb = flange_b.f;
  elseif cardinality(flange_a) &gt; 0 and cardinality(flange_b) == 0 then
    fa = flange_a.f;
    fb = -fa;
  elseif cardinality(flange_a) == 0 and cardinality(flange_b) &gt; 0 then
    fa = -fb;
    fb = flange_b.f;
  else
    fa = 0;
    fb = 0;
  end if;

  /* Force and torque balance of the two point masses
     - Kinematics for center of masses CM1, CM2 of point masses including gravity
       (L = length, va = der(frame_a.r_0), vb = der(frame_b.r_0))
       r_CM1_0 = frame_a.r_0 + e_rel_0*L_a;
       r_CM2_0 = frame_b.r_0 - e_rel_0*L_b;
       v_CM1_0 = der(r_CM1_0);
       v_CM2_0 = der(r_CM2_0);
       ag_CM1_0 = der(v_CM1_0) - world.gravityAcceleration(r_CM1_0);
       ag_CM2_0 = der(v_CM2_0) - world.gravityAcceleration(r_CM2_0);
       der(e_rel_0) = der(r_rel_0/sqrt(r_rel_0*r_rel_0))
                    = 1/L*(I - e_rel_0*e_rel_0&#39;)*der(r_rel_0)
                    = 1/L*(I - e_rel_0*e_rel_0&#39;)*(vb - va)
       v_CM1_0 = va + L_a/L*(I - e_rel_0*e_rel_0&#39;)*(vb - va)
       v_CM2_0 = vb - L_b/L*(I - e_rel_0*e_rel_0&#39;)*(vb - va)
     - Power balance for the connection line
       (f1=force on frame_a side, f2=force on frame_b side)
       0 = f1*va - m_a*ag_CM1*v_CM1 + f2*vb - m_b*ag_CM2*v_CM2
         = f1*va - m_a*ag_CM1*(va + L_a/L*(I - e_rel*e_rel&#39;)*(vb - va)) +
           f2*vb - m_b*ag_CM2*(vb - L_b/L*(I - e_rel*e_rel&#39;)*(vb - va))
         = (f1 - m_a*ag_CM1*(I - L_a/L*(I - e_rel*e_rel&#39;))
               - m_b*ag_CM2*(L_b/L*(I - e_rel*e_rel&#39;)))*va +
           (f2 - m_b*ag_CM2*(I - L_b/L*(I - e_rel_0*e_rel_0&#39;))
               - m_a*ag_CM1*(L_a/L*(I - e_rel*e_rel&#39;)))*vb
         = va*(f1 - m_a*ag_CM1 +
               (m_a*ag_CM1*L_a/L - m_b*ag_CM2*L_b/L)*(I - e_rel*e_rel&#39;)) +
           vb*(f2 - m_b*ag_CM2 +
               (m_b*ag_CM2*L_b/L - m_a*ag_CM1*L_a/L)*(I - e_rel*e_rel&#39;))
       since va and vb are completely independent from other
       the paranthesis must vanish:
         f1 := m_a*ag_CM1 - (m_a*ag_CM1*L_a/L - m_b*ag_CM2*L_b/L)*(I - e_rel*e_rel&#39;)
         f2 := m_b*ag_CM2 + (m_a*ag_CM1*L_a/L - m_b*ag_CM2*L_b/L)*(I - e_rel*e_rel&#39;)
       or
         aux1 := ag_CM1*(m_a*L_a/L) - ag_CM2*(m_b*L_b/L);
         aux2 := aux1 - (aux1&#39;*e_rel)*e_rel
         f1 := m_a*ag_CM1 - aux2
         f2 := m_b*ag_CM2 + aux2
     - Force balance on frame_a and frame_b finally results in
         0 = frame_a.f + e_rel_a*fa - f1_a
         0 = frame_b.f + e_rel_b*fb - f2_b
       and therefore
         frame_a.f = -e_rel_a*fa + m_a*ag_CM1 - aux2
         frame_b.f = -e_rel_b*fb + m_b*ag_CM2 + aux2
  */
  if m_a &gt; 0 or m_b &gt; 0 then
    r_CM1_0 = frame_a.r_0 + e_rel_0*L_a;
    r_CM2_0 = frame_b.r_0 - e_rel_0*L_b;
    v_CM1_0 = der(r_CM1_0);
    v_CM2_0 = der(r_CM2_0);
    ag_CM1_0 = der(v_CM1_0) - world.gravityAcceleration(r_CM1_0);
    ag_CM2_0 = der(v_CM2_0) - world.gravityAcceleration(r_CM2_0);
    aux1_0 = ag_CM1_0*(m_a*L_a/length) - ag_CM2_0*(m_b*L_b/length);
    aux2_0 = aux1_0 - (aux1_0*e_rel_0)*e_rel_0;
    frame_a.f = Frames.resolve2(frame_a.R, m_a*ag_CM1_0 - aux2_0 - e_rel_0*fa);
    frame_b.f = Frames.resolve2(frame_b.R, m_b*ag_CM2_0 + aux2_0 - e_rel_0*fb);
  else
    r_CM1_0 = zeros(3);
    r_CM2_0 = zeros(3);
    v_CM1_0 = zeros(3);
    v_CM2_0 = zeros(3);
    ag_CM1_0 = zeros(3);
    ag_CM2_0 = zeros(3);
    aux1_0 = zeros(3);
    aux2_0 = zeros(3);
    frame_a.f = -Frames.resolve2(frame_a.R, e_rel_0*fa);
    frame_b.f = -Frames.resolve2(frame_b.R, e_rel_0*fb);
  end if;

  // Provide appropriate equations, if direct connections of line forces
  if fixedRotationAtFrame_a then
    Connections.root(frame_a.R);
    frame_a.R = Frames.nullRotation();
  else
    frame_a.t = zeros(3);
  end if;

  if fixedRotationAtFrame_b then
    Connections.root(frame_b.R);
    frame_b.R = Frames.nullRotation();
  else
    frame_b.t = zeros(3);
  end if;

end LineForceWithTwoMasses;</code></pre>
<hr />
<h1 id="image58-modelica.mechanics.multibody.forces.spring"><img src="Modelica.Mechanics.MultiBody.Forces.SpringI.png" alt="image58" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.Spring</h1>
<p><strong>Linear translational spring with optional mass</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<p><strong>Linear spring</strong> acting as line force between frame_a and frame_b. A <strong>force f</strong> is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:</p>
<pre><code>f = c*(s - s_unstretched);</code></pre>
<p>where &quot;c&quot; and &quot;s_unstretched&quot; are parameters and &quot;s&quot; is the distance between the origin of frame_a and the origin of frame_b.</p>
<p>Optionally, the mass of the spring is taken into account by a point mass located on the line between frame_a and frame_b (default: middle of the line). If the spring mass is zero, the additional equations to handle the mass are removed.</p>
<p>In the following figure a typical animation of the spring is shown. The blue sphere in the middle of the spring characterizes the location of the point mass.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-8">Parameters</h2>
<table>
<col width="37%" />
<col width="8%" />
<col width="11%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">showMass</td>
<td align="left">true</td>
<td align="left">= true, if point mass shall be visualized as sphere if animation=true and m&gt;0</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.TranslationalSpringConstant">TranslationalSpringConstant</a></td>
<td align="left">c</td>
<td align="left">
</td>
<td align="left">Spring constant [N/m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">s_unstretched</td>
<td align="left">0</td>
<td align="left">Unstretched spring length [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m</td>
<td align="left">0</td>
<td align="left">Spring mass located on the connetion line between the origin of frame_a and the origin of frame_b [kg]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">lengthFraction</td>
<td align="left">0.5</td>
<td align="left">Location of spring mass with respect to frame_a as a fraction of the distance from frame_a to frame_b (=0: at frame_a; =1: at frame_b)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">world.defaultForceWidth</td>
<td align="left">Width of spring [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">coilWidth</td>
<td align="left">width/10</td>
<td align="left">Width of spring coil [m]</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">numberOfWindings</td>
<td align="left">5</td>
<td align="left">Number of spring windings</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of spring</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left">if animation = true and showMass = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">massDiameter</td>
<td align="left">max(0, (width - 2*coilWidth)...</td>
<td align="left">Diameter of mass point sphere [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">massColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of mass point</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_a</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_a.R is fixed (to directly connect line forces)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_b</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_b.R is fixed (to directly connect line forces)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-8">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>model Spring &quot;Linear translational spring with optional mass&quot;
  import Modelica.Mechanics.MultiBody.Types;
  extends Interfaces.PartialTwoFrames;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Boolean showMass=true 
    &quot;= true, if point mass shall be visualized as sphere if animation=true and m&gt;0&quot;;

  parameter SI.TranslationalSpringConstant c(final min=0) &quot;Spring constant&quot;;
  parameter SI.Length s_unstretched=0 &quot;Unstretched spring length&quot;;
  parameter SI.Mass m(min=0)=0 
    &quot;Spring mass located on the connetion line between the origin of frame_a and the origin of frame_b&quot;;
  parameter Real lengthFraction(
    min=0,
    max=1) = 0.5 
    &quot;Location of spring mass with respect to frame_a as a fraction of the distance from frame_a to frame_b (=0: at frame_a; =1: at frame_b)&quot;;
  input SI.Distance width=world.defaultForceWidth &quot; Width of spring&quot;;
  input SI.Distance coilWidth=width/10 &quot; Width of spring coil&quot;;
  parameter Integer numberOfWindings=5 &quot; Number of spring windings&quot;;
  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.SpringColor 
    &quot; Color of spring&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  input SIunits.Diameter massDiameter=max(0, (width - 2*coilWidth)*0.9) 
    &quot; Diameter of mass point sphere&quot;;
  input Types.Color massColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot; Color of mass point&quot;;
  parameter Boolean fixedRotationAtFrame_a=false 
    &quot;=true, if rotation frame_a.R is fixed (to directly connect line forces)&quot;;
  parameter Boolean fixedRotationAtFrame_b=false 
    &quot;=true, if rotation frame_b.R is fixed (to directly connect line forces)&quot;;

  Forces.LineForceWithMass lineForce(
    animateLine=animation,
    animateMass=showMass,
    m=m,
    lengthFraction=lengthFraction,
    lineShapeType=&quot;spring&quot;,
    lineShapeHeight=coilWidth*2,
    lineShapeWidth=width,
    lineShapeExtra=numberOfWindings,
    lineShapeColor=color,
    specularCoefficient=specularCoefficient,
    massDiameter=massDiameter,
    massColor=massColor,
    fixedRotationAtFrame_a=fixedRotationAtFrame_a,
    fixedRotationAtFrame_b=fixedRotationAtFrame_b);
  Modelica.Mechanics.Translational.Components.Spring spring(
                                                 s_rel0=s_unstretched, c=c);

equation 
  connect(lineForce.frame_a, frame_a);
  connect(lineForce.frame_b, frame_b);
  connect(spring.flange_b, lineForce.flange_b);
  connect(spring.flange_a, lineForce.flange_a);

end Spring;</code></pre>
<hr />
<h1 id="image59-modelica.mechanics.multibody.forces.damper"><img src="Modelica.Mechanics.MultiBody.Forces.DamperI.png" alt="image59" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.Damper</h1>
<p><strong>Linear (velocity dependent) damper</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<p><strong>Linear damper</strong> acting as line force between frame_a and frame_b. A <strong>force f</strong> is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:</p>
<pre><code>f = d*der(s);</code></pre>
<p>where &quot;d&quot; is a parameter, &quot;s&quot; is the distance between the origin of frame_a and the origin of frame_b and der(s) is the time derivative of &quot;s&quot;.</p>
<p>In the following figure a typical animation is shown where a mass is hanging on a damper.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce">Interfaces.PartialLineForce</a> (Base model for line force elements), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-9">Parameters</h2>
<table>
<col width="46%" />
<col width="10%" />
<col width="13%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.TranslationalDampingConstant">TranslationalDampingConstant</a></td>
<td align="left">d</td>
<td align="left">
</td>
<td align="left">Damping constant [N.s/m]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Temperature">Temperature</a></td>
<td align="left">T</td>
<td align="left">293.15</td>
<td align="left">Fixed device temperature if useHeatPort = false [K]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">length_a</td>
<td align="left">world.defaultForceLength</td>
<td align="left">Length of cylinder at frame_a side [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">diameter_a</td>
<td align="left">world.defaultForceWidth</td>
<td align="left">Diameter of cylinder at frame_a side [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">diameter_b</td>
<td align="left">0.6*diameter_a</td>
<td align="left">Diameter of cylinder at frame_b side [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color_a</td>
<td align="left">{100,100,100}</td>
<td align="left">Color at frame_a</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color_b</td>
<td align="left">{155,155,155}</td>
<td align="left">Color at frame_b</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">s_small</td>
<td align="left">1.E-6</td>
<td align="left">Prevent zero-division if relative distance s=0 [m]</td>
</tr>
<tr class="odd">
<td align="left">If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_a</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_a.R is fixed (to directly connect line forces)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_b</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_b.R is fixed (to directly connect line forces)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-9">Connectors</h2>
<table>
<col width="55%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the force element with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the force element with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>model Damper &quot;Linear (velocity dependent) damper&quot;
  import Modelica.Mechanics.MultiBody.Types;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter SI.TranslationalDampingConstant d(final min=0, start = 0) 
    &quot;Damping constant&quot;;
  parameter SI.Distance length_a=world.defaultForceLength 
    &quot; Length of cylinder at frame_a side&quot;;
  input SIunits.Diameter diameter_a=world.defaultForceWidth 
    &quot; Diameter of cylinder at frame_a side&quot;;
  input SIunits.Diameter diameter_b=0.6*diameter_a 
    &quot; Diameter of cylinder at frame_b side&quot;;
  input Types.Color color_a={100,100,100} &quot; Color at frame_a&quot;;
  input Types.Color color_b={155,155,155} &quot; Color at frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  extends Interfaces.PartialLineForce;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort
    (final T=293.15);
protected 
  SI.Position r0_b[3]=e_a*noEvent(min(length_a, s));
  Visualizers.Advanced.Shape shape_a(
    shapeType=&quot;cylinder&quot;,
    color=color_a,
    specularCoefficient=specularCoefficient,
    length=noEvent(min(length_a, s)),
    width=diameter_a,
    height=diameter_a,
    lengthDirection=e_a,
    widthDirection={0,1,0},
    r=frame_a.r_0,
    R=frame_a.R) if 
                   world.enableAnimation and animation;
  Visualizers.Advanced.Shape shape_b(
    shapeType=&quot;cylinder&quot;,
    color=color_b,
    specularCoefficient=specularCoefficient,
    length=noEvent(max(s - length_a, 0)),
    width=diameter_b,
    height=diameter_b,
    lengthDirection=e_a,
    widthDirection={0,1,0},
    r_shape=r0_b,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
equation 
  f = d*der(s);
  lossPower = f*der(s);
end Damper;</code></pre>
<hr />
<h1 id="image60-modelica.mechanics.multibody.forces.springdamperparallel"><img src="Modelica.Mechanics.MultiBody.Forces.SpringDamperParallelI.png" alt="image60" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.SpringDamperParallel</h1>
<p><strong>Linear spring and linear damper in parallel</strong></p>
<h2 id="information-11">Information</h2>
<p>::</p>
<p><strong>Linear spring</strong> and <strong>dinear damper</strong> in parallel acting as line force between frame_a and frame_b. A <strong>force f</strong> is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equation:</p>
<pre><code>f = c*(s - s_unstretched) + d*der(s);</code></pre>
<p>where &quot;c&quot;, &quot;s_unstretched&quot; and &quot;d&quot; are parameters, &quot;s&quot; is the distance between the origin of frame_a and the origin of frame_b and der(s) is the time derivative of s.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce">Interfaces.PartialLineForce</a> (Base model for line force elements), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-10">Parameters</h2>
<table>
<col width="46%" />
<col width="10%" />
<col width="13%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.TranslationalSpringConstant">TranslationalSpringConstant</a></td>
<td align="left">c</td>
<td align="left">
</td>
<td align="left">Spring constant [N/m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">s_unstretched</td>
<td align="left">0</td>
<td align="left">Unstretched spring length [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.TranslationalDampingConstant">TranslationalDampingConstant</a></td>
<td align="left">d</td>
<td align="left">0</td>
<td align="left">Damping constant [N.s/m]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Temperature">Temperature</a></td>
<td align="left">T</td>
<td align="left">293.15</td>
<td align="left">Fixed device temperature if useHeatPort = false [K]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">world.defaultForceWidth</td>
<td align="left">Width of spring [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">coilWidth</td>
<td align="left">width/10</td>
<td align="left">Width of spring coil [m]</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">numberOfWindings</td>
<td align="left">5</td>
<td align="left">Number of spring windings</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of spring</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">s_small</td>
<td align="left">1.E-6</td>
<td align="left">Prevent zero-division if relative distance s=0 [m]</td>
</tr>
<tr class="even">
<td align="left">If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_a</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_a.R is fixed (to directly connect line forces)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_b</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_b.R is fixed (to directly connect line forces)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-10">Connectors</h2>
<table>
<col width="55%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the force element with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the force element with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>model SpringDamperParallel 
  &quot;Linear spring and linear damper in parallel&quot;
  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter SI.TranslationalSpringConstant c(final min=0) &quot;Spring constant&quot;;
  parameter SI.Length s_unstretched=0 &quot;Unstretched spring length&quot;;
  parameter SI.TranslationalDampingConstant d(final min=0) = 0 
    &quot;Damping constant&quot;;
  input SI.Distance width=world.defaultForceWidth &quot; Width of spring&quot;;
  input SI.Distance coilWidth=width/10 &quot; Width of spring coil&quot;;
  parameter Integer numberOfWindings=5 &quot; Number of spring windings&quot;;
  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.SpringColor 
    &quot; Color of spring&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  extends Interfaces.PartialLineForce;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort
    (final T=293.15);

protected 
  Modelica.SIunits.Force f_d &quot;Damping force&quot;;
  Visualizers.Advanced.Shape shape(
    shapeType=&quot;spring&quot;,
    color=color,
    length=s,
    width=width,
    height=coilWidth*2,
    lengthDirection=e_a,
    widthDirection={0,1,0},
    extra=numberOfWindings,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
equation 
  f_d = d*der(s);
  f = c*(s - s_unstretched) + f_d;
  lossPower = f_d*der(s);
end SpringDamperParallel;</code></pre>
<hr />
<h1 id="image61-modelica.mechanics.multibody.forces.springdamperseries"><img src="Modelica.Mechanics.MultiBody.Forces.SpringDamperSeriesI.png" alt="image61" /> <a href="Modelica_Mechanics_MultiBody_Forces.html#Modelica.Mechanics.MultiBody.Forces">Modelica.Mechanics.MultiBody.Forces</a>.SpringDamperSeries</h1>
<p><strong>Linear spring and linear damper in series connection</strong></p>
<h2 id="information-12">Information</h2>
<p>::</p>
<p><strong>Linear spring</strong> and <strong>linear damper</strong> in series connection acting as line force between frame_a and frame_b:</p>
<pre><code>frame_a --&gt; damper ----&gt; spring --&gt; frame_b
        |              |
        |-- s_damper --|  (s_damper is the state variable of this system)</code></pre>
<p>A <strong>force f</strong> is exerted on the origin of frame_b and with opposite sign on the origin of frame_a along the line from the origin of frame_a to the origin of frame_b according to the equations:</p>
<pre><code>f = c*(s - s_unstretched - s_damper);
f = d*der(s_damper);</code></pre>
<p>where &quot;c&quot;, &quot;s_unstretched&quot; and &quot;d&quot; are parameters, &quot;s&quot; is the distance between the origin of frame_a and the origin of frame_b. &quot;s_damper&quot; is the length of the damper (= an internal state of this force element) and der(s_damper) is the time derivative of s_damper.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialLineForce">Interfaces.PartialLineForce</a> (Base model for line force elements), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-11">Parameters</h2>
<table>
<col width="47%" />
<col width="12%" />
<col width="5%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.TranslationalSpringConstant">TranslationalSpringConstant</a></td>
<td align="left">c</td>
<td align="left">
</td>
<td align="left">Spring constant [N/m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">s_unstretched</td>
<td align="left">0</td>
<td align="left">Unstretched spring length [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.TranslationalDampingConstant">TranslationalDampingConstant</a></td>
<td align="left">d</td>
<td align="left">0</td>
<td align="left">Damping constant [N.s/m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">s_damper_start</td>
<td align="left">0</td>
<td align="left">Initial length of damper [m]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Temperature">Temperature</a></td>
<td align="left">T</td>
<td align="left">293.15</td>
<td align="left">Fixed device temperature if useHeatPort = false [K]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">s_small</td>
<td align="left">1.E-6</td>
<td align="left">Prevent zero-division if relative distance s=0 [m]</td>
</tr>
<tr class="odd">
<td align="left">If enabled, can give wrong results, see MultiBody.UsersGuide.Tutorial.ConnectionOfLineForces</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_a</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_a.R is fixed (to directly connect line forces)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">fixedRotationAtFrame_b</td>
<td align="left">false</td>
<td align="left">=true, if rotation frame_b.R is fixed (to directly connect line forces)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-11">Connectors</h2>
<table>
<col width="55%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the force element with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the force element with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>model SpringDamperSeries 
  &quot;Linear spring and linear damper in series connection&quot;
  import SI = Modelica.SIunits;
  parameter SI.TranslationalSpringConstant c(final min=0) &quot;Spring constant&quot;;
  parameter SI.Length s_unstretched=0 &quot;Unstretched spring length&quot;;
  parameter SI.TranslationalDampingConstant d(final min=0) = 0 
    &quot;Damping constant&quot;;
  parameter SI.Length s_damper_start=0 &quot;Initial length of damper&quot;;
  SI.Position s_damper(start=s_damper_start, fixed=true) 
    &quot;Actual length of damper (frame_a - damper - spring - frame_b)&quot;;
  extends Interfaces.PartialLineForce;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPort
    (final T=293.15);
equation 
  f = c*(s - s_unstretched - s_damper);
  d*der(s_damper) = f;
  lossPower = f*der(s_damper);
end SpringDamperSeries;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:30:27 2010.</p>
</body>
</html>
