<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Math.Matrices</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Math.Matrices</h1>
</div>
<h1 id="modelica.math.matrices"><a href="Modelica_Math.html#Modelica.Math">Modelica.Math</a>.Matrices</h1>
<p><strong>Library of functions operating on matrices</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<h3 id="library-content">Library content</h3>
<p>This library provides functions operating on matrices. Below, the functions are ordered according to categories and a typical call of the respective function is shown. Most functions are solely an interface to the external <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK">LAPACK</a> library.</p>
<p>Note: A' is a short hand notation of transpose(A):</p>
<p><strong>Basic Information</strong></p>
<ul>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.toString">toString</a>(A)

- returns the string representation of matrix A.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual">isEqual</a>(M1, M2) - returns true if matrices M1 and M2 have the same size and the same elements.</li>
</ul>
<p><strong>Linear Equations</strong></p>
<ul>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">solve</a>(A,b)

- returns solution x of the linear equation A*x=b (where b is a vector, and A is a square matrix that must be regular).</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2">solve2</a>(A,B)

- returns solution X of the linear equation A*X=B (where B is a matrix, and A is a square matrix that must be regular)</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares">leastSquares</a>(A,b)

- returns solution x of the linear equation A*x=b in a least squares sense (where b is a vector and A may be non-square and may be rank deficient)</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares2">leastSquares2</a>(A,B)

- returns solution X of the linear equation A*X=B in a least squares sense (where B is a matrix and A may be non-square and may be rank deficient)</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.equalityLeastSquares">equalityLeastSquares</a>(A,a,B,b)

- returns solution x of a linear equality constrained least squares problem: min|A*x-a|^2 subject to B*x=b</li>
<li>(LU,p,info) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">LU</a>(A) -returns the LU decomposition with row pivoting of a rectangular matrix A.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve">LU_solve</a>(LU,p,b)

- returns solution x of the linear equation L*U*x[p]=b with a b vector and an LU decomposition from &quot;LU(..)&quot;.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2">LU_solve2</a>(LU,p,B)

- returns solution X of the linear equation L*U*X[p,:]=B with a B matrix and an LU decomposition from &quot;LU(..)&quot;.</li>
</ul>
<p><strong>Matrix Factorizations</strong></p>
<ul>
<li>(eval,evec) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues">eigenValues</a>(A)

- returns eigen values &quot;eval&quot; and eigen vectors &quot;evec&quot; for a real, nonsymmetric matrix A in a Real representation.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix">eigenValueMatrix</a>(eval)

- returns real valued block diagonal matrix of the eigenvalues &quot;eval&quot; of matrix A.</li>
<li>(sigma,U,VT) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues">singularValues</a>(A)

- returns singular values &quot;sigma&quot; and left and right singular vectors U and VT of a rectangular matrix A.</li>
<li>(Q,R,p) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.QR">QR</a>(A) -returns the QR decomposition with column pivoting of a rectangular matrix A such that Q*R = A[:,p].</li>
<li>(H,U) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.hessenberg">hessenberg</a>(A)

- returns the upper Hessenberg form H and the orthogonal transformation matrix U of a square matrix A such that H = U'*A*U.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.realSchur">realSchur</a>(A)

- returns the real Schur form of a square matrix A.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.cholesky">cholesky</a>(A)

- returns the cholesky factor H of a real symmetric positive definite matrix A so that A = H'*H.</li>
<li>(D,Aimproved) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.balance">balance</a>(A)

- returns an improved form Aimproved of a square matrix A that has a smaller condition as A, with Aimproved = inv(diagonal(D))*A*diagonal(D).</li>
</ul>
<p><strong>Matrix Properties</strong></p>
<ul>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.trace">trace</a>(A)

- returns the trace of square matrix A, i.e., the sum of the diagonal elements.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.det">det</a>(A) -returns the determinant of square matrix A (using LU decomposition; try to avoid det(..))</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.inv">inv</a>(A) -returns the inverse of square matrix A (try to avoid, use instead &quot;solve2(..) with B=identity(..))</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank">rank</a>(A)

- returns the rank of square matrix A (computed with singular value decomposition)</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.conditionNumber">conditionNumber</a>(A)

- returns the condition number norm(A)*norm(inv(A)) of a square matrix A in the range 1..∞.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rcond">rcond</a>(A)

- returns the reciprocal condition number 1/conditionNumber(A) of a square matrix A in the range 0..1.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm">norm</a>(A)

- returns the 1-, 2-, or infinity-norm of matrix A.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.frobeniusNorm">frobeniusNorm</a>(A)

- returns the Frobenius norm of matrix A.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.nullSpace">nullSpace</a>(A)

<ul>
<li>returns the null space of matrix A.</li>
</ul></li>
</ul>
<p><strong>Matrix Exponentials</strong></p>
<ul>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.exp">exp</a>(A) -returns the exponential e^A of a matrix A by adaptive Taylor series expansion with scaling and balancing</li>
<li>(phi, gamma) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExp">integralExp</a>(A,B)

- returns the exponential phi=e^A and the integral gamma=integral(exp(A*t)*dt)*B as needed for a discretized system with zero order hold.</li>
<li>(phi, gamma, gamma1) = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExpT">integralExpT</a>(A,B)

- returns the exponential phi=e^A, the integral gamma=integral(exp(A*t)*dt)*B, and the time-weighted integral gamma1 = integral((T-t)*exp(A*t)*dt)*B as needed for a discretized system with first order hold.</li>
</ul>
<p><strong>Matrix Equations</strong></p>
<ul>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousLyapunov">continuousLyapunov</a>(A,C)

- returns solution X of the continuous-time Lyapunov equation X*A + A'*X = C</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousSylvester">continuousSylvester</a>(A,B,C)

- returns solution X of the continuous-time Sylvester equation A*X + X*B = C</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati">continuousRiccati</a>(A,B,R,Q)

- returns solution X of the continuous-time algebraic Riccat equation A'*X + X*A - X*B*inv(R)*B'*X + Q = 0</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteLyapunov">discreteLyapunov</a>(A,C)

<ul>
<li>returns solution X of the discretes-time Lyapunov equation A'*X*A</li>
</ul>
+ sgn*X = C</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteSylvester">discreteSylvester</a>(A,B,C)

<ul>
<li>returns solution X of the discrete-time Sylvester equation A*X*B</li>
</ul>
+ sgn*X = C</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati">discreteRiccati</a>(A,B,R,Q)

- returns solution X of the discrete-time algebraic Riccat equation A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0</li>
</ul>
<p><strong>Matrix Manipulation</strong></p>
<ul>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.sort">sort</a>(M)

- returns the sorted rows or columns of matrix M in ascending or descending order.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.flipLeftRight">flipLeftRight</a>(M)

- returns matrix M so that the columns of M are flipped in left/right direction.</li>
<li><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.flipUpDown">flipUpDown</a>(M)

- returns matrix M so that the rows of M are flipped in up/down direction.</li>
</ul>
<h3 id="see-also">See also</h3>
<p><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Vectors</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="51%" />
<col width="48%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.ExamplesS.png" alt="image42" /> <a href="Modelica_Math_Matrices_Examples.html#Modelica.Math.Matrices.Examples">Examples</a></td>
<td align="left">Examples demonstrating the usage of the Math.Matrices functions</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.toStringS.png" alt="image43" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.toString">toString</a></td>
<td align="left">Convert a matrix into its string representation</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image44" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual">isEqual</a></td>
<td align="left">Compare whether two Real matrices are identical</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image45" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">solve</a></td>
<td align="left">Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image46" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2">solve2</a></td>
<td align="left">Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image47" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares">leastSquares</a></td>
<td align="left">Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image48" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares2">leastSquares2</a></td>
<td align="left">Solve linear equation A*X = B (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image49" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.equalityLeastSquares">equalityLeastSquares</a></td>
<td align="left">Solve a linear equality constrained least squares problem</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image50" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">LU</a></td>
<td align="left">LU decomposition of square or rectangular matrix</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image51" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve">LU_solve</a></td>
<td align="left">Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image52" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2">LU_solve2</a></td>
<td align="left">Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image53" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues">eigenValues</a></td>
<td align="left">Return eigenvalues and eigenvectors for a real, nonsymmetric matrix in a Real representation</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image54" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix">eigenValueMatrix</a></td>
<td align="left">Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image55" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues">singularValues</a></td>
<td align="left">Return singular values and left and right singular vectors</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.isEqualS.png" alt="image56" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.QR">QR</a></td>
<td align="left">Return the QR decomposition of a square matrix with optional column pivoting (A(:,p) = Q*R)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.hessenbergS.png" alt="image57" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.hessenberg">hessenberg</a></td>
<td align="left">Return upper Hessenberg form of a matrix</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.hessenbergS.png" alt="image58" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.realSchur">realSchur</a></td>
<td align="left">Return the real Schur form (rsf) S of a square matrix A, A=QZ*S*QZ'</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.hessenbergS.png" alt="image59" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.cholesky">cholesky</a></td>
<td align="left">Return the Cholesky factorization of a symmetric positive definite matrix</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image60" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.balance">balance</a></td>
<td align="left">Return a balanced form of matrix A to improve the condition of A</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image61" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.trace">trace</a></td>
<td align="left">Return the trace of matrix A, i.e., the sum of the diagonal elements</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image62" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.det">det</a></td>
<td align="left">Return determinant of a matrix (computed by LU decomposition; try to avoid det(..))</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image63" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.inv">inv</a></td>
<td align="left">Return inverse of a matrix (try to avoid inv(..))</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image64" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank">rank</a></td>
<td align="left">Return rank of a rectangular matrix (computed with singular values)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image65" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.conditionNumber">conditionNumber</a></td>
<td align="left">Return the condition number norm(A)*norm(inv(A)) of a matrix A</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image66" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rcond">rcond</a></td>
<td align="left">Return the reciprocal condition number of a matrix</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image67" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm">norm</a></td>
<td align="left">Return the p-norm of a matrix</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image68" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.frobeniusNorm">frobeniusNorm</a></td>
<td align="left">Return the Frobenius norm of a matrix</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image69" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.nullSpace">nullSpace</a></td>
<td align="left">Return the orthonormal nullspace of a matrix</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image70" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.exp">exp</a></td>
<td align="left">Return the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image71" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExp">integralExp</a></td>
<td align="left">Return the exponential and the integral of the exponential of a matrix</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.balanceS.png" alt="image72" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExpT">integralExpT</a></td>
<td align="left">Return the exponential, the integral of the exponential, and time-weighted integral of the exponential of a matrix</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.continuousLyapunovS.png" alt="image73" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousLyapunov">continuousLyapunov</a></td>
<td align="left">Return solution X of the continuous-time Lyapunov equation X*A + A'*X = C</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.continuousLyapunovS.png" alt="image74" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousSylvester">continuousSylvester</a></td>
<td align="left">Return solution X of the continuous-time Sylvester equation A*X + X*B = C</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.continuousLyapunovS.png" alt="image75" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati">continuousRiccati</a></td>
<td align="left">Return solution X of the continuous-time algebraic Riccati equation A'*X + X*A - X*B*inv(R)*B'*X + Q = 0 (care)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.continuousLyapunovS.png" alt="image76" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteLyapunov">discreteLyapunov</a></td>
<td align="left">Return solution X of the discrete-time Lyapunov equation A'*X*A + sgn*X = C</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.continuousLyapunovS.png" alt="image77" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteSylvester">discreteSylvester</a></td>
<td align="left">Return solution of the discrete-time Sylvester equation A*X*B + sgn*X = C</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.continuousLyapunovS.png" alt="image78" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati">discreteRiccati</a></td>
<td align="left">Return solution of discrete-time algebraic Riccati equation A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0 (dare)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.sortS.png" alt="image79" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.sort">sort</a></td>
<td align="left">Sort the rows or columns of a matrix in ascending or descending order</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.flipLeftRightS.png" alt="image80" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.flipLeftRight">flipLeftRight</a></td>
<td align="left">Flip the columns of a matrix in left/right direction</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.flipLeftRightS.png" alt="image81" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.flipUpDown">flipUpDown</a></td>
<td align="left">Flip the rows of a matrix in up/down direction</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Matrices.LAPACKS.png" alt="image82" /> <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK">LAPACK</a></td>
<td align="left">Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Matrices.LAPACKS.png" alt="image83" /> <a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities">Utilities</a></td>
<td align="left">Utility functions that should not be directly utilized by the user</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="modelica.math.matrices.tostring"><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.toString</h1>
<p><strong>Convert a matrix into its string representation</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<h3 id="syntax">Syntax</h3>
<blockquote>
<pre><code>Matrices.toString(A);
Matrices.toString(A, name=&quot;&quot;, significantDigits=6);</code></pre>
</blockquote>
<h3 id="description">Description</h3>
<p>The function call &quot;<code>Matrices.toString(A)</code>&quot; returns the string representation of matrix <strong>A</strong>. With the optional arguments &quot;name&quot; and &quot;significantDigits&quot;, a name and the number of the digits are defined. The default values of name and significantDigits are &quot;&quot; and 6 respectively. If name==&quot;&quot; then the prefix &quot;&lt;name&gt; =&quot; is leaved out.</p>
<h3 id="example">Example</h3>
<blockquote>
<pre><code>A = [2.12, -4.34; -2.56, -1.67];

toString(A);
// = &quot;
//      2.12   -4.34
//     -2.56   -1.67&quot;;

toString(A,&quot;A&quot;,1);
// = &quot;A =
//         2     -4
//        -3     -2&quot;</code></pre>
</blockquote>
<h3 id="see-also-1">See also</h3>
<p><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.toString">Vectors.toString</a></p>
<p>::</p>
<h2 id="inputs">Inputs</h2>
<table>
<col width="12%" />
<col width="23%" />
<col width="12%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">M[:, :]</td>
<td align="left">
</td>
<td align="left">Real matrix</td>
</tr>
<tr class="even">
<td align="left">String</td>
<td align="left">name</td>
<td align="left">&quot;&quot;</td>
<td align="left">Independent variable name used for printing</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">significantDigits</td>
<td align="left">6</td>
<td align="left">Number of significant digits that are shown</td>
</tr>
</tbody>
</table>
<h2 id="outputs">Outputs</h2>
<table>
<col width="15%" />
<col width="12%" />
<col width="47%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">String</td>
<td align="left">s</td>
<td align="left">String expression of matrix M</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>function toString &quot;Convert a matrix into its string representation &quot;
  import Modelica.Utilities.Strings;

  input Real M[:,:] &quot;Real matrix&quot;;
  input String name=&quot;&quot; &quot;Independent variable name used for printing&quot;;
  input Integer significantDigits=6 
    &quot;Number of significant digits that are shown&quot;;
  output String s=&quot;&quot; &quot;String expression of matrix M&quot;;
protected 
  String blanks=Strings.repeat(significantDigits);
  String space=Strings.repeat(8);
  String space2=Strings.repeat(3);
  Integer r=size(M, 1);
  Integer c=size(M, 2);

algorithm 
  if r == 0 or c == 0 then
    s := name + &quot; = []&quot;;
  else
    s := if name == &quot;&quot; then &quot;\n&quot; else &quot;\n&quot; + name + &quot; = \n&quot;;
    for i in 1:r loop
      s := s + space;
      for j in 1:c loop
        if M[i, j] &gt;= 0 then
          s := s + &quot; &quot;;
        end if;
        s := s + String(M[i, j], significantDigits=significantDigits) +
          Strings.repeat(significantDigits + 8 - Strings.length(String(abs(M[i,
          j]))));
      end for;
      s := s + &quot;\n&quot;;
    end for;

  end if;

end toString;</code></pre>
<hr />
<h1 id="image84-modelica.math.matrices.isequal"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image84" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.isEqual</h1>
<p><strong>Compare whether two Real matrices are identical</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<h3 id="syntax-1">Syntax</h3>
<blockquote>
<pre><code>Matrices.isEqual(M1, M2);
Matrices.isEqual(M1, M2, eps=0);</code></pre>
</blockquote>
<h3 id="description-1">Description</h3>
<p>The function call &quot;<code>Matrices.isEqual(M1, M2)</code>&quot; returns <strong>true</strong>, if the two Real matrices M1 and M2 have the same dimensions and the same elements. Otherwise the function returns <strong>false</strong>. Two elements e1 and e2 of the two matrices are checked on equality by the test &quot;abs(e1-e2) ≤ eps&quot;, where &quot;eps&quot; can be provided as third argument of the function. Default is &quot;eps = 0&quot;.</p>
<h3 id="example-1">Example</h3>
<blockquote>
<pre><code>Real A1[2,2] = [1,2; 3,4];
Real A2[3,2] = [1,2; 3,4; 5,6];
Real A3[2,2] = [1,2, 3,4.0001];
Boolean result;</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>result := Matrices.isEqual(M1,M2); // = false result := Matrices.isEqual(M1,M3); // = false result := Matrices.isEqual(M1,M1); // = true result := Matrices.isEqual(M1,M3,0.1); // = true</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-2">See also</h3>
<p><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual">Vectors.isEqual</a>, <a href="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.isEqual">Strings.isEqual</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-1">Inputs</h2>
<table>
<col width="7%" />
<col width="11%" />
<col width="10%" />
<col width="70%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">M1[:, :]</td>
<td align="left">
</td>
<td align="left">First matrix</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">M2[:, :]</td>
<td align="left">
</td>
<td align="left">Second matrix (may have different size as M1</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">0</td>
<td align="left">Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) &lt;= eps</td>
</tr>
</tbody>
</table>
<h2 id="outputs-1">Outputs</h2>
<table>
<col width="13%" />
<col width="12%" />
<col width="73%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">result</td>
<td align="left">= true, if matrices have the same size and the same elements</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>function isEqual &quot;Compare whether two Real matrices are identical&quot;
  extends Modelica.Icons.Function;
  input Real M1[:, :] &quot;First matrix&quot;;
  input Real M2[:, :] &quot;Second matrix (may have different size as M1&quot;;
  input Real eps(min=0) = 0 
    &quot;Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) &lt;= eps&quot;;
  output Boolean result 
    &quot;= true, if matrices have the same size and the same elements&quot;;

protected 
  Integer nrow=size(M1, 1) &quot;Number of rows of matrix M1&quot;;
  Integer ncol=size(M1, 2) &quot;Number of columns of matrix M1&quot;;
  Integer i=1;
  Integer j;
algorithm 
  result := false;
  if size(M2, 1) == nrow and size(M2, 2) == ncol then
    result := true;
    while i &lt;= nrow loop
      j := 1;
      while j &lt;= ncol loop
        if abs(M1[i, j] - M2[i, j]) &gt; eps then
          result := false;
          i := nrow;
          j := ncol;
        end if;
        j := j + 1;
      end while;
      i := i + 1;
    end while;
  end if;

end isEqual;</code></pre>
<hr />
<h1 id="image85-modelica.math.matrices.solve"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image85" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.solve</h1>
<p><strong>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<h3 id="syntax-2">Syntax</h3>
<blockquote>
<pre><code>Matrices.solve(A,b);</code></pre>
</blockquote>
<h3 id="description-2">Description</h3>
<p>This function call returns the solution <strong>x</strong> of the linear system of equations</p>
<blockquote>
<p><strong>A</strong>*<strong>x</strong> = <strong>b</strong></p>
</blockquote>
<p>If a unique solution <strong>x</strong> does not exist (since <strong>A</strong> is singular), an assertion is triggered. If this is not desired, use instead <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares">Matrices.leastSquares</a> and inquire the singularity of the solution with the return argument rank (a unique solution is computed if rank = size(A,1)).</p>
<p>Note, the solution is computed with the LAPACK function &quot;dgesv&quot;, i.e., by Gaussian elemination with partial pivoting.</p>
<h3 id="example-2">Example</h3>
<blockquote>
<pre><code>Real A[3,3] = [1,2,3;
               3,4,5;
               2,1,4];
Real b[3] = {10,22,12};
Real x[3];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>x := Matrices.solve(A,b); // x = {3,2,1}</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-3">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">Matrices.LU</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve">Matrices.LU_solve</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares">Matrices.leastSquares</a>.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-2">Inputs</h2>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Matrix A of A*x = b</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">b[size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Vector b of A*x = b</td>
</tr>
</tbody>
</table>
<h2 id="outputs-2">Outputs</h2>
<table>
<col width="12%" />
<col width="25%" />
<col width="44%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x[size(b, 1)]</td>
<td align="left">Vector x such that A*x = b</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>function solve 
  &quot;Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)&quot;

  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)] &quot;Matrix A of A*x = b&quot;;
  input Real b[size(A, 1)] &quot;Vector b of A*x = b&quot;;
  output Real x[size(b, 1)] &quot;Vector x such that A*x = b&quot;;

protected 
  Integer info;
algorithm 
  (x,info) := LAPACK.dgesv_vec(A, b);
  assert(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.solve\&quot; is not possible, because the system has either
no or infinitely many solutions (A is singular).&quot;);
end solve;</code></pre>
<hr />
<h1 id="image86-modelica.math.matrices.solve2"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image86" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.solve2</h1>
<p><strong>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<h3 id="syntax-3">Syntax</h3>
<blockquote>
<pre><code>Matrices.solve2(A,b);</code></pre>
</blockquote>
<h3 id="description-3">Description</h3>
<p>This function call returns the solution <strong>X</strong> of the linear system of equations</p>
<blockquote>
<p><strong>A</strong>*<strong>X</strong> = <strong>B</strong></p>
</blockquote>
<p>If a unique solution <strong>X</strong> does not exist (since <strong>A</strong> is singular), an assertion is triggered. If this is not desired, use instead <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares2">Matrices.leastSquares2</a> and inquire the singularity of the solution with the return argument rank (a unique solution is computed if rank = size(A,1)).</p>
<p>Note, the solution is computed with the LAPACK function &quot;dgesv&quot;, i.e., by Gaussian elemination with partial pivoting.</p>
<h3 id="example-3">Example</h3>
<blockquote>
<pre><code>Real A[3,3] = [1,2,3;
               3,4,5;
               2,1,4];
Real B[3,2] = [10, 20;
               22, 44;
               12, 24];
Real X[3,2];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>(LU, pivots) := Matrices.LU(A); X := Matrices.solve2(A, B1); /* X = [3, 6; 2, 4; 1, 2] */</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-4">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">Matrices.LU</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2">Matrices.LU_solve2</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares2">Matrices.leastSquares2</a>.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-3">Inputs</h2>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Matrix A of A*X = B</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[size(A, 1), :]</td>
<td align="left">
</td>
<td align="left">Matrix B of A*X = B</td>
</tr>
</tbody>
</table>
<h2 id="outputs-3">Outputs</h2>
<table>
<col width="12%" />
<col width="41%" />
<col width="44%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(B, 1), size(B, 2)]</td>
<td align="left">Matrix X such that A*X = B</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>function solve2 
  &quot;Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)&quot;

  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)] &quot;Matrix A of A*X = B&quot;;
  input Real B[size(A, 1),:] &quot;Matrix B of A*X = B&quot;;
  output Real X[size(B, 1), size(B,2)] &quot;Matrix X such that A*X = B&quot;;

protected 
  Integer info;
algorithm 
  (X,info) := LAPACK.dgesv(A, B);
  assert(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.solve2\&quot; is not possible, because the system has either
no or infinitely many solutions (A is singular).&quot;);
end solve2;</code></pre>
<hr />
<h1 id="image87-modelica.math.matrices.leastsquares"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image87" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.leastSquares</h1>
<p><strong>Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<h3 id="syntax-4">Syntax</h3>
<blockquote>
<pre><code>x = Matrices.leastSquares(A,b);</code></pre>
</blockquote>
<h3 id="description-4">Description</h3>
<p>Returns a solution of equation A*x = b in a least square sense (A may be rank deficient):</p>
<pre><code>minimize | A*x - b |</code></pre>
<p>Several different cases can be distinguished (note, <strong>rank</strong> is an output argument of this function):</p>
<p><strong>size(A,1) = size(A,2)</strong></p>
<p>A solution is returned for a regular, as well as a singular matrix A:</p>
<ul>
<li><dl>
<dt><strong>rank</strong> = size(A,1):</dt>
<dd><p>A is <strong>regular</strong> and the returned solution x fulfills the equation</p>
</dd>
</dl>
A*x = b uniquely.</li>
<li><dl>
<dt><strong>rank</strong> &lt; size(A,1):</dt>
<dd><p>A is <strong>singular</strong> and no unique solution for equation A*x = b</p>
</dd>
</dl>
<p>exists.</p>
<ul>
<li>If an infinite number of solutions exists, the one is selected that fulfills the equation and at the same time has the minimum norm |x| for all solution vectors that fulfill the equation.</li>
<li>If no solution exists, x is selected such that |A*x - b| is as small as possible (but A*x - b is not zero).</li>
</ul></li>
</ul>
<p><strong>size(A,1) &gt; size(A,2):</strong></p>
<p>The equation A*x = b has no unique solution. The solution x is selected such that |A*x - b| is as small as possible. If rank = size(A,2), this minimum norm solution is unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the same minimum value of |A*x - b|. From these infinite number of solutions, the one with the minimum norm |x| is selected. This gives a unique solution that minimizes both |A*x - b| and |x|.</p>
<p><strong>size(A,1) &lt; size(A,2):</strong></p>
<ul>
<li><dl>
<dt><strong>rank</strong> = size(A,1):</dt>
<dd><p>There are an infinite number of solutions that fulfill the equation</p>
</dd>
</dl>
A*x = b. From this infinite number, the unique solution is selected that minimizes |x|.</li>
<li><dl>
<dt><strong>rank</strong> &lt; size(A,1):</dt>
<dd><p>There is either no solution of equation A*x = b, or there are again</p>
</dd>
</dl>
an infinite number of solutions. The unique solution x is returned that minimizes both |A*x - b| and |x|.</li>
</ul>
<p>Note, the solution is computed with the LAPACK function &quot;dgelsx&quot;, i.e., QR or LQ factorization of A with column pivoting.</p>
<h3 id="algorithmic-details">Algorithmic details</h3>
<p>The function first computes a QR factorization with column pivoting:</p>
<pre><code>A * P = Q * [ R11 R12 ]
            [  0  R22 ]</code></pre>
<p>with R11 defined as the largest leading submatrix whose estimated condition number is less than 1/rcond. The order of R11, <strong>rank</strong>, is the effective rank of A.</p>
<p>Then, R22 is considered to be negligible, and R12 is annihilated by orthogonal transformations from the right, arriving at the complete orthogonal factorization:</p>
<pre><code>A * P = Q * [ T11 0 ] * Z
            [  0  0 ]</code></pre>
<p>The minimum-norm solution is then</p>
<pre><code>x = P * Z&#39; [ inv(T11)*Q1&#39;*b ]
           [        0       ]</code></pre>
<p>where Q1 consists of the first &quot;rank&quot; columns of Q.</p>
<h3 id="see-also-5">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares2">Matrices.leastSquares2</a> (same as leastSquares, but with a right hand side matrix),</p>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a> (for square, regular matrices A)</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-4">Inputs</h2>
<table>
<col width="7%" />
<col width="15%" />
<col width="27%" />
<col width="49%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Matrix A</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">b[size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Vector b</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">rcond</td>
<td align="left">100*Modelica.Constants.eps</td>
<td align="left">Reciprocal condition number to estimate the rank of A</td>
</tr>
</tbody>
</table>
<h2 id="outputs-4">Outputs</h2>
<table>
<col width="8%" />
<col width="12%" />
<col width="79%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x[size(A, 2)]</td>
<td align="left">Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">rank</td>
<td align="left">Rank of A</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>function leastSquares 
  &quot;Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)&quot;
  extends Modelica.Icons.Function;
  input Real A[:, :] &quot;Matrix A&quot;;
  input Real b[size(A, 1)] &quot;Vector b&quot;;
  input Real rcond=100*Modelica.Constants.eps 
    &quot;Reciprocal condition number to estimate the rank of A&quot;;
  output Real x[size(A, 2)] 
    &quot;Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)&quot;;
  output Integer rank &quot;Rank of A&quot;;
protected 
  Integer info;
  Real xx[max(size(A,1),size(A,2))];
algorithm 
  if min(size(A)) &gt; 0 then
    (xx,info,rank) := LAPACK.dgelsx_vec(A, b, rcond);
     x := xx[1:size(A,2)];
     assert(info == 0, &quot;Solving an overdetermined or underdetermined linear system\n&quot; +
                       &quot;of equations with function \&quot;Matrices.leastSquares\&quot; failed.&quot;);
  else
     x := fill(0.0, size(A, 2));
  end if;
end leastSquares;</code></pre>
<hr />
<h1 id="image88-modelica.math.matrices.leastsquares2"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image88" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.leastSquares2</h1>
<p><strong>Solve linear equation A*X = B (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<h3 id="syntax-5">Syntax</h3>
<blockquote>
<pre><code>X = Matrices.leastSquares2(A,B);</code></pre>
</blockquote>
<h3 id="description-5">Description</h3>
<p>Returns a solution of equation A*X = B in a least square sense (A may be rank deficient):</p>
<pre><code>minimize | A*X - B |</code></pre>
<p>Several different cases can be distinguished (note, <strong>rank</strong> is an output argument of this function):</p>
<p><strong>size(A,1) = size(A,2)</strong></p>
<p>A solution is returned for a regular, as well as a singular matrix A:</p>
<ul>
<li><dl>
<dt><strong>rank</strong> = size(A,1):</dt>
<dd><p>A is <strong>regular</strong> and the returned solution X fulfills the equation</p>
</dd>
</dl>
A*X = B uniquely.</li>
<li><dl>
<dt><strong>rank</strong> &lt; size(A,1):</dt>
<dd><p>A is <strong>singular</strong> and no unique solution for equation A*X = B</p>
</dd>
</dl>
<p>exists.</p>
<ul>
<li>If an infinite number of solutions exists, the one is selected that fulfills the equation and at the same time has the minimum norm |x| for all solution vectors that fulfill the equation.</li>
<li>If no solution exists, X is selected such that |A*X - B| is as small as possible (but A*X - B is not zero).</li>
</ul></li>
</ul>
<p><strong>size(A,1) &gt; size(A,2):</strong></p>
<p>The equation A*X = B has no unique solution. The solution X is selected such that |A*X - B| is as small as possible. If rank = size(A,2), this minimum norm solution is unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the same minimum value of |A*X - B|. From these infinite number of solutions, the one with the minimum norm |X| is selected. This gives a unique solution that minimizes both |A*X - B| and |X|.</p>
<p><strong>size(A,1) &lt; size(A,2):</strong></p>
<ul>
<li><dl>
<dt><strong>rank</strong> = size(A,1):</dt>
<dd><p>There are an infinite number of solutions that fulfill the equation</p>
</dd>
</dl>
A*X = B. From this infinite number, the unique solution is selected that minimizes |X|.</li>
<li><dl>
<dt><strong>rank</strong> &lt; size(A,1):</dt>
<dd><p>There is either no solution of equation A*X = B, or there are again</p>
</dd>
</dl>
an infinite number of solutions. The unique solution X is returned that minimizes both |A*X - B| and |X|.</li>
</ul>
<p>Note, the solution is computed with the LAPACK function &quot;dgelsx&quot;, i.e., QR or LQ factorization of A with column pivoting.</p>
<h3 id="algorithmic-details-1">Algorithmic details</h3>
<p>The function first computes a QR factorization with column pivoting:</p>
<pre><code>A * P = Q * [ R11 R12 ]
            [  0  R22 ]</code></pre>
<p>with R11 defined as the largest leading submatrix whose estimated condition number is less than 1/rcond. The order of R11, <strong>rank</strong>, is the effective rank of A.</p>
<p>Then, R22 is considered to be negligible, and R12 is annihilated by orthogonal transformations from the right, arriving at the complete orthogonal factorization:</p>
<pre><code>A * P = Q * [ T11 0 ] * Z
            [  0  0 ]</code></pre>
<p>The minimum-norm solution is then</p>
<pre><code>X = P * Z&#39; [ inv(T11)*Q1&#39;*B ]
           [        0       ]</code></pre>
<p>where Q1 consists of the first &quot;rank&quot; columns of Q.</p>
<h3 id="see-also-6">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares">Matrices.leastSquares</a> (same as leastSquares2, but with a right hand side vector),</p>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2">Matrices.solve2</a> (for square, regular matrices A)</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-5">Inputs</h2>
<table>
<col width="7%" />
<col width="18%" />
<col width="27%" />
<col width="46%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Matrix A</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[size(A, 1), :]</td>
<td align="left">
</td>
<td align="left">Matrix B</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">rcond</td>
<td align="left">100*Modelica.Constants.eps</td>
<td align="left">Reciprocal condition number to estimate rank of A</td>
</tr>
</tbody>
</table>
<h2 id="outputs-5">Outputs</h2>
<table>
<col width="7%" />
<col width="18%" />
<col width="73%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(A, 2), size(B, 2)]</td>
<td align="left">Matrix X such that min|A*X-B|^2 if size(A,1) &gt;= size(A,2) or min|X|^2 and A*X=B, if size(A,1) &lt; size(A,2)</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">rank</td>
<td align="left">Rank of A</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>function leastSquares2 
  &quot;Solve linear equation A*X = B (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)&quot;
  extends Modelica.Icons.Function;
  input Real A[:, :] &quot;Matrix A&quot;;
  input Real B[size(A, 1),:] &quot;Matrix B&quot;;
  input Real rcond=100*Modelica.Constants.eps 
    &quot;Reciprocal condition number to estimate rank of A&quot;;
  output Real X[size(A, 2), size(B,2)] 
    &quot;Matrix X such that min|A*X-B|^2 if size(A,1) &gt;= size(A,2) or min|X|^2 and A*X=B, if size(A,1) &lt; size(A,2)&quot;;
  output Integer rank &quot;Rank of A&quot;;
protected 
  Integer info;
  Real XX[max(size(A,1),size(A,2)), size(B,2)];
algorithm 
  (XX,info,rank) := LAPACK.dgelsx(A, B, rcond);
  X := XX[1:size(A,2), :];
  assert(info == 0, &quot;Solving an overdetermined or underdetermined linear system of
equations with function \&quot;Matrices.leastSquares2\&quot; failed.&quot;);
end leastSquares2;</code></pre>
<hr />
<h1 id="image89-modelica.math.matrices.equalityleastsquares"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image89" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.equalityLeastSquares</h1>
<p><strong>Solve a linear equality constrained least squares problem</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<h3 id="syntax-6">Syntax</h3>
<blockquote>
<pre><code>x = Matrices.equalityLeastSquares(A,a,B,b);</code></pre>
</blockquote>
<h3 id="description-6">Description</h3>
<p>This function returns the solution <strong>x</strong> of the linear equality-constrained least squares problem:</p>
<blockquote>
<p>min|<strong>A</strong>*<strong>x</strong> - <strong>a</strong>|^2 over <strong>x</strong>, subject to <strong>B</strong>*<strong>x</strong> = <strong>b</strong></p>
</blockquote>
<p>It is required that the dimensions of A and B fulfill the following relationship:</p>
<blockquote>
<p>size(B,1) ≤ size(A,2) ≤ size(A,1) + size(B,1)</p>
</blockquote>
<p>Note, the solution is computed with the LAPACK function &quot;dgglse&quot; using the generalized RQ factorization under the assumptions that B has full row rank (= size(B,1)) and the matrix [A;B] has full column rank (= size(A,2)). In this case, the problem has a unique solution.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-6">Inputs</h2>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Minimize |A*x - a|^2</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">a[size(A, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">B[:, size(A, 2)]</td>
<td align="left">
</td>
<td align="left">subject to B*x=b</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">b[size(B, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="outputs-6">Outputs</h2>
<table>
<col width="12%" />
<col width="25%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x[size(A, 2)]</td>
<td align="left">solution vector</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>function equalityLeastSquares 
  &quot;Solve a linear equality constrained least squares problem&quot;
  extends Modelica.Icons.Function;
  input Real A[:,:] &quot;Minimize |A*x - a|^2&quot;;
  input Real a[size(A,1)];
  input Real B[:,size(A,2)] &quot;subject to B*x=b&quot;;
  input Real b[size(B,1)];
  output Real x[size(A,2)] &quot;solution vector&quot;;

protected 
  Integer info;
algorithm 
  assert(size(A,2) &gt;= size(B,1) and size(A,2) &lt;= size(A,1) + size(B,1),
         &quot;It is required that size(B,1) &lt;= size(A,2) &lt;= size(A,1) + size(B,1)\n&quot; +
         &quot;This relationship is not fulfilled, since the matrices are declared as:\n&quot; +
         &quot;  A[&quot; + String(size(A,1)) + &quot;,&quot; + String(size(A,2)) + &quot;], B[&quot; +
         String(size(B,1)) + &quot;,&quot; + String(size(B,2)) + &quot;]\n&quot;);

  (x, info) := LAPACK.dgglse_vec(A, a, B, b);

  assert(info == 0, &quot;Solving a linear equality-constrained least squares problem
with function \&quot;Matrices.equalityLeastSquares\&quot; failed.&quot;);
end equalityLeastSquares;</code></pre>
<hr />
<h1 id="image90-modelica.math.matrices.lu"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image90" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.LU</h1>
<p><strong>LU decomposition of square or rectangular matrix</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<h3 id="syntax-7">Syntax</h3>
<blockquote>
<pre><code>(LU, pivots)       = Matrices.LU(A);
(LU, pivots, info) = Matrices.LU(A);</code></pre>
</blockquote>
<h3 id="description-7">Description</h3>
<p>This function call returns the LU decomposition of a &quot;Real[m,n]&quot; matrix A, i.e.,</p>
<blockquote>
<p><strong>P</strong>*<strong>L</strong>*<strong>U</strong> = <strong>A</strong></p>
</blockquote>
<p>where <strong>P</strong> is a permutation matrix (implicitely defined by vector <code>pivots</code>), <strong>L</strong> is a lower triangular matrix with unit diagonal elements (lower trapezoidal if m &gt; n), and <strong>U</strong> is an upper triangular matrix (upper trapezoidal if m &lt; n). Matrices <strong>L</strong> and <strong>U</strong> are stored in the returned matrix <code>LU</code> (the diagonal of <strong>L</strong> is not stored). With the companion function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve">Matrices.LU_solve</a>, this decomposition can be used to solve linear systems (<strong>P</strong>*<strong>L</strong>*<strong>U</strong>)*<strong>x</strong> = <strong>b</strong> with different right hand side vectors <strong>b</strong>. If a linear system of equations with just one right hand side vector <strong>b</strong> shall be solved, it is more convenient to just use the function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a>.</p>
<p>The optional third (Integer) output argument has the following meaning:</p>
<table>
<col width="15%" />
<col width="84%" />
<tbody>
<tr class="odd">
<td align="left">info = 0:</td>
<td align="left">successful exit</td>
</tr>
<tr class="even">
<td align="left">info &gt; 0:</td>
<td align="left"><dl>
<dt>if info = i, U[i,i] is exactly zero. The factorization has been completed,</dt>
<dd><p>but the factor U is exactly singular, and division by zero will occur if it is used to solve a system of equations.</p>
</dd>
</dl></td>
</tr>
</tbody>
</table>
<p>The LU factorization is computed with the LAPACK function &quot;dgetrf&quot;, i.e., by Gaussian elemination using partial pivoting with row interchanges. Vector &quot;pivots&quot; are the pivot indices, i.e., for 1 ≤ i ≤ min(m,n), row i of matrix A was interchanged with row pivots[i].</p>
<h3 id="example-4">Example</h3>
<blockquote>
<pre><code>Real A[3,3] = [1,2,3;
               3,4,5;
               2,1,4];
Real b1[3] = {10,22,12};
Real b2[3] = { 7,13,10};
Real    LU[3,3];
Integer pivots[3];
Real    x1[3];
Real    x2[3];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>(LU, pivots) := Matrices.LU(A); x1 := Matrices.LU_solve(LU, pivots, b1); // x1 = {3,2,1} x2 := Matrices.LU_solve(LU, pivots, b2); // x2 = {1,0,2}</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-7">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve">Matrices.LU_solve</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a>,</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-7">Inputs</h2>
<table>
<col width="12%" />
<col width="16%" />
<col width="16%" />
<col width="45%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Square or rectangular matrix</td>
</tr>
</tbody>
</table>
<h2 id="outputs-7">Outputs</h2>
<table>
<col width="12%" />
<col width="41%" />
<col width="45%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">LU[size(A, 1), size(A, 2)]</td>
<td align="left">L,U factors (used with LU_solve(..))</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">pivots[min(size(A, 1), size(A, 2))]</td>
<td align="left">pivot indices (used with LU_solve(..))</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">info</td>
<td align="left">Information</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>function LU &quot;LU decomposition of square or rectangular matrix&quot;
  extends Modelica.Icons.Function;
  input Real A[:, :] &quot;Square or rectangular matrix&quot;;
  output Real LU[size(A, 1), size(A,2)] = A 
    &quot;L,U factors (used with LU_solve(..))&quot;;
  output Integer pivots[min(size(A, 1), size(A,2))] 
    &quot;pivot indices (used with LU_solve(..))&quot;;
  output Integer info &quot;Information&quot;;
protected 
  Integer lda=max(1,size(A, 1));
  external &quot;FORTRAN 77&quot; dgetrf(size(A, 1), size(A, 2), LU, lda, pivots, info);

end LU;</code></pre>
<hr />
<h1 id="image91-modelica.math.matrices.lu_solve"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image91" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.LU_solve</h1>
<p><strong>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<h3 id="syntax-8">Syntax</h3>
<blockquote>
<pre><code>Matrices.LU_solve(LU, pivots, b);</code></pre>
</blockquote>
<h3 id="description-8">Description</h3>
<p>This function call returns the solution <strong>x</strong> of the linear systems of equations</p>
<blockquote>
<p><strong>P</strong>*<strong>L</strong>*<strong>U</strong>*<strong>x</strong> = <strong>b</strong>;</p>
</blockquote>
<p>where <strong>P</strong> is a permutation matrix (implicitely defined by vector <code>pivots</code>), <strong>L</strong> is a lower triangular matrix with unit diagonal elements (lower trapezoidal if m &gt; n), and <strong>U</strong> is an upper triangular matrix (upper trapezoidal if m &lt; n). The matrices of this decomposition are computed with function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">Matrices.LU</a> that returns arguments <code>LU</code> and <code>pivots</code> used as input arguments of <code>Matrices.LU_solve</code>. With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code> it is possible to efficiently solve linear systems with different right hand side vectors. If a linear system of equations with just one right hand side vector shall be solved, it is more convenient to just use the function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a>.</p>
<p>If a unique solution <strong>x</strong> does not exist (since the LU decomposition is singular), an exception is raised.</p>
<p>The LU factorization is computed with the LAPACK function &quot;dgetrf&quot;, i.e., by Gaussian elemination using partial pivoting with row interchanges. Vector &quot;pivots&quot; are the pivot indices, i.e., for 1 ≤ i ≤ min(m,n), row i of matrix A was interchanged with row pivots[i].</p>
<h3 id="example-5">Example</h3>
<blockquote>
<pre><code>Real A[3,3] = [1,2,3;
               3,4,5;
               2,1,4];
Real b1[3] = {10,22,12};
Real b2[3] = { 7,13,10};
Real    LU[3,3];
Integer pivots[3];
Real    x1[3];
Real    x2[3];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>(LU, pivots) := Matrices.LU(A); x1 := Matrices.LU_solve(LU, pivots, b1); // x1 = {3,2,1} x2 := Matrices.LU_solve(LU, pivots, b2); // x2 = {1,0,2}</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-8">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">Matrices.LU</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a>,</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-8">Inputs</h2>
<table>
<col width="11%" />
<col width="23%" />
<col width="11%" />
<col width="53%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">LU[:, size(LU, 1)]</td>
<td align="left">
</td>
<td align="left">L,U factors of Matrices.LU(..) for a square matrix</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">pivots[size(LU, 1)]</td>
<td align="left">
</td>
<td align="left">Pivots indices of Matrices.LU(..)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">b[size(LU, 1)]</td>
<td align="left">
</td>
<td align="left">Right hand side vector of P*L*U*x=b</td>
</tr>
</tbody>
</table>
<h2 id="outputs-8">Outputs</h2>
<table>
<col width="12%" />
<col width="25%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x[size(b, 1)]</td>
<td align="left">Solution vector such that P*L*U*x = b</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>function LU_solve 
  &quot;Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))&quot;

  extends Modelica.Icons.Function;
  input Real LU[:, size(LU,1)] 
    &quot;L,U factors of Matrices.LU(..) for a square matrix&quot;;
  input Integer pivots[size(LU, 1)] &quot;Pivots indices of Matrices.LU(..)&quot;;
  input Real b[size(LU, 1)] &quot;Right hand side vector of P*L*U*x=b&quot;;
  output Real x[size(b, 1)] &quot;Solution vector such that P*L*U*x = b&quot;;

algorithm 
  for i in 1:size(LU,1) loop
       assert(LU[i,i] &lt;&gt; 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LU_solve\&quot; is not possible, since the LU decomposition
is singular, i.e., no unique solution exists.&quot;);
  end for;
  x := LAPACK.dgetrs_vec(LU, pivots, b);
end LU_solve;</code></pre>
<hr />
<h1 id="image92-modelica.math.matrices.lu_solve2"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image92" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.LU_solve2</h1>
<p><strong>Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<h3 id="syntax-9">Syntax</h3>
<blockquote>
<pre><code>Matrices.LU_solve(LU, pivots, B);</code></pre>
</blockquote>
<h3 id="description-9">Description</h3>
<p>This function call returns the solution <strong>X</strong> of the linear systems of equations</p>
<blockquote>
<p><strong>P</strong>*<strong>L</strong>*<strong>U</strong>*<strong>X</strong> = <strong>B</strong>;</p>
</blockquote>
<p>where <strong>P</strong> is a permutation matrix (implicitely defined by vector <code>pivots</code>), <strong>L</strong> is a lower triangular matrix with unit diagonal elements (lower trapezoidal if m &gt; n), and <strong>U</strong> is an upper triangular matrix (upper trapezoidal if m &lt; n). The matrices of this decomposition are computed with function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">Matrices.LU</a> that returns arguments <code>LU</code> and <code>pivots</code> used as input arguments of <code>Matrices.LU_solve2</code>. With <code>Matrices.LU</code> and <code>Matrices.LU_solve2</code> it is possible to efficiently solve linear systems with different right hand side <strong>matrices</strong>. If a linear system of equations with just one right hand side matrix shall be solved, it is more convenient to just use the function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2">Matrices.solve2</a>.</p>
<p>If a unique solution <strong>X</strong> does not exist (since the LU decomposition is singular), an exception is raised.</p>
<p>The LU factorization is computed with the LAPACK function &quot;dgetrf&quot;, i.e., by Gaussian elemination using partial pivoting with row interchanges. Vector &quot;pivots&quot; are the pivot indices, i.e., for 1 ≤ i ≤ min(m,n), row i of matrix A was interchanged with row pivots[i].</p>
<h3 id="example-6">Example</h3>
<blockquote>
<pre><code>Real A[3,3] = [1,2,3;
               3,4,5;
               2,1,4];
Real B1[3] = [10, 20;
              22, 44;
              12, 24];
Real B2[3] = [ 7, 14;
              13, 26;
              10, 20];
Real    LU[3,3];
Integer pivots[3];
Real    X1[3,2];
Real    X2[3,2];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>(LU, pivots) := Matrices.LU(A); X1 := Matrices.LU_solve2(LU, pivots, B1); /* X1 = [3, 6; 2, 4; 1, 2] <em>/ X2 := Matrices.LU_solve2(LU, pivots, B2); /</em> X2 = [1, 2; 0, 0; 2, 4] */</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-9">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU">Matrices.LU</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2">Matrices.solve2</a>,</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-9">Inputs</h2>
<table>
<col width="11%" />
<col width="23%" />
<col width="11%" />
<col width="53%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">LU[:, size(LU, 1)]</td>
<td align="left">
</td>
<td align="left">L,U factors of Matrices.LU(..) for a square matrix</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">pivots[size(LU, 1)]</td>
<td align="left">
</td>
<td align="left">Pivots indices of Matrices.LU(..)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">B[size(LU, 1), :]</td>
<td align="left">
</td>
<td align="left">Right hand side matrix of P*L*U*X=B</td>
</tr>
</tbody>
</table>
<h2 id="outputs-9">Outputs</h2>
<table>
<col width="10%" />
<col width="35%" />
<col width="53%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(B, 1), size(B, 2)]</td>
<td align="left">Solution matrix such that P*L*U*X = B</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>function LU_solve2 
  &quot;Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))&quot;

  extends Modelica.Icons.Function;
  input Real LU[:, size(LU,1)] 
    &quot;L,U factors of Matrices.LU(..) for a square matrix&quot;;
  input Integer pivots[size(LU, 1)] &quot;Pivots indices of Matrices.LU(..)&quot;;
  input Real B[size(LU, 1),:] &quot;Right hand side matrix of P*L*U*X=B&quot;;
  output Real X[size(B, 1), size(B,2)] &quot;Solution matrix such that P*L*U*X = B&quot;;

algorithm 
  for i in 1:size(LU,1) loop
       assert(LU[i,i] &lt;&gt; 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LU_solve\&quot; is not possible, since the LU decomposition
is singular, i.e., no unique solution exists.&quot;);
  end for;
  X := Modelica.Math.Matrices.LAPACK.dgetrs(
    LU,
    pivots,
    B);
end LU_solve2;</code></pre>
<hr />
<h1 id="image93-modelica.math.matrices.eigenvalues"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image93" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.eigenValues</h1>
<p><strong>Return eigenvalues and eigenvectors for a real, nonsymmetric matrix in a Real representation</strong></p>
<h2 id="information-11">Information</h2>
<p>::</p>
<h3 id="syntax-10">Syntax</h3>
<blockquote>
<pre><code>eigenvalues = Matrices.eigenValues(A);</code></pre>
<blockquote>
<p>(eigenvalues, eigenvectors) = Matrices.eigenValues(A);</p>
</blockquote>
</blockquote>
<h3 id="description-10">Description</h3>
<p>This function call returns the eigenvalues and optionally the (right) eigenvectors of a square matrix <strong>A</strong>. The first column of &quot;eigenvalues&quot; contains the real and the second column contains the imaginary part of the eigenvalues. If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is the corresponding real eigenvector. If the i-th eigenvalue has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the imaginary part of the eigenvector of the i-th eigenvalue. With function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix">Matrices.eigenValueMatrix</a>, a real block diagonal matrix is constructed from the eigenvalues such that</p>
<blockquote>
<pre><code>A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors)</code></pre>
</blockquote>
<p>provided the eigenvector matrix &quot;eigenvectors&quot; can be inverted (an inversion is possible, if all eigenvalues are different; in some cases, an inversion is also possible if some eigenvalues are the same).</p>
<h3 id="example-7">Example</h3>
<blockquote>
<pre><code>Real A[3,3] = [1,2,3;
               3,4,5;
               2,1,4];
Real eval;</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><dl>
<dt>eval := Matrices.eigenValues(A); // eval = [-0.618, 0;</dt>
<dd><p>// 8.0 , 0; // 1.618, 0];</p>
</dd>
</dl>
</dd>
</dl>
</blockquote>
</blockquote>
<p>i.e., matrix A has the 3 real eigenvalues -0.618, 8, 1.618.</p>
<h3 id="see-also-10">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix">Matrices.eigenValueMatrix</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues">Matrices.singularValues</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-10">Inputs</h2>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Matrix</td>
</tr>
</tbody>
</table>
<h2 id="outputs-10">Outputs</h2>
<table>
<col width="7%" />
<col width="35%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">eigenvalues[size(A, 1), 2]</td>
<td align="left">Eigenvalues of matrix A (Re: first column, Im: second column)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">eigenvectors[size(A, 1), size(A, 2)]</td>
<td align="left">Real-valued eigenvector matrix</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>function eigenValues 
  &quot;Return eigenvalues and eigenvectors for a real, nonsymmetric matrix in a Real representation&quot;

  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)] &quot;Matrix&quot;;
  output Real eigenvalues[size(A, 1), 2] 
    &quot;Eigenvalues of matrix A (Re: first column, Im: second column)&quot;;
  output Real eigenvectors[size(A,1), size(A,2)] 
    &quot;Real-valued eigenvector matrix&quot;;

protected 
  Integer info;
  // replace with &quot;isPresent(..)&quot; if supported by Dymola
  Boolean onlyEigenvalues = false;
algorithm 
if size(A,1) &gt; 0 then
  if onlyEigenvalues then
     (eigenvalues[:, 1],eigenvalues[:, 2],info) := LAPACK.dgeev_eigenValues(A);
     eigenvectors :=zeros(size(A, 1), size(A, 1));
  else
     (eigenvalues[:, 1],eigenvalues[:, 2],eigenvectors, info) := LAPACK.dgeev(A);
  end if;
  assert(info == 0, &quot;Calculating the eigen values with function
\&quot;Matrices.eigenvalues\&quot; is not possible, since the
numerical algorithm does not converge.&quot;);
end if;
end eigenValues;</code></pre>
<hr />
<h1 id="image94-modelica.math.matrices.eigenvaluematrix"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image94" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.eigenValueMatrix</h1>
<p><strong>Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)</strong></p>
<h2 id="information-12">Information</h2>
<p>::</p>
<h3 id="syntax-11">Syntax</h3>
<blockquote>
<pre><code>Matrices.eigenValueMatrix(eigenvalues);</code></pre>
</blockquote>
<h3 id="description-11">Description</h3>
<p>The function call returns a block diagonal matrix <strong>J</strong> from the the two-column matrix <code>eigenvalues</code> (computed by function <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues">Matrices.eigenValues</a>). Matrix <code>eigenvalues</code> must have the real part of the eigenvalues in the first column and the imaginary part in the second column. If an eigenvalue i has a vanishing imaginary part, then <strong>J</strong>[i,i] = eigenvalues[i,1], i.e., the diagonal element of <strong>J</strong> is the real eigenvalue. Otherwise, eigenvalue i and conjugate complex eigenvalue i+1 are used to construct a 2 by 2 diagonal block of <strong>J</strong>:</p>
<blockquote>
<pre><code>J[i  , i]   := eigenvalues[i,1];
J[i  , i+1] := eigenvalues[i,2];
J[i+1, i]   := eigenvalues[i+1,2];
J[i+1, i+1] := eigenvalues[i+1,1];</code></pre>
</blockquote>
<h3 id="see-also-11">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues">Matrices.eigenValues</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-11">Inputs</h2>
<table>
<col width="7%" />
<col width="17%" />
<col width="9%" />
<col width="66%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">eigenValues[:, 2]</td>
<td align="left">
</td>
<td align="left">Eigen values from function eigenValues(..) (Re: first column, Im: second column)</td>
</tr>
</tbody>
</table>
<h2 id="outputs-11">Outputs</h2>
<table>
<col width="6%" />
<col width="34%" />
<col width="59%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">J[size(eigenValues, 1), size(eigenValues, 1)]</td>
<td align="left">Real valued block diagonal matrix with eigen values (Re: 1x1 block, Im: 2x2 block)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>function eigenValueMatrix 
  &quot;Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)&quot;

  extends Modelica.Icons.Function;
  input Real eigenValues[:, 2] 
    &quot;Eigen values from function eigenValues(..) (Re: first column, Im: second column)&quot;;
  output Real J[size(eigenValues, 1), size(eigenValues, 1)] 
    &quot;Real valued block diagonal matrix with eigen values (Re: 1x1 block, Im: 2x2 block)&quot;;

protected 
  Integer n=size(eigenValues, 1);
  Integer i;
algorithm 
  J := zeros(n, n);
  i := 1;
  while i &lt;= n loop
    if eigenValues[i, 2] == 0 then
      J[i, i] := eigenValues[i, 1];
      i := i + 1;
    else
      J[i, i] := eigenValues[i, 1];
      J[i, i + 1] := eigenValues[i, 2];
      J[i + 1, i] := eigenValues[i + 1, 2];
      J[i + 1, i + 1] := eigenValues[i + 1, 1];
      i := i + 2;
    end if;
  end while;
end eigenValueMatrix;</code></pre>
<hr />
<h1 id="image95-modelica.math.matrices.singularvalues"><img src="Modelica.Math.Matrices.isEqualI.png" alt="image95" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.singularValues</h1>
<p><strong>Return singular values and left and right singular vectors</strong></p>
<h2 id="information-13">Information</h2>
<p>::</p>
<h3 id="syntax-12">Syntax</h3>
<blockquote>
<pre><code>sigma = Matrices.singularValues(A);</code></pre>
<blockquote>
<p>(sigma, U, VT) = Matrices.singularValues(A);</p>
</blockquote>
</blockquote>
<h3 id="description-12">Description</h3>
<p>This function computes the singular values and optionally the singular vectors of matrix A. Basically the singular value decomposition of A is computed, i.e.,</p>
<blockquote>
<pre><code>A = U S VT
  = U*Sigma*VT</code></pre>
<p>where <strong>U</strong>and <strong>V</strong> are orthogonal matrices (<strong>UU</strong><sup>T</sup>=<strong>I,</strong><strong>VV</strong><sup>T</sup>=<strong>I</strong>). <strong>S</strong> = diag(s<sub>i</sub>) has the same size as matrix A with nonnegative diagonal elements in decreasing order and with all other elements zero (s<sub>1</sub> is the largest element). The function returns the singular values s<sub>i</sub> in vector <code>sigma</code> and the orthogonal matrices in matrices <code>U</code> and <code>V</code>.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2,  3,  4;
     3, 4,  5, -2;
    -1, 2, -3,  5];
(sigma, U, VT) = singularValues(A);
results in:
   sigma = {8.33, 6.94, 2.31};
i.e.
   Sigma = [8.33,    0,    0, 0;
               0, 6.94,    0, 0;
               0,    0, 2.31, 0]</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues">Matrices.eigenValues</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="16%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Matrix</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="10%" />
<col width="44%" />
<col width="44%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">sigma[min(size(A, 1), size(A, 2))]</td>
<td align="left">Singular values</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">U[size(A, 1), size(A, 1)]</td>
<td align="left">Left orthogonal matrix</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">VT[size(A, 2), size(A, 2)]</td>
<td align="left">Transposed right orthogonal matrix</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function singularValues 
  &quot;Return singular values and left and right singular vectors&quot;
  extends Modelica.Icons.Function;
  input Real A[:, :] &quot;Matrix&quot;;
  output Real sigma[min(size(A, 1), size(A, 2))] &quot;Singular values&quot;;
  output Real U[size(A, 1), size(A, 1)]=identity(size(A, 1)) 
    &quot;Left orthogonal matrix&quot;;
  output Real VT[size(A, 2), size(A, 2)]=identity(size(A, 2)) 
    &quot;Transposed right orthogonal matrix &quot;;

protected 
  Integer info;
  Integer n=min(size(A, 1), size(A, 2)) &quot;Number of singular values&quot;;
algorithm 
if n&gt;0 then
  (sigma,U,VT,info) := Modelica.Math.Matrices.LAPACK.dgesvd(A);
  assert(info == 0, &quot;The numerical algorithm to compute the
singular value decomposition did not converge&quot;);
end if;
end singularValues;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.isEqualI.png" alt="image96" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.QR</h2>
<p><strong>Return the QR decomposition of a square matrix with optional column pivoting (A(:,p) = Q*R)</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>(Q,R,p) = Matrices.QR(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function returns the QR decomposition of a rectangular matrix <strong>A</strong> (the number of columns of <strong>A</strong> must be less than or equal to the number of rows):</p>
<blockquote>
<p><strong>Q</strong>*<strong>R</strong> = <strong>A</strong>[:,<strong>p</strong>]</p>
</blockquote>
<p>where <strong>Q</strong> is a rectangular matrix that has orthonormal columns and has the same size as A (<strong>Q</strong><sup>T</sup><strong>Q</strong>=<strong>I</strong>), <strong>R</strong> is a square, upper triangular matrix and <strong>p</strong> is a permutation vector. Matrix <strong>R</strong> has the following important properties:</p>
<ul>
<li>The absolute value of a diagonal element of <strong>R</strong> is the largest value in this row, i.e., abs(R[i,i]) ≥ abs(R[i,j]).</li>
<li>The diagonal elements of <strong>R</strong> are sorted according to size, such that the largest absolute value is abs(R[1,1]) and abs(R[i,i]) ≥ abs(R[j,j]) with i &lt; j.</li>
</ul>
<p>This means that if abs(R[i,i]) ≤ ε then abs(R[j,k]) ≤ ε for j ≥ i, i.e., the i-th row up to the last row of <strong>R</strong> have small elements and can be treated as being zero. This allows to, e.g., estimate the row-rank of <strong>R</strong> (which is the same row-rank as <strong>A</strong>). Furthermore, <strong>R</strong> can be partitioned in two parts</p>
<blockquote>
<pre><code>A[:,p] = Q * [R1, R2;
              0,  0]</code></pre>
</blockquote>
<p>where <strong>R</strong><sub>1</sub> is a regular, upper triangular matrix.</p>
<p>Note, the solution is computed with the LAPACK functions &quot;dgeqpf&quot; and &quot;dorgqr&quot;, i.e., by Housholder transformations with column pivoting. If <strong>Q</strong> is not needed, the function may be called as: <code>(,R,p) = QR(A)</code>.</p>
<h4>Example</h4>
<blockquote>
<pre><code>Real A[3,3] = [1,2,3;
               3,4,5;
               2,1,4];
Real R[3,3];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><dl>
<dt>(,R) := Matrices.QR(A); // R = [-7.07.., -4.24.., -3.67..;</dt>
<dd><p>0 , -1.73.., -0.23..; 0 , 0 , 0.65..];</p>
</dd>
</dl>
</dd>
</dl>
</blockquote>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="13%" />
<col width="12%" />
<col width="61%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Rectangular matrix with size(A,1) &gt;= size(A,2)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">pivoting</td>
<td align="left">true</td>
<td align="left">True if column pivoting is performed. True is default</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="10%" />
<col width="26%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">Q[size(A, 1), size(A, 2)]</td>
<td align="left">Rectangular matrix with orthonormal columns such that Q*R=A[:,p]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">R[size(A, 2), size(A, 2)]</td>
<td align="left">Square upper triangular matrix</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">p[size(A, 2)]</td>
<td align="left">Column permutation vector</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function QR 
  &quot;Return the QR decomposition of a square matrix with optional column pivoting (A(:,p) = Q*R)&quot;

  extends Modelica.Icons.Function;
  input Real A[:, :] &quot;Rectangular matrix with size(A,1) &gt;= size(A,2)&quot;;
  input Boolean pivoting=true 
    &quot;True if column pivoting is performed. True is default&quot;;
  output Real Q[size(A, 1), size(A, 2)] 
    &quot;Rectangular matrix with orthonormal columns such that Q*R=A[:,p]&quot;;
  output Real R[size(A, 2), size(A, 2)] &quot;Square upper triangular matrix&quot;;
  output Integer p[size(A, 2)] &quot;Column permutation vector&quot;;

protected 
  Integer nrow=size(A, 1);
  Integer ncol=size(A, 2);
  Real tau[ncol];
algorithm 
  assert(nrow &gt;= ncol, &quot;\nInput matrix A[&quot; + String(nrow) + &quot;,&quot; + String(ncol) + &quot;] has more columns as rows.
This is not allowed when calling Modelica.Matrices.QR(A).&quot;);
  if pivoting then
    (Q,tau,p) := LAPACK.dgeqpf(A);
  else
    (Q,tau) := Modelica.Math.Matrices.LAPACK.dgeqrf(A);
     p := 1:ncol;
  end if;

  // determine R
  R := zeros(ncol,ncol);
  for i in 1:ncol loop
    for j in i:ncol loop
      R[i, j] := Q[i,j];
    end for;
  end for;

  // if isPresent(Q) then (not yet supported by Dymola)
  Q := LAPACK.dorgqr(Q, tau);
end QR;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.hessenberg</h2>
<p><strong>Return upper Hessenberg form of a matrix</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>H = Matrices.hessenberg(A);</code></pre>
<blockquote>
<p>(H, U) = Matrices.hessenberg(A);</p>
</blockquote>
</blockquote>
<h4>Description</h4>
<p>Function <strong>hessenberg</strong> computes the Hessenberg matrix <strong>H</strong> of matrix <strong>A</strong> as well as the orthogonal transformation matrix <strong>U</strong> that holds <strong>H</strong> = <strong>U</strong>'*<strong>A</strong>*<strong>U</strong>. The Hessenberg form of a matrix is computed by repeated Householder similarity transformation. The elementary reflectors and the corresponding scalar factors are provided by function &quot;Utilities.toUpperHessenberg()&quot;. The transformation matrix <strong>U</strong> is then computed by <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dorghr">LAPACK.dorghr</a>.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A  = [1, 2,  3;
      6, 5,  4;
      1, 0,  0];

(H, U) = hessenberg(A);

 results in:

H = [1.0,  -2.466,  2.630;
    -6.083, 5.514, -3.081;
     0.0,   0.919, -0.514]

U = [1.0,    0.0,      0.0;
     0.0,   -0.9864,  -0.1644;
     0.0,   -0.1644,   0.9864]

 and therefore,

U*H*transpose(U) = [1.0, 2.0, 3.0;
                    6.0, 5.0, 4.0;
                    1.0, 0.0, 0.0]</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.toUpperHessenberg">Matrices.Utilities.toUpperHessenberg</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix A</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="41%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">H[size(A, 1), size(A, 2)]</td>
<td align="left">Hessenberg form of A</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">U[size(A, 1), size(A, 2)]</td>
<td align="left">Transformation matrix</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function hessenberg &quot;Return upper Hessenberg form of a matrix&quot;
  import Modelica;
  import Modelica.Math.Matrices;

  input Real A[:,size(A, 1)] &quot;Square matrix A&quot;;

  output Real H[size(A, 1),size(A, 2)] &quot;Hessenberg form of A&quot;;
  output Real U[size(A, 1),size(A, 2)] &quot;Transformation matrix&quot;;

protected 
  Real V[size(A, 1),size(A, 2)] 
    &quot;V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors&quot;;
  Real tau[max(0,size(A, 1) - 1)] &quot;Scalar factors of the elementary reflectors&quot;;

algorithm 
  (H, V, tau) := Matrices.Utilities.toUpperHessenberg(A, 1, size(A, 1));
   U := Matrices.LAPACK.dorghr(V,1,size(A, 1),tau);
end hessenberg;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.realSchur</h2>
<p><strong>Return the real Schur form (rsf) S of a square matrix A, A=QZ*S*QZ'</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>S = Matrices.realSchur(A);</code></pre>
<blockquote>
<p>(S, QZ, alphaReal, alphaImag) = Matrices.realSchur(A);</p>
</blockquote>
</blockquote>
<h4>Description</h4>
<p>Function <strong>realSchur</strong> calculates the real Schur form of a real square matrix <strong>A</strong>, i.e.</p>
<blockquote>
<pre><code>A = QZ*S*transpose(QZ)</code></pre>
</blockquote>
<p>with the real nxn matrices <strong>S</strong> and <strong>QZ</strong>. <strong>S</strong> is a block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal. <strong>QZ</strong> is an orthogonal matrix. The 1x1 blocks contains the real eigenvalues of <strong>A</strong>. The 2x2 blocks [s11, s12; s21, s11] represents the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues are the elements of the diagonal (s11). The imaginary parts are the positive and negative square roots of the product of the two elements s12 and s21 (imag = +-sqrt(s12*s21)).</p>
<p>The calculation in lapack.dgees is performed stepwise, i.e., using the internal methods of balancing and scaling of dgees.</p>
<h4>Example</h4>
<blockquote>
<pre><code>Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
Real T[3,3];
Real Z[3,3];
Real alphaReal[3];
Real alphaImag[3];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>(T, Z, alphaReal, alphaImag):=Modelica.Math.Matrices.realSchur(A);</p>
</dd>
</dl>
<p>// T = [16.12, 4.9, 1.59E-015; // 0, -1.12, -1.12E-015; // 0, 0, -1.30E-015] // Z = [-0.23, -0.88, 0.41; // -0.52, -0.24, -0.82; // -0.82, 0.4, 0.41] //alphaReal = {16.12, -1.12, -1.32E-015} //alphaImag = {0, 0, 0}</p>
</blockquote>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.reorderRSF">Math.Matrices.Utilities.reorderRSF</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="9%" />
<col width="31%" />
<col width="58%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">S[size(A, 1), size(A, 2)]</td>
<td align="left">Real Schur form of A</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">QZ[size(A, 1), size(A, 2)]</td>
<td align="left">Schur vector Matrix</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">alphaReal[size(A, 1)]</td>
<td align="left">Real part of eigenvalue=alphaReal+i*alphaImag</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">alphaImag[size(A, 1)]</td>
<td align="left">Imaginary part of eigenvalue=(alphaReal+i*alphaImag</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function realSchur 
  &quot;Return the real Schur form (rsf) S of a square matrix A, A=QZ*S*QZ&#39;&quot;
  import Modelica.Math.Matrices;

  input Real A[:,size(A, 1)] &quot;Square matrix&quot;;

public 
  output Real S[size(A, 1),size(A, 2)] &quot;Real Schur form of A&quot;;
  output Real QZ[size(A, 1),size(A, 2)] &quot;Schur vector Matrix&quot;;
  output Real alphaReal[size(A, 1)] 
    &quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;;
  output Real alphaImag[size(A, 1)] 
    &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;;

protected 
  Integer info;

algorithm 
  if size(A, 1) &gt; 1 then
    (S,QZ,alphaReal,alphaImag) := Matrices.LAPACK.dgees(A);
    assert(info == 0, &quot;The output info of LAPACK.dgees should be zero, else if\n
     info &lt; 0:  if info = -i, the i-th argument of dgees had an illegal value\n
     info &gt; 0:  if INFO = i, and i is
               &lt;= N: the QR algorithm failed to compute all the
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
                     contain those eigenvalues which have converged; if
                     JOBVS = &#39;V&#39;, VS contains the matrix which reduces A
                     to its partially converged Schur form.\n&quot;);
  else
    S := A;
    if size(A, 1) &gt; 0 then
      QZ := [1];
      alphaReal := {1};
      alphaImag := {0};
    else
      QZ := fill(1, 0, 0);
      alphaReal := fill(1, 0);
      alphaImag := fill(0, 0);
    end if;
  end if;

end realSchur;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.cholesky</h2>
<p><strong>Return the Cholesky factorization of a symmetric positive definite matrix</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>H = Matrices.cholesky(A);
H = Matrices.cholesky(A, upper=true);</code></pre>
</blockquote>
<h4>Description</h4>
<p>Function <strong>cholesky</strong> computes the Cholesky factorization of a real symmetric positive definite matrix A. The optional Boolean input &quot;upper&quot; specifies wether the upper or the lower triangular matrix is returned, i.e.</p>
<blockquote>
<pre><code>A = H&#39;*H   if upper is true (H is upper triangular)
A = H*H&#39;   if upper is false (H is lower triangular)</code></pre>
</blockquote>
<p>The computation is performed by <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dpotrf">LAPACK.dpotrf</a>.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A  = [1, 0,  0;
      6, 5,  0;
      1, -2,  2];
S = A*transpose(A);

H = Matrices.cholesky(S);

results in:

H = [1.0,  6.0,  1.0;
     0.0,  5.0, -2.0;
     0.0,  0.0,  2.0]

with

transpose(H)*H = [1.0,  6.0,   1;
                  6.0, 61.0,  -4.0;
                  1.0, -4.0,   9.0] //=S</code></pre>
</blockquote>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="10%" />
<col width="17%" />
<col width="10%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Symmetric positive definite matrix</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">upper</td>
<td align="left">true</td>
<td align="left">True if the right cholesky factor (upper triangle) should be returned</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="7%" />
<col width="25%" />
<col width="67%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">H[size(A, 1), size(A, 2)]</td>
<td align="left">Cholesky factor U (upper=true) or L (upper=false) for A = U'*U or A = L*L'</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function cholesky 
  &quot;Return the Cholesky factorization of a symmetric positive definite matrix&quot;
  import Modelica.Math.Matrices.LAPACK;
  input Real A[:,size(A, 1)] &quot;Symmetric positive definite matrix&quot;;
  input Boolean upper=true 
    &quot;True if the right cholesky factor (upper triangle) should be returned&quot;;

  output Real H[size(A, 1),size(A, 2)] 
    &quot;Cholesky factor U (upper=true) or L (upper=false) for A = U&#39;*U or A = L*L&#39;&quot;;

protected 
  Integer n=size(A,1);
  Integer info;

algorithm 
  if size(A, 1) &gt; 0 then
    (H, info) := LAPACK.dpotrf(A, upper);
  else
    H := fill(0,0,0);
    info := 0;
  end if;
  if info&lt;0 then
   assert(info==0,&quot;Cholesky factorization failed in function \&quot;Matrices.cholesky\&quot; due to illegal value of input &quot; +String(info)+&quot; for LAPACK routine DPOTRF&quot;);
  else
    assert(info==0,&quot;Cholesky factorization failed in function \&quot;Matrices.cholesky\&quot; since matrix A is not positive definite&quot;);
  end if;

  if upper then
    for i in 2:n loop
      for j in 1:i - 1 loop
        H[i, j] := 0.0;
      end for;
    end for;
  else
    for i in 1:n - 1 loop
      for j in i + 1:n loop
        H[i, j] := 0.0;
      end for;
    end for;
  end if;
end cholesky;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image97" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.balance</h2>
<p><strong>Return a balanced form of matrix A to improve the condition of A</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>(D,B) = Matrices.balance(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function returns a vector D, such that B=inv(diagonal(D))*A*diagonal(D) has a better condition as matrix A, i.e., conditionNumber(B) ≤ conditionNumber(A). The elements of D are multiples of 2 which means that this function does not introduce round-off errors. Balancing attempts to make the norm of each row of B equal to the norm of the respective column.</p>
<p>Balancing is used to minimize roundoff errors induced through large matrix calculations like Taylor-series approximation or computation of eigenvalues.</p>
<h4>Example</h4>
<blockquote>
<pre><code>- A = [1, 10,  1000; 0.01,  0,  10; 0.005,  0.01,  10]
- Matrices.norm(A, 1);
  = 1020.0
- (T,B)=Matrices.balance(A)
- T
  = {256, 16, 0.5}
- B
  =  [1,     0.625,   1.953125;
      0.16,  0,       0.3125;
      2.56,  0.32,   10.0]
- Matrices.norm(B, 1);
  = 12.265625</code></pre>
</blockquote>
<p>The Algorithm is taken from</p>
<ol start="8" style="list-style-type: upper-alpha">
<li><ol start="4" style="list-style-type: upper-alpha">
<li>Joos, G. Grbel:</li>
</ol></li>
</ol>
<dl>
<dt><strong>RASP'91 Regulator Analysis and Synthesis Programs</strong></dt>
<dd><p>DLR - Control Systems Group 1991</p>
</dd>
</dl>
<p>which based on the balanc function from EISPACK.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="6%" />
<col width="21%" />
<col width="71%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">D[size(A, 1)]</td>
<td align="left">diagonal(D)=T is transformation matrix, such that B = inv(T)*A*T has smaller condition as A</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[size(A, 1), size(A, 1)]</td>
<td align="left">Balanced matrix (= inv(diagonal(D))*A*diagonal(D) )</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function balance 
  &quot;Return a balanced form of matrix A to improve the condition of A&quot;
  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)];
  output Real D[size(A, 1)] &quot;diagonal(D)=T is transformation matrix, such that
          B = inv(T)*A*T has smaller condition as A&quot;;
  output Real B[size(A, 1), size(A, 1)] 
    &quot;Balanced matrix (= inv(diagonal(D))*A*diagonal(D) )&quot;;
protected 
  Integer na=size(A, 1);
  Integer radix=2 &quot;Radix of exponent representation must be &#39;radix&#39;
          or a multiple of &#39;radix&#39;&quot;;
  Integer radix2=radix*radix;
  Boolean noconv=true;
  Integer i=1;
  Integer j=1;
  Real CO;
  Real RO;
  Real G;
  Real F;
  Real S;
  /*auxiliary variables*/

algorithm 
  // B = inv(D)*A*D, so that cond(B)&lt;=cond(A)
  D := ones(na);
  B := A;
  while noconv loop
    noconv := false;
    for i in 1:na loop
      CO := sum(abs(B[:, i])) - abs(B[i, i]);
      RO := sum(abs(B[i, :])) - abs(B[i, i]);
      G := RO/radix;
      F := 1;
      S := CO + RO;
      while not (CO &gt;= G or CO == 0) loop
        F := F*radix;
        CO := CO*radix2;
      end while;
      G := RO*radix;
      while not (CO &lt; G or RO == 0) loop
        F := F/radix;
        CO := CO/radix2;
      end while;
      if not ((CO + RO)/F &gt;= 0.95*S) then
        G := 1/F;
        D[i] := D[i]*F;
        B[i, :] := B[i, :]*G;
        B[:, i] := B[:, i]*F;
        noconv := true;
      end if;
    end for;
  end while;
end balance;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image98" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.trace</h2>
<p><strong>Return the trace of matrix A, i.e., the sum of the diagonal elements</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>r = Matrices.trace(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function computes the trace, i.e., the sum of the elements in the diagonal of matrix <strong>A</strong>.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 3;
     2, 1];
r = trace(A);

results in:

r = 2.0</code></pre>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix A</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="15%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result</td>
<td align="left">Trace of A</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function trace 
  &quot;Return the trace of matrix A, i.e., the sum of the diagonal elements&quot;
  extends Modelica.Icons.Function;

  input Real A[:,size(A, 1)] &quot;Square matrix A&quot;;
  output Real result &quot;Trace of A&quot;;
algorithm 
  result := sum(A[i, i] for i in 1:size(A, 1));
end trace;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image99" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.det</h2>
<p><strong>Return determinant of a matrix (computed by LU decomposition; try to avoid det(..))</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>result = Matrices.det(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function returns the determinant &quot;result&quot; of matrix A computed by a LU decomposition with row pivoting. For details about determinants, see <a href="http://en.wikipedia.org/wiki/Determinant"><a href="http://en.wikipedia.org/wiki/Determinant">http://en.wikipedia.org/wiki/Determinant</a></a>. Usually, this function should never be used, because there are nearly always better numerical algorithms as by computing the determinant. Examples:</p>
<ul>
<li>Use <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank">Matrices.rank</a> to compute whether det(A) = 0 (i.e., Matrices.rank(A) &lt; size(A,1)).</li>
<li>Use <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a> to solve the linear equation A*x = b, instead of using determinantes to compute the solution.</li>
</ul>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank">Matrices.rank</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="15%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result</td>
<td align="left">Determinant of matrix A</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function det 
  &quot;Return determinant of a matrix (computed by LU decomposition; try to avoid det(..))&quot;

  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)];
  output Real result &quot;Determinant of matrix A&quot;;
protected 
  Real LU[size(A,1),size(A,1)];
  Integer pivots[size(A,1)];

algorithm 
  (LU,pivots) := Matrices.LU(A);
  result:=product(LU[i,i] for i in 1:size(A,1))*
    product(if pivots[i]==i then 1 else -1 for i in 1:size(pivots,1));
end det;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image100" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.inv</h2>
<p><strong>Return inverse of a matrix (try to avoid inv(..))</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>invA = Matrices.inv(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function returns the inverse of matrix A, i.e., A*inv(A) = identity(size(A,1)) computed by a LU decomposition with row pivoting. Usually, this function should not be used, because there are nearly always better numerical algorithms as by computing directly the inverse. Example:</p>
<blockquote>
<p>Use x = <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a>(A,b) to solve the linear equation A*x = b, instead of computing the solution by x = inv(A)*b, because this is much more efficient and much more reliable.</p>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve">Matrices.solve</a> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2">Matrices.solve2</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="45%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">invA[size(A, 1), size(A, 2)]</td>
<td align="left">Inverse of matrix A</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function inv &quot;Return inverse of a matrix (try to avoid inv(..))&quot;
  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)];
  output Real invA[size(A, 1), size(A, 2)] &quot;Inverse of matrix A&quot;;
protected 
  Integer info;
  Integer pivots[size(A, 1)] &quot;Pivot vector&quot;;
  Real LU[size(A, 1), size(A, 2)] &quot;LU factors of A&quot;;
algorithm 
  (LU,pivots,info) := LAPACK.dgetrf(A);

  assert(info == 0, &quot;Calculating an inverse matrix with function
\&quot;Matrices.inv\&quot; is not possible, since matrix A is singular.&quot;);

  invA := LAPACK.dgetri(LU, pivots);

end inv;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image101" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.rank</h2>
<p><strong>Return rank of a rectangular matrix (computed with singular values)</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>result = Matrices.rank(A);
result = Matrices.rank(A,eps=0);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function returns the rank of a square or rectangular matrix A computed by singular value decomposition. For details about the rank of a matrix, see <a href="http://en.wikipedia.org/wiki/Matrix_rank">http://en.wikipedia.org/wiki/Matrix_rank</a>. To be more precise:</p>
<ul>
<li>rank(A) returns the number of singular values of A that are larger than max(size(A))*norm(A)*Modelica.Constants.eps.</li>
<li>rank(A, eps) returns the number of singular values of A that are larger than &quot;eps&quot;.</li>
</ul>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rcond">Matrices.rcond</a>.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="5%" />
<col width="7%" />
<col width="7%" />
<col width="79%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Matrix</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">0</td>
<td align="left">If eps &gt; 0, the singular values are checked against eps; otherwise eps=max(size(A))*norm(A)*Modelica.Constants.eps is used</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="16%" />
<col width="15%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">result</td>
<td align="left">Rank of matrix A</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function rank 
  &quot;Return rank of a rectangular matrix (computed with singular values)&quot;
  extends Modelica.Icons.Function;
  input Real A[:, :] &quot;Matrix&quot;;
  input Real eps=0 
    &quot;If eps &gt; 0, the singular values are checked against eps; otherwise eps=max(size(A))*norm(A)*Modelica.Constants.eps is used&quot;;
  output Integer result &quot;Rank of matrix A&quot;;

protected 
  Integer n=min(size(A, 1), size(A, 2));
  Integer i=n;
  Real sigma[n];
  Real eps2;
algorithm 
  result := 0;
  if n &gt; 0 then
    sigma := Modelica.Math.Matrices.singularValues(A);
    eps2 := if eps &gt; 0 then eps else max(size(A))*sigma[1]*Modelica.Constants.eps;
    while i &gt; 0 loop
      if sigma[i] &gt; eps2 then
        result := i;
        i := 0;
      end if;
      i := i - 1;
    end while;
  end if;
end rank;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image102" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.conditionNumber</h2>
<p><strong>Return the condition number norm(A)*norm(inv(A)) of a matrix A</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>r = Matrices.conditionNumber(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function calculates the condition number (norm(A) * norm(inv(A))) of a general real matrix <strong>A</strong>, in either the 1-norm, 2-norm or the infinity-norm. In the case of 2-norm the result is the ratio of the largest to the smallest singular value of <strong>A</strong>. For more details, see <a href="http://en.wikipedia.org/wiki/Condition_number">http://en.wikipedia.org/wiki/Condition_number</a>.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2;
     2, 1];
r = conditionNumber(A);

results in:

r = 3.0</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rcond">Matrices.rcond</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="9%" />
<col width="12%" />
<col width="12%" />
<col width="66%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Input matrix</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">p</td>
<td align="left">2</td>
<td align="left">Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="15%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result</td>
<td align="left">p-norm of matrix A</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function conditionNumber 
  &quot;Return the condition number norm(A)*norm(inv(A)) of a matrix A&quot;
  extends Modelica.Icons.Function;

  input Real A[:,:] &quot;Input matrix&quot;;
  input Real p(min=1) = 2 
    &quot;Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)&quot;;
  output Real result=0.0 &quot;p-norm of matrix A&quot;;

protected 
  Real eps=1e-25;
  Real s[size(A, 1)] &quot;singular values&quot;;

algorithm 
  if min(size(A)) &gt; 0 then
    if p == 2 then
      s := Modelica.Math.Matrices.singularValues(A);
      if min(s) &lt; eps then
        result := Modelica.Constants.inf;
      else
        result := max(s)/min(s);
      end if;
    else
      result := Modelica.Math.Matrices.norm(A, p)*Modelica.Math.Matrices.norm(
        Modelica.Math.Matrices.inv(A), p);
    end if;
  end if;

end conditionNumber;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image103" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.rcond</h2>
<p><strong>Return the reciprocal condition number of a matrix</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>r = Matrices.rcond(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function estimates the reciprocal of the condition number (norm(A) * norm(inv(A))) of a general real matrix <strong>A</strong>, in either the 1-norm or the infinity-norm, using the LAPACK function <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgecon">DGECON</a>. If rcond(A) is near 1.0, <strong>A</strong> is well conditioned and <strong>A</strong> is ill conditioned if rcond(A) is near zero.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2;
     2, 1];
r = rcond(A);

results in:

r = 0.3333</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.conditionNumber">Matrices.conditionNumber</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="11%" />
<col width="20%" />
<col width="11%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square real matrix</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">inf</td>
<td align="left">false</td>
<td align="left">Is true if infinity norm is used and false for 1-norm</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="16%" />
<col width="13%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">rcond</td>
<td align="left">Reciprocal condition number of A</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">info</td>
<td align="left">Information</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function rcond &quot;Return the reciprocal condition number of a matrix&quot;
  extends Modelica.Icons.Function;
  input Real A[:,size(A,1)] &quot;Square real matrix&quot;;
  input Boolean inf = false 
    &quot;Is true if infinity norm is used and false for 1-norm&quot;;
  output Real rcond &quot;Reciprocal condition number of A&quot;;
  output Integer info &quot;Information&quot;;
protected 
  Real LU[size(A,1),size(A,1)] 
    &quot;LU factorization of matrix A, returned by dgetrf&quot;;
  Real anorm &quot;Norm of matrix A&quot;;
  String normspec= if inf then &quot;I&quot; else &quot;1&quot; &quot;Specifies the norm 1 or inf&quot;;

algorithm 
  if min(size(A)) &gt; 0 then
    (LU,,info) := Modelica.Math.Matrices.LAPACK.dgetrf(A);
    anorm := Modelica.Math.Matrices.LAPACK.dlange(A,normspec);
    (rcond,info) := Modelica.Math.Matrices.LAPACK.dgecon(LU,inf,anorm);
  else
    rcond := Modelica.Constants.inf;
    info := 0;
  end if;

end rcond;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image104" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.norm</h2>
<p><strong>Return the p-norm of a matrix</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>Matrices.norm(A);
Matrices.norm(A, p=2);</code></pre>
</blockquote>
<h4>Description</h4>
<p>The function call &quot;<code>Matrices.norm(A)</code>&quot; returns the 2-norm of matrix A, i.e., the largest singular value of A. The function call &quot;<code>Matrices.norm(A, p)</code>&quot; returns the p-norm of matrix A. The only allowed values for p are</p>
<ul>
<li>&quot;p=1&quot;: the largest column sum of A</li>
<li>&quot;p=2&quot;: the largest singular value of A</li>
<li>&quot;p=Modelica.Constants.inf&quot;: the largest row sum of A</li>
</ul>
<p>Note, for any matrices A1, A2 the following inequality holds:</p>
<blockquote>
<pre><code>Matrices.norm(A1+A2,p) ≤ Matrices.norm(A1,p) + Matrices.norm(A2,p)</code></pre>
</blockquote>
<p>Note, for any matrix A and vector v the following inequality holds:</p>
<blockquote>
<pre><code>Vectors.norm(A*v,p) ≤ Matrices.norm(A,p)*Vectors.norm(A,p)</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.frobeniusNorm">Matrices.frobeniusNorm</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="9%" />
<col width="12%" />
<col width="12%" />
<col width="66%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Input matrix</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">p</td>
<td align="left">2</td>
<td align="left">Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="15%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result</td>
<td align="left">p-norm of matrix A</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function norm &quot;Return the p-norm of a matrix&quot;
  extends Modelica.Icons.Function;
  input Real A[:, :] &quot;Input matrix&quot;;
  input Real p(min=1) = 2 
    &quot;Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)&quot;;
  output Real result=0.0 &quot;p-norm of matrix A&quot;;

algorithm 
  if p == 1 then
    // column sum norm
    for i in 1:size(A, 2) loop
      result := max(result, sum(abs(A[:, i])));
    end for;
  elseif p == 2 then
    // largest singular value
    result := max(singularValues(A));
  elseif p == Modelica.Constants.inf then
    // row sum norm
    for i in 1:size(A, 1) loop
      result := max(result, sum(abs(A[i, :])));
    end for;
  else
    assert(false, &quot;Optional argument \&quot;p\&quot; of function \&quot;norm\&quot; must be
1, 2 or Modelica.Constants.inf&quot;);
  end if;
end norm;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image105" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.frobeniusNorm</h2>
<p><strong>Return the Frobenius norm of a matrix</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>r = Matrices.frobeniusNorm(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function computes the Frobenius norm of a general real matrix <strong>A</strong>, i.e., the square root of the sum of the squares of all elements.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2;
     2, 1];
r = frobeniusNorm(A);

results in:

r = 3.162;</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm">Matrices.norm</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="16%" />
<col width="16%" />
<col width="23%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Input matrix</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="15%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result</td>
<td align="left">Frobenius norm of matrix A</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function frobeniusNorm &quot;Return the Frobenius norm of a matrix&quot;
  extends Modelica.Icons.Function;
  input Real A[:,:] &quot;Input matrix&quot;;
  output Real result &quot;Frobenius norm of matrix A&quot;;

algorithm 
  result := if min(size(A))&gt;0 then sqrt(sum(A.*A)) else -1e100;

end frobeniusNorm;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image106" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.nullSpace</h2>
<p><strong>Return the orthonormal nullspace of a matrix</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>Z = Matrices.nullspace(A);</code></pre>
<blockquote>
<p>(Z, nullity) = Matrices.nullspace(A);</p>
</blockquote>
</blockquote>
<h4>Description</h4>
<p>This function calculates an orthonormal basis <strong>Z</strong>=[<strong>z</strong>_1, <strong>z</strong>_2, ...] of the nullspace of a matrix <strong>A</strong>, i.e., <strong>A</strong>*<strong>z</strong>_i=<strong>0</strong>.</p>
<p>The nullspace is obtained by svd method. That is, matrix <strong>A</strong> is decomposed into the matrices <strong>S</strong>, <strong>U</strong>, <strong>V</strong>:</p>
<blockquote>
<pre><code>A = U*S*transpose(V)</code></pre>
</blockquote>
<p>with the orthonormal matrices <strong>U</strong> and <strong>V</strong> and the matrix <strong>S</strong> with</p>
<blockquote>
<pre><code>S = [S1, 0]
S1 = [diag(s); 0]</code></pre>
</blockquote>
<p>and the singular values <strong>s</strong>={s1, s2, ..., sr} of <strong>A</strong> and r=rank(<strong>A</strong>). Note, that <strong>S</strong> has the same size as <strong>A</strong>. Since <strong>U</strong> and <strong>V</strong> are orthonormal we may write</p>
<blockquote>
<pre><code>transpose(U)*A*V = [S1, 0].</code></pre>
</blockquote>
<p>Matrix <strong>S</strong>1 obviously has full column rank and therefore, the left n-r rows (n is the number of columns of <strong>A</strong> or <strong>S</strong>) of matrix <strong>V</strong> span a nullspace of <strong>A</strong>.</p>
<p>The nullity of matrix <strong>A</strong> is the dimension of the nullspace of <strong>A</strong>. In view of the above, it becomes clear that nullity holds</p>
<blockquote>
<pre><code>nullity = n - r</code></pre>
</blockquote>
<p>with</p>
<blockquote>
<pre><code>n = number of columns of matrix A
r = rank(A)</code></pre>
</blockquote>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2,  3, 1;
     3, 4,  5, 2;
    -1, 2, -3, 3];
(Z, nullity) = nullspace(A);

results in:

Z=[0.1715;
  -0.686;
   0.1715;
   0.686]

nullity = 1</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues">Matrices.singularValues</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="16%" />
<col width="16%" />
<col width="23%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Input matrix</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="14%" />
<col width="25%" />
<col width="60%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">Z[size(A, 2), :]</td>
<td align="left">Orthonormal nullspace of matrix A</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">nullity</td>
<td align="left">Nullity, i.e., the dimension of the nullspace</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function nullSpace &quot;Return the orthonormal nullspace of a matrix&quot;
  extends Modelica.Icons.Function;

  input Real A[:,:] &quot;Input matrix&quot;;
  output Real Z[size(A, 2),:] &quot;Orthonormal nullspace of matrix A&quot;;
  output Integer nullity &quot;Nullity, i.e., the dimension of the nullspace&quot;;

protected 
  Real V[size(A, 2),size(A, 2)] &quot;Right orthogonal matrix &quot;;
  Real sigma[min(size(A, 1), size(A, 2))] &quot;singular values&quot;;
  Integer rank &quot;rank of matrix A&quot;;
  Real eps &quot;tolerance for rank determination&quot;;
  Integer n=min(size(A, 1), size(A, 2));
  Integer i=n;

algorithm 
  (sigma,,V) := Modelica.Math.Matrices.singularValues(A);
  V := transpose(V);
  // rank computation
  eps := max(size(A, 1), size(A, 2))*max(sigma)*Modelica.Constants.eps;
  rank := 0;
  if n &gt; 0 then
    while i &gt; 0 loop
      if sigma[i] &gt; eps then
        rank := i;
        i := 0;
      end if;
      i := i - 1;
    end while;
  end if;
  Z := V[:, rank + 1:size(A, 2)];// nullspace computation
  nullity := size(A, 2) - rank;// nullity

end nullSpace;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image107" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.exp</h2>
<p><strong>Return the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>phi = Matrices.exp(A);
phi = Matrices.exp(A,T=1);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function computes the exponential e<sup>**A**T</sup> of matrix <strong>A</strong>, i.e.</p>
<blockquote>
<pre><code>(AT)^2   (AT)^3</code></pre>
<blockquote>
<dl>
<dt>Φ = e^(AT) = I + AT + ------ + ------ + ....</dt>
<dd><p>2! 3!</p>
</dd>
</dl>
</blockquote>
</blockquote>
<p>where e=2.71828..., <strong>A</strong> is an n x n matrix with real elements and T is a real number, e.g., the sampling time. <strong>A</strong> may be singular. With the exponential of a matrix it is, e.g., possible to compute the solution of a linear system of differential equations</p>
<pre><code>der(x) = A*x   -&gt;   x(t0 + T) = e^(AT)*x(t0)</code></pre>
<h4>Algorithmic details:</h4>
<p>The algorithm is taken from</p>
<ol start="8" style="list-style-type: upper-alpha">
<li><ol start="4" style="list-style-type: upper-alpha">
<li>Joos, G. Gruebel:</li>
</ol></li>
</ol>
<dl>
<dt><strong>RASP'91 Regulator Analysis and Synthesis Programs</strong></dt>
<dd><p>DLR - Control Systems Group 1991</p>
</dd>
</dl>
<p>The following steps are performed to calculate the exponential of A:</p>
<ol>
<li><dl>
<dt>Matrix <strong>A</strong> is balanced</dt>
<dd><p>(= is transformed with a diagonal matrix <strong>D</strong>, such that</p>
</dd>
</dl>
inv(<strong>D</strong>)*<strong>A</strong>*<strong>D</strong> has a smaller condition as <strong>A</strong>).</li>
<li>The scalar T is divided by a multiple of 2 such that norm( inv(<strong>D</strong>)*<strong>A</strong>*<strong>D</strong>*T/2^k ) &lt; 0.5. Note, that (1) and (2) are implemented such that no round-off errors are introduced.</li>
<li>The matrix from (2) is approximated by explicitly performing the Taylor series expansion with a variable number of terms. Truncation occurs if a new term does no longer contribute to the value of <strong>Φ</strong> from the previous iteration.</li>
<li>The resulting matrix is transformed back, by reverting the steps of (2) and (1).</li>
</ol>
<p>In several sources it is not recommended to use Taylor series expansion to calculate the exponential of a matrix, such as in 'C.B. Moler and C.F. Van Loan: Nineteen dubious ways to compute the exponential of a matrix. SIAM Review 20, pp. 801-836, 1979' or in the documentation of m-file expm2 in Matlab version 6 (<a href="http://www.MathWorks.com">http://www.MathWorks.com</a>) where it is stated that 'As a practical numerical method, this is often slow and inaccurate'. These statements are valid for a direct implementation of the Taylor series expansion, but <em>not</em> for the implementation variant used in this function.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">T</td>
<td align="left">1</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="44%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">phi[size(A, 1), size(A, 1)]</td>
<td align="left">= exp(A*T)</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function exp 
  &quot;Return the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing&quot;

  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)];
  input Real T=1;
  output Real phi[size(A, 1), size(A, 1)] &quot;= exp(A*T)&quot;;

protected 
  parameter Integer nmax=21;
  /*max number of iterations*/
  parameter Integer na=size(A, 1);
  Integer j=1;
  Integer k=0;
  Boolean done=false;
  Real Anorm;
  Real Tscaled=1;
  Real Atransf[na, na];
  Real D[na, na];
  /*D: dummy variable for psi*/
  Real M[na, na];
  /*M: dummy matrix*/
  Real Diag[na];
  /*diagonal transformation matrix for balancing*/

encapsulated function columnNorm 
    &quot;Returns the column norm of a matrix&quot;
  input Real A[:, :] &quot;Input matrix&quot;;
  output Real result=0.0 &quot;1-norm of matrix A&quot;;
algorithm 
   for i in 1:size(A, 2) loop
      result := max(result, sum(abs(A[:, i])));
   end for;
end columnNorm;

algorithm 
  // balancing of A
  (Diag,Atransf) := balance(A);

  // scaling of T until norm(A)*/(2^k) &lt; 1
  Tscaled := T;
  /*Anorm: column-norm of matrix A*/
  Anorm := columnNorm(Atransf);
  Anorm := Anorm*T;
  while Anorm &gt;= 0.5 loop
    Anorm := Anorm/2;
    Tscaled := Tscaled/2;
    k := k + 1;
  end while;

  // Computation of psi by Taylor-series approximation
  M := identity(na);
  D := M;
  while j &lt; nmax and not done loop
    M := Atransf*M*Tscaled/j;
    //stop if the new element of the series is small
    if columnNorm((D + M) - D) == 0 then
      done := true;
    else
      D := M + D;
      j := j + 1;
    end if;
  end while;

  // re-scaling
  for i in 1:k loop
    D := D*D;
  end for;

  // re-balancing: psi := diagonal(Diag)*D*inv(diagonal(Diag));
  for j in 1:na loop
    for k in 1:na loop
      phi[j, k] := D[j, k]*Diag[j]/Diag[k];
    end for;
  end for;
end exp;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image108" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.integralExp</h2>
<p><strong>Return the exponential and the integral of the exponential of a matrix</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>(phi,gamma) = Matrices.integralExp(A,B);
(phi,gamma) = Matrices.integralExp(A,B,T=1);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function computes the exponential phi = e^(<strong>A</strong>T) of matrix <strong>A</strong> and the integral gamma = integral(phi*dt)*B.</p>
<p>The function uses a Taylor series expansion with Balancing and scaling/squaring to approximate the integral <strong>Ψ</strong> of the matrix exponential <strong>Φ</strong>=e^(AT):</p>
<pre><code>AT^2   A^2 * T^3          A^k * T^(k+1)</code></pre>
<blockquote>
<p>Ψ = int(e^(As))ds = IT + ---- + --------- + ... + -------------- 2! 3! (k+1)!</p>
</blockquote>
<p><strong>Φ</strong> is calculated through <strong>Φ</strong> = I + A*<strong>Ψ</strong>, so A may be singular. <strong>Γ</strong> is simply <strong>Ψ</strong>*B.</p>
<p>The algorithm runs in the following steps:</p>
<ol>
<li>Balancing</li>
<li>Scaling</li>
<li>Taylor series expansion</li>
<li>Re-scaling</li>
<li>Re-Balancing</li>
</ol>
<p>Balancing put the bad condition of a square matrix <em>A</em> into a diagonal transformation matrix <em>D</em>. This reduce the effort of following calculations. Afterwards the result have to be re-balanced by transformation D*Atransf *inv(D). Scaling halfen T k-times, until the norm of A*T is less than 0.5. This garantees minumum rounding errors in the following series expansion. The re-scaling based on the equation exp(A*2T) = exp(AT)^2. The needed re-scaling formula for psi thus becomes:</p>
<pre><code>Φ = Φ&#39;*Φ&#39;</code></pre>
<blockquote>
<p>I + A<em>Ψ = I + 2A</em>Ψ' + A^2<em>Ψ'^2 Ψ = A</em>Ψ'^2 + 2*Ψ'</p>
</blockquote>
<p>where psi' is the scaled result from the series expansion while psi is the re-scaled matrix.</p>
<p>The function is normally used to discretize a state-space system as the zero-order-hold equivalent:</p>
<pre><code>x(k+1) = Φ*x(k) + Γ*u(k)
  y(k) = C*x(k) + D*u(k)</code></pre>
<p>The zero-order-hold sampling, also known as step-invariant method, gives exact values of the state variables, under the assumption that the control signal u is constant between the sampling instants. Zero-order-hold sampling is discribed in</p>
<ol start="11" style="list-style-type: upper-alpha">
<li><ol start="10" style="list-style-type: upper-alpha">
<li>Astroem, B. Wittenmark:</li>
</ol></li>
</ol>
<dl>
<dt><strong>Computer Controlled Systems - Theory and Design</strong></dt>
<dd><p>Third Edition, p. 32</p>
</dd>
</dl>
<pre><code>Syntax:
      (phi,gamma) = Matrices.expIntegral(A,B,T)
                       A,phi: [n,n] square matrices
                     B,gamma: [n,m] input matrix
                           T: scalar, e.g., sampling time</code></pre>
<p>The Algorithm to calculate psi is taken from</p>
<ol start="8" style="list-style-type: upper-alpha">
<li><ol start="4" style="list-style-type: upper-alpha">
<li>Joos, G. Gruebel:</li>
</ol></li>
</ol>
<dl>
<dt><strong>RASP'91 Regulator Analysis and Synthesis Programs</strong></dt>
<dd><p>DLR - Control Systems Group 1991</p>
</dd>
</dl>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[size(A, 1), :]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">T</td>
<td align="left">1</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="47%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">phi[size(A, 1), size(A, 1)]</td>
<td align="left">= exp(A*T)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">gamma[size(A, 1), size(B, 2)]</td>
<td align="left">= integral(phi)*B</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function integralExp 
  &quot;Return the exponential and the integral of the exponential of a matrix&quot;

  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)];
  input Real B[size(A, 1), :];
  input Real T=1;
  output Real phi[size(A, 1), size(A, 1)] &quot;= exp(A*T)&quot;;
  output Real gamma[size(A, 1), size(B, 2)] &quot;= integral(phi)*B&quot;;
protected 
  parameter Integer nmax=21;
  /*max number of iterations*/
  parameter Integer na=size(A, 1);
  Integer j=2;
  Integer k=0;
  Boolean done=false;
  Real Anorm;
  Real Tscaled=1;
  Real Atransf[na, na];
  Real Psi[na, na];
  /*Psi: dummy variable for psi*/
  Real M[na, na];
  /*M: dummy matrix*/
  Real Diag[na];
  /*diagonal transformation matrix for balancing*/

encapsulated function columnNorm 
    &quot;Returns the column norm of a matrix&quot;
  input Real A[:, :] &quot;Input matrix&quot;;
  output Real result=0.0 &quot;1-norm of matrix A&quot;;
algorithm 
   for i in 1:size(A, 2) loop
      result := max(result, sum(abs(A[:, i])));
   end for;
end columnNorm;
algorithm 
  // balancing of A
  (Diag,Atransf) := balance(A);

  // scaling of T until norm(A)*/(2^k) &lt; 0.5
  Tscaled := T;
  /*Anorm: column-norm of matrix A*/
  // Anorm := norm(Atransf, 1);
  Anorm := columnNorm(Atransf);
  Anorm := Anorm*T;
  while Anorm &gt;= 0.5 loop
    Anorm := Anorm/2;
    Tscaled := Tscaled/2;
    k := k + 1;
  end while;

  // Computation of psi by Taylor-series approximation
  M := identity(na)*Tscaled;
  Psi := M;
  while j &lt; nmax and not done loop
    M := Atransf*M*Tscaled/j;
    //stop if the new element of the series is small
    // if norm((Psi + M) - Psi, 1) == 0 then
    if columnNorm((Psi + M) - Psi) == 0 then
      done := true;
    else
      Psi := M + Psi;
      j := j + 1;
    end if;
  end while;

  // re-scaling
  for j in 1:k loop
    Psi := Atransf*Psi*Psi + 2*Psi;
  end for;

  // re-balancing: psi := diagonal(Diag)*D*inv(diagonal(Diag));
  for j in 1:na loop
    for k in 1:na loop
      Psi[j, k] := Psi[j, k]*Diag[j]/Diag[k];
    end for;
  end for;
  gamma := Psi*B;
  phi := A*Psi + identity(na);

end integralExp;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.balanceI.png" alt="image109" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.integralExpT</h2>
<p><strong>Return the exponential, the integral of the exponential, and time-weighted integral of the exponential of a matrix</strong></p>
<h3>Information</h3>
<pre><code>::

    (phi,gamma,gamma1) = Matrices.integralExp(A,B);
    (phi,gamma,gamma1) = Matrices.integralExp(A,B,T=1);</code></pre>
<h4>Description</h4>
<p>This function computes the exponential phi = e^(<strong>A</strong>T) of matrix <strong>A</strong> and the integral gamma = integral(phi*dt)*B and the integral integral((T-t)*exp(A*t)*dt)*B, where A is a square (n,n) matrix and B, gamma, and gamma1 are (n,m) matrices.</p>
<p>The function calculates the matrices phi,gamma,gamma1 through the equation:</p>
<pre><code>[ A B 0 ]</code></pre>
<blockquote>
<dl>
<dt>[phi gamma gamma1] = [I 0 0]<em>exp([ 0 0 I ]</em>T)</dt>
<dd><p>[ 0 0 0 ]</p>
</dd>
</dl>
</blockquote>
<p>The matrices define the discretized first-order-hold equivalent of a state-space system:</p>
<pre><code>x(k+1) = phi*x(k) + gamma*u(k) + gamma1/T*(u(k+1) - u(k))</code></pre>
<p>The first-order-hold sampling, also known as ramp-invariant method, gives more smooth control signals as the ZOH equivalent. First-order-hold sampling is, e.g., described in</p>
<ol start="11" style="list-style-type: upper-alpha">
<li><ol start="10" style="list-style-type: upper-alpha">
<li>Astroem, B. Wittenmark:</li>
</ol></li>
</ol>
<dl>
<dt><strong>Computer Controlled Systems - Theory and Design</strong></dt>
<dd><p>Third Edition, p. 256</p>
</dd>
</dl>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="29%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[size(A, 1), :]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">T</td>
<td align="left">1</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="11%" />
<col width="43%" />
<col width="45%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">phi[size(A, 1), size(A, 1)]</td>
<td align="left">= exp(A*T)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">gamma[size(A, 1), size(B, 2)]</td>
<td align="left">= integral(phi)*B</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">gamma1[size(A, 1), size(B, 2)]</td>
<td align="left">= integral((T-t)*exp(A*t))*B</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function integralExpT 
  &quot;Return the exponential, the integral of the exponential, and time-weighted integral of the exponential of a matrix&quot;

  extends Modelica.Icons.Function;
  input Real A[:, size(A, 1)];
  input Real B[size(A, 1), :];
  input Real T=1;
  output Real phi[size(A, 1), size(A, 1)] &quot;= exp(A*T)&quot;;
  output Real gamma[size(A, 1), size(B, 2)] &quot;= integral(phi)*B&quot;;
  output Real gamma1[size(A, 1), size(B, 2)] &quot;= integral((T-t)*exp(A*t))*B&quot;;
protected 
  Integer nmax=200;
  /*max number of iterations*/
  parameter Integer na=size(A, 1);
  parameter Integer nb=size(B, 2);
  Integer j=1;
  Boolean done=false;
  Real F[na + 2*nb, na + 2*nb];

algorithm 
  F := [A, B, zeros(na, nb); zeros(2*nb, na), zeros(2*nb, nb), [identity(nb);
     zeros(nb, nb)]];
  F := exp(F, T);
  phi := F[1:na, 1:na];
  gamma := F[1:na, na + 1:na + nb];
  gamma1 := F[1:na, na + nb + 1:na + 2*nb];

end integralExpT;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.continuousLyapunov</h2>
<p><strong>Return solution X of the continuous-time Lyapunov equation X*A + A'*X = C</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>X = Matrices.continuousLyapunov(A, C);
X = Matrices.continuousLyapunov(A, C, ATisSchur, eps);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function computes the solution <strong>X</strong> of the continuous-time Lyapunov equation</p>
<blockquote>
<pre><code>X*A + A&#39;*X = C</code></pre>
</blockquote>
<p>using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].</p>
<p>In a nutshell, the problem is reduced to the corresponding problem</p>
<blockquote>
<pre><code>Y*R&#39; + R*Y = D</code></pre>
</blockquote>
<p>with <strong>R</strong>=<strong>U</strong>'*<strong>A'</strong>*<strong>U</strong> is the real Schur form of <strong>A</strong>' and <strong>D</strong>=<strong>U</strong>'*<strong>C</strong>*<strong>U</strong> and <strong>Y</strong>=<strong>U</strong>'*<strong>X</strong>*<strong>U</strong> are the corresponding transformations of <strong>C</strong> and <strong>X</strong>. This problem is solved sequently for the 1x1 or 2x2 Schur blocks by exploiting the block triangular form of <strong>R</strong>. Finally the solution of the original problem is recovered as <strong>X</strong>=<strong>U</strong>*<strong>Y</strong>*<strong>U</strong>'. The boolean input &quot;ATisSchur&quot; indicates to omit the transformation to Schur in the case that <strong>A</strong>' has already Schur form.</p>
<h4>References</h4>
<pre><code>[1] Bartels, R.H. and Stewart G.W.
    Algorithm 432: Solution of the matrix equation AX + XB = C.
    Comm. ACM., Vol. 15, pp. 820-826, 1972.</code></pre>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2,  3,  4;
     3, 4,  5, -2;
    -1, 2, -3, -5;
     0, 2,  0,  6];

C =  [-2, 3, 1, 0;
      -6, 8, 0, 1;
       2, 3, 4, 5;
      0, -2, 0, 0];

X = continuousLyapunov(A, C);

results in:

X = [1.633, -0.761,  0.575, -0.656;
    -1.158,  1.216,  0.047,  0.343;
    -1.066, -0.052, -0.916,  1.61;
    -2.473,  0.717, -0.986,  1.48]</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousSylvester">Matrices.continuousSylvester</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteLyapunov">Matrices.discreteLyapunov</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="9%" />
<col width="22%" />
<col width="27%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix A in X*A + A'*X = C</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">C[size(A, 1), size(A, 2)]</td>
<td align="left">
</td>
<td align="left">Square matrix C in X*A + A'*X = C</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">ATisSchur</td>
<td align="left">false</td>
<td align="left">True if transpose(A) has already real Schur form</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">Modelica.Math.Matrices.norm(...</td>
<td align="left">Tolerance eps</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="9%" />
<col width="31%" />
<col width="59%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(A, 1), size(A, 2)]</td>
<td align="left">Solution X of the Lyapunov equation X*A + A'*X = C</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function continuousLyapunov 
  &quot;Return solution X of the continuous-time Lyapunov equation X*A + A&#39;*X = C&quot;
  import Modelica.Math.Matrices;

  input Real A[:,size(A, 1)] &quot;Square matrix A in X*A + A&#39;*X = C&quot;;
  input Real C[size(A, 1),size(A, 2)] &quot;Square matrix C in X*A + A&#39;*X = C&quot;;
  input Boolean ATisSchur=false 
    &quot;True if transpose(A) has already real Schur form&quot;;
  input Real eps=Modelica.Math.Matrices.norm(A, 1)*10*1e-15 &quot;Tolerance eps&quot;;

protected 
  Integer n=size(A, 1);
  Real R[size(A, 1),size(A, 2)] &quot;rsf of A&#39;, i.e., R=U&#39;A&#39;U&quot;;
  Real U[size(A, 1),size(A, 2)] &quot;transformation matrix U for R=U&#39;A&#39;U&quot;;
  Real D[size(A, 1),size(A, 2)] &quot;Matrix D=U&#39;*C*U&quot;;
  Real R11[size(A, 1),size(A, 2)];
  Real R22[size(A, 1),size(A, 2)];
  Real R12[size(A, 1),size(A, 2)];
  Real R21[size(A, 1),size(A, 2)];
  Real R2[2*size(A, 1),2*size(A, 2)];
  Real I[size(A, 1),size(A, 1)]=identity(size(A, 1));
  Real y[2*size(A, 1)];
  Real c[2*size(A, 1)];
  Real CC[size(A, 1),2];
  Integer k;

public 
  output Real X[size(A, 1),size(A, 2)] 
    &quot;Solution X of the Lyapunov equation  X*A + A&#39;*X = C&quot;;

algorithm 
  if n &gt; 1 then
    if ATisSchur then
      R := transpose(A);
      U := identity(n);
      D := C;
    else
      (R,U) := Modelica.Math.Matrices.realSchur(transpose(A));
      D := transpose(U)*C*U;
    end if;

    X := zeros(n, n);

// Calculate the last 1 or 2 columns of X
    R22 := R;
    for i1 in 1:n loop
      R22[i1, i1] := R[i1, i1] + R[n, n];
    end for;
    if abs(R[n, n - 1]) &lt; eps then
      X[:, n] := Matrices.solve(R22, D[:, n]);
      k := n - 1;
    else
      R11 := R;
      R12 := zeros(n, n);
      R21 := zeros(n, n);
      for i1 in 1:n loop
        R11[i1, i1] := R[i1, i1] + R[n - 1, n - 1];
        R12[i1, i1] := R[n - 1, n];
        R21[i1, i1] := R[n, n - 1];
      end for;

// solve 2nx2n equation for 2x2 Schur bump with Kronecker product and vec operator approach
      R2 := [R11,R12; R21,R22];
      c := cat(1, D[:, n - 1], D[:, n]);
      y := Matrices.solve(R2, c);
      X[:, n - 1] := y[1:n];
      X[:, n] := y[n + 1:2*n];
      k := n - 2;
    end if;

// Calculate the rest of X
    while k &gt; 1 loop
      R22 := R;
      for i1 in 1:n loop
        R22[i1, i1] := R[i1, i1] + R[k, k];
      end for;
      if abs(R[k, k - 1]) &lt; eps then
        //real eigenvalue
        X[:, k] := Matrices.solve(R22, D[:, k] - vector(X[:, k + 1:n]*matrix(R[
          k, k + 1:n])));
        k := k - 1;
      else
       // conjugated complex eigenvalues
        R11 := R;
        R12 := zeros(n, n);
        R21 := zeros(n, n);
        for i1 in 1:n loop
          R11[i1, i1] := R[i1, i1] + R[k - 1, k - 1];
          R12[i1, i1] := R[k - 1, k];
          R21[i1, i1] := R[k, k - 1];
        end for;
        R2 := [R11,R12; R21,R22];
        CC := D[:, k - 1:k] - X[:, k + 1:n]*transpose(R[k - 1:k, k + 1:n]);
        c := cat(
          1,
          CC[:, 1],
          CC[:, 2]);
        y := Matrices.solve(R2, c);
        X[:, k - 1] := y[1:n];
        X[:, k] := y[n + 1:2*n];

        k := k - 2;
      end if;
    end while;// k=1 or k=0

// if k=1 the first column (if there exist a real eigenvalue) has to be calculated separately
    if k == 1 then
      R22 := R;
      for i1 in 1:n loop
        R22[i1, i1] := R[i1, i1] + R[1, 1];
      end for;
      X[:, 1] := Matrices.solve(R22, D[:, 1] - vector(X[:, 2:n]*matrix(R[1, 2:n])));
    end if;

// transform X corresponding to the original form
    if not ATisSchur then
      X := U*X*transpose(U);
    end if;

  elseif n == 1 then //simple scalar equation
    X[1, 1] := C[1, 1]/(2*A[1, 1]);
  else
    X := fill(0, 0, 0);
  end if;

end continuousLyapunov;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.continuousSylvester</h2>
<p><strong>Return solution X of the continuous-time Sylvester equation A*X + X*B = C</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>X = Matrices.continuousSylvester(A, B, C);
X = Matrices.continuousSylvester(A, B, C, AisSchur, BisSchur);</code></pre>
</blockquote>
<h4>Description</h4>
<p>Function <strong>continuousSylvester</strong> computes the solution <strong>X</strong> of the continuous-time Sylvester equation</p>
<blockquote>
<pre><code>A*X + X*B = C.</code></pre>
</blockquote>
<p>using the Schur method for Sylvester equations proposed by Bartels and Stewart [1].</p>
<p>In a nutshell, the problem is reduced to the corresponding problem</p>
<blockquote>
<pre><code>S*Y + Y*T = D.</code></pre>
</blockquote>
<p>with <strong>S</strong>=<strong>U</strong>'*<strong>A</strong>*<strong>U</strong> is the real Schur of <strong>A</strong>, <strong>T</strong>=<strong>V</strong>'*<strong>T</strong>*<strong>V</strong> is the real Schur form of <strong>B</strong> and <strong>D</strong>=<strong>U</strong>'*<strong>C</strong>*<strong>V</strong> and <strong>Y</strong>=<strong>U</strong>*<strong>X</strong>*<strong>V</strong>' are the corresponding transformations of <strong>C</strong> and <strong>X</strong>. This problem is solved sequently by exploiting the block triangular form of <strong>S</strong> and <strong>T</strong>. Finally the solution of the original problem is recovered as <strong>X</strong>=<strong>U</strong>'*<strong>Y</strong>*<strong>V</strong>. The boolean inputs &quot;AisSchur&quot; and &quot;BisSchur&quot; indicate to omit one or both of the transformation to Schur in the case that <strong>A</strong> and/or <strong>B</strong> have already Schur form.</p>
<p>The function applies LAPACK-routine DTRSYL. See <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dtrsyl">LAPACK.dtrsyl</a> for more information.</p>
<h4>References</h4>
<pre><code>[1] Bartels, R.H. and Stewart G.W.
    Algorithm 432: Solution of the matrix equation AX + XB = C.
    Comm. ACM., Vol. 15, pp. 820-826, 1972.</code></pre>
<h4>Example</h4>
<blockquote>
<pre><code>A = [17.0,   24.0,   1.0,   8.0,   15.0 ;
     23.0,    5.0,   7.0,  14.0,   16.0 ;
      0.0,    6.0,  13.0,  20.0,   22.0;
      0.0,    0.0,  19.0,  21.0,    3.0 ;
      0.0,    0.0,   0.0,   2.0,    9.0];

B =  [8.0, 1.0, 6.0;
      0.0, 5.0, 7.0;
      0.0, 9.0, 2.0];

C = [62.0,  -12.0, 26.0;
     59.0,  -10.0, 31.0;
     70.0,  -6.0,   9.0;
     35.0,  31.0,  -7.0;
     36.0, -15.0,   7.0];

X = continuousSylvester(A, B, C);

results in:

X = [0.0,  0.0,  1.0;
     1.0,  0.0,  0.0;
     0.0,  1.0,  0.0;
     1.0,  1.0, -1.0;
     2.0, -2.0,  1.0];</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteSylvester">Matrices.discreteSylvester</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousLyapunov">Matrices.continuousLyapunov</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="31%" />
<col width="12%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Square matrix A</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[:, :]</td>
<td align="left">
</td>
<td align="left">Square matrix B</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">C[size(A, 1), size(B, 2)]</td>
<td align="left">
</td>
<td align="left">Matrix C</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">AisSchur</td>
<td align="left">false</td>
<td align="left">True if A has already real Schur form</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">BisSchur</td>
<td align="left">false</td>
<td align="left">True if B has already real Schur form</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="10%" />
<col width="33%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(A, 1), size(B, 2)]</td>
<td align="left">Solution of the continuous Sylvester equation</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function continuousSylvester 
  &quot;Return solution X of the continuous-time Sylvester equation A*X + X*B = C&quot;
  import Modelica.Math.Matrices;

  input Real A[:,:] &quot;Square matrix A&quot;;
  input Real B[:,:] &quot;Square matrix B&quot;;
  input Real C[size(A, 1),size(B, 2)] &quot;Matrix C&quot;;
  input Boolean AisSchur=false &quot;True if A has already real Schur form&quot;;
  input Boolean BisSchur=false &quot;True if B has already real Schur form&quot;;
  output Real X[size(A, 1),size(B, 2)] 
    &quot;Solution of the continuous Sylvester equation&quot;;

protected 
  Integer n=size(A, 1);
  Integer m=size(B, 1);
  Real S[size(A, 1),size(A, 2)];
  Real T[size(B, 1),size(B, 2)];
  Real U[size(A, 1),size(A, 1)];
  Real V[size(B, 1),size(B, 1)];
  Real Chat[size(C, 1),size(C, 2)];
  Real scale;
  Integer info;

algorithm 
  if n &gt; 1 and m &gt; 1 then
    if AisSchur then
      S := A;
      U := identity(n);
    else
      (S,U) := Modelica.Math.Matrices.realSchur(    A);
    end if;
    if BisSchur then
      T := B;
      V := identity(m);
    else
      (T,V) := Modelica.Math.Matrices.realSchur(    B);
    end if;

    Chat := if AisSchur and BisSchur then C else if AisSchur then C*V else if 
      BisSchur then transpose(U)*C else transpose(U)*C*V;
    (X,scale,info) := Matrices.LAPACK.dtrsyl(S, T, Chat);
    assert(info == 0, &quot;Solving of Sylvester equation with Matrices.continuousSylvester was not sucessfull.\n
                    The value of info is &quot; + String(info) + &quot;, but should be zero. A value unequal to zero means:\n
            &lt; 0: if INFO = -i, the i-th argument had an illegal value\n
            = 1: A and B have common or very close eigenvalues; perturbed
                 values were used to solve the equation (but the matrices
                 A and B are unchanged).&quot;);
    X := if AisSchur and BisSchur then scale*X else if AisSchur then scale*X*
      transpose(V) else if BisSchur then scale*U*X else scale*U*X*transpose(V);
  else
    X := fill(0, n, m);
  end if;

end continuousSylvester;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.continuousRiccati</h2>
<p><strong>Return solution X of the continuous-time algebraic Riccati equation A'*X + X*A - X*B*inv(R)*B'*X + Q = 0 (care)</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>X = Matrices.continuousRiccati(A, B, R, Q);</code></pre>
<blockquote>
<p>(X, alphaReal, alphaImag) = Matrices.continuousRiccati(A, B, R, Q, true);</p>
</blockquote>
</blockquote>
<h4>Description</h4>
<p>Function <strong>continuousRiccati</strong> computes the solution <strong>X</strong> of the continuous-time algebraic Riccati equation</p>
<blockquote>
<pre><code>A&#39;*X + X*A - X*G*X + Q = 0</code></pre>
</blockquote>
<p>with <code>G = B*inv(R)*B'</code> using the Schur vector approach proposed by Laub [1].</p>
<p>It is assumed that <strong>Q</strong> is symmetric and positive semidefinite and <strong>R</strong> is symmetric, nonsingular and positive definite, (<strong>A</strong>,<strong>B</strong>) is stabilizable and (<strong>A</strong>,<strong>Q</strong>) is detectable.</p>
<p><strong>These assumptions are not checked in this function !!</strong></p>
<p>The assumptions guarantee that the Hamiltonian matrix</p>
<blockquote>
<pre><code>H = [A, -G; -Q, -A&#39;]</code></pre>
</blockquote>
<p>has no pure imaginary eigenvalue and can be put to an ordered real Schur form</p>
<blockquote>
<pre><code>U&#39;*H*U = S = [S11, S12; 0, S22]</code></pre>
</blockquote>
<p>with orthogonal similarity transformation <strong>U</strong>. <strong>S</strong> is ordered in such a way, that <strong>S</strong>11 contains the n stable eigenvalues of the closed loop system with system matrix <strong>A</strong> -<strong>B</strong>*inv(<strong>R</strong>)*<strong>B</strong>'*<strong>X</strong>. If <strong>U</strong> is partitioned to</p>
<blockquote>
<pre><code>U = [U11, U12; U21, U22]</code></pre>
</blockquote>
<p>with dimenstions according to <strong>S</strong>, the solution <strong>X</strong> is calculated by</p>
<blockquote>
<pre><code>X*U11 = U21.</code></pre>
</blockquote>
<p>With optional input <code>refinement=true</code> a subsequent iterative refinement based on Newton's method with exact line search is applied. See <a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative">continuousRiccatiIterative</a> for more information.</p>
<p>The algorithm calls LAPACK routines <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgehrd">dgehrd</a> (to compute the upper Hessenberg matrix of <strong>H</strong>), <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dorghr">dorghr</a> (to calculate the orthogonal matrix from the elementary reflectors as returned from dgehrd), <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dhseqr">dhseqr</a> (to put transformed <strong>H</strong> to Schur form and to calculate the eigenvalues of the closed loop system) and <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dtrsen">dtrsen</a> (to compute the ordered real Schur form and matrix <strong>U</strong>).</p>
<h4>References</h4>
<pre><code>[1] Laub, A.J.
    A Schur Method for Solving Algebraic Riccati equations.
    IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.</code></pre>
<h4>Example</h4>
<blockquote>
<pre><code>A = [0.0, 1.0;
     0.0, 0.0];

B = [0.0;
     1.0];

R = [1];

Q = [1.0, 0.0;
     0.0, 2.0];</code></pre>
<blockquote>
<p>X = continuousRiccati(A, B, R, Q);</p>
<blockquote>
<p>results in:</p>
</blockquote>
<dl>
<dt>X = [2.0, 1.0;</dt>
<dd><p>1.0, 2.0];</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices_Utilities.html#Modelica.Math.Matrices.Utilities.continuousRiccatiIterative">Matrices.Utilities.continuousRiccatiIterative</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteRiccati">Matrices.discreteRiccati</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="11%" />
<col width="29%" />
<col width="24%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix A in CARE</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[size(A, 1), :]</td>
<td align="left">
</td>
<td align="left">Matrix B in CARE</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">R[size(B, 2), size(B, 2)]</td>
<td align="left">identity(size(B, 2))</td>
<td align="left">Matrix R in CARE</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">Q[size(A, 1), size(A, 1)]</td>
<td align="left">identity(size(A, 1))</td>
<td align="left">Matrix Q in CARE</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">refine</td>
<td align="left">false</td>
<td align="left">True for subsequent refinement</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="9%" />
<col width="30%" />
<col width="59%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(A, 1), size(A, 2)]</td>
<td align="left">stabilizing solution of CARE</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">alphaReal[size(H, 1)]</td>
<td align="left">Real parts of eigenvalue=alphaReal+i*alphaImag</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">alphaImag[size(H, 1)]</td>
<td align="left">Imaginary parts of eigenvalue=(alphaReal+i*alphaImag</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function continuousRiccati 
  &quot;Return solution X of the continuous-time algebraic Riccati equation A&#39;*X + X*A - X*B*inv(R)*B&#39;*X + Q = 0 (care)&quot;
  import Modelica.Math.Matrices;

  input Real A[:,size(A, 1)] &quot;Square matrix A in CARE&quot;;
  input Real B[size(A, 1),:] &quot;Matrix B in CARE&quot;;
  input Real R[size(B, 2),size(B, 2)]=identity(size(B, 2)) &quot;Matrix R in CARE&quot;;
  input Real Q[size(A, 1),size(A, 1)]=identity(size(A, 1)) &quot;Matrix Q in CARE&quot;;
  input Boolean refine=false &quot;True for subsequent refinement&quot;;

protected 
  Integer n=size(A, 1);
  Real G[size(A, 1),size(A, 1)]=B*Modelica.Math.Matrices.solve2(R, transpose(B));
  Real H[2*size(A, 1),2*size(A, 1)]=[A,-G; -Q,-transpose(A)];
  Real H_RSF[2*size(A, 1),2*size(A, 1)]=H;
  Real Z[size(H, 1),size(H, 2)];
  Real Z11[size(A, 1),size(A, 2)];
  Real Z21[size(A, 1),size(A, 2)];

  Integer info;

public 
  output Real X[size(A, 1),size(A, 2)] &quot;stabilizing solution of CARE&quot;;
  output Real alphaReal[size(H, 1)] 
    &quot;Real parts of eigenvalue=alphaReal+i*alphaImag&quot;;
  output Real alphaImag[size(H, 1)] 
    &quot;Imaginary parts of eigenvalue=(alphaReal+i*alphaImag&quot;;
algorithm 
  if n &gt; 1 then
    (H_RSF,Z,alphaReal,alphaImag) := Modelica.Math.Matrices.realSchur(    H);
    (H_RSF,Z,alphaReal,alphaImag) := Matrices.Utilities.reorderRSF(
      H_RSF,
      Z,
      alphaReal,
      alphaImag,
      true);

    Z11 := Z[1:n, 1:n];
    Z21 := Z[n + 1:2*n, 1:n];
    if size(Z11, 1) &gt; 0 then

      (X,info) := Matrices.LAPACK.dgesvx(Z11, transpose(Z21));
      //this function does not need to transpose Z11 as solve2 does with //  X := transpose(Matrices.solve2(transpose(Z11), transpose(Z21)));
      assert(info == 0, &quot;Solving a linear system of equations with function \&quot;Matrices.LAPACK.dgesvx\&quot; is not possible, because the system has either no or infinitely many solutions (input A is singular).&quot;);
      X := transpose(X);

      if refine then
        X := Modelica.Math.Matrices.Utilities.continuousRiccatiIterative(
                                        A, B, R, Q, X);
      end if;
    else
      X := fill(0, size(Z21, 1), size(Z11, 1));
    end if;

  elseif n == 1 then
    X := matrix((A[1, 1] - sqrt(A[1, 1]*A[1, 1] + G[1, 1]*Q[1, 1]))/G[1, 1]);
    if X[1, 1]*G[1, 1] &lt; A[1, 1] then
      X := matrix((A[1, 1] + sqrt(A[1, 1]*A[1, 1] + G[1, 1]*Q[1, 1]))/G[1, 1]);
    end if;
  else
    X := fill(0, 0, 0);
  end if;

end continuousRiccati;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.discreteLyapunov</h2>
<p><strong>Return solution X of the discrete-time Lyapunov equation A'*X*A + sgn*X = C</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>X = Matrices.discreteLyapunov(A, C);
X = Matrices.discreteLyapunov(A, C, ATisSchur, sgn, eps);</code></pre>
</blockquote>
<h4>Description</h4>
<p>This function computes the solution <strong>X</strong> of the discrete-time Lyapunov equation</p>
<blockquote>
<pre><code>A&#39;*X*A + sgn*X = C</code></pre>
</blockquote>
<p>where sgn=1 or sgn =-1. For sgn = -1, the discrete Lyapunov equation is a special case of the Stein equation:</p>
<blockquote>
<pre><code>A*X*B - X + Q = 0.</code></pre>
</blockquote>
<p>The algorithm uses the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].</p>
<p>In a nutshell, the problem is reduced to the corresponding problem</p>
<blockquote>
<pre><code>R*Y*R&#39; + sgn*Y = D.</code></pre>
</blockquote>
<p>with <strong>R</strong>=<strong>U</strong>'*<strong>A'</strong>*<strong>U</strong> is the the real Schur form of <strong>A</strong>' and <strong>D</strong>=<strong>U</strong>'*<strong>C</strong>*<strong>U</strong> and <strong>Y</strong>=<strong>U</strong>'*<strong>X</strong>*<strong>U</strong> are the corresponding transformations of <strong>C</strong> and <strong>X</strong>. This problem is solved sequently by exploiting the block triangular form of <strong>R</strong>. Finally the solution of the original problem is recovered as <strong>X</strong>=<strong>U</strong>*<strong>Y</strong>*<strong>U</strong>'. The boolean input &quot;ATisSchur&quot; indicates to omit the transformation to Schur in the case that <strong>A</strong>' has already Schur form.</p>
<h4>References</h4>
<pre><code>[1] Bartels, R.H. and Stewart G.W.
    Algorithm 432: Solution of the matrix equation AX + XB = C.
    Comm. ACM., Vol. 15, pp. 820-826, 1972.</code></pre>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2,  3,  4;
     3, 4,  5, -2;
    -1, 2, -3, -5;
     0, 2,  0,  6];

C =  [-2,  3, 1, 0;
      -6,  8, 0, 1;
       2,  3, 4, 5;
       0, -2, 0, 0];

X = discreteLyapunov(A, C, sgn=-1);

results in:

X  = [7.5735,   -3.1426,  2.7205, -2.5958;
     -2.6105,    1.2384, -0.9232,  0.9632;
      6.6090,   -2.6775,  2.6415, -2.6928;
     -0.3572,    0.2298,  0.0533, -0.27410];</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteSylvester">Matrices.discreteSylvester</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousLyapunov">Matrices.continuousLyapunov</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="9%" />
<col width="22%" />
<col width="28%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix A in A'*X*A + sgn*X = C</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">C[size(A, 1), size(A, 2)]</td>
<td align="left">
</td>
<td align="left">Square matrix C in A'*X*A + sgn*X = C</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">ATisSchur</td>
<td align="left">false</td>
<td align="left">True if transpose(A) has already real Schur form</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">sgn</td>
<td align="left">1</td>
<td align="left">Specifies the sign in A'*X*A + sgn*X = C</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">Matrices.norm(A, 1)*10*Model...</td>
<td align="left">Tolerance eps</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="8%" />
<col width="29%" />
<col width="61%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(A, 1), size(A, 2)]</td>
<td align="left">Solution X of the Lyapunov equation A'*X*A + sgn*X = C</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function discreteLyapunov 
  &quot;Return solution X of the discrete-time Lyapunov equation A&#39;*X*A + sgn*X = C&quot;
  import Modelica.Math.Matrices;

  input Real A[:,size(A, 1)] &quot;Square matrix A in A&#39;*X*A + sgn*X = C&quot;;
  input Real C[size(A, 1),size(A, 2)] &quot;Square matrix C in A&#39;*X*A + sgn*X = C&quot;;
  input Boolean ATisSchur=false 
    &quot;True if transpose(A) has already real Schur form&quot;;
  input Integer sgn=1 &quot;Specifies the sign in A&#39;*X*A + sgn*X = C&quot;;
  input Real eps=Matrices.norm(A, 1)*10*Modelica.Constants.eps &quot;Tolerance eps&quot;;

protected 
  Integer n=size(A, 1);
  Real R[size(A, 1),size(A, 2)] &quot;RSF of A&#39;, i.e., R=U&#39;A&#39;U&quot;;
  Real U[size(A, 1),size(A, 2)] &quot;Transformation matrix U for R=U&#39;A&#39;U&quot;;
  Real D[size(A, 1),size(A, 2)] &quot;Matrix D=U&#39;*C*U&quot;;
  Real R22[size(A, 1),size(A, 2)];
  Real R11[size(A, 1),size(A, 2)];
  Integer k;

  Real g[size(A, 1)];
  Real w[size(A, 1)];
  Real y[2*size(A, 1)];
  Boolean crit;

public 
  output Real X[size(A, 1),size(A, 2)] 
    &quot;Solution X of the Lyapunov equation A&#39;*X*A + sgn*X = C&quot;;

algorithm 
  assert(sgn==1 or sgn==-1,&quot;Input sgn in function Math.Matrices.discreteLyapunov() must be 1 or -1, however it is &quot;+String(sgn));
  X := zeros(n, n);
  k := n;
  if n &gt; 1 then
    if ATisSchur then
      R := transpose(A);
      U := identity(n);
      D := C;
    else
      (R,U) := Modelica.Math.Matrices.realSchur(transpose(A));
       D := transpose(U)*C*U;
    end if;

    while k &gt; 0 loop
      w := D[:, k] - R*X[:, k + 1:n]*R[k, k + 1:n];
      crit := if k &gt; 1 then abs(R[k, k - 1]) &lt; eps else false;
      if (k == 1 or crit) then
        R22 := R[k, k]*R;
        for i in 1:n loop
          R22[i, i] := R22[i, i] + sgn;
        end for;
        X[:, k] := Matrices.solve(R22, w);
        k := k - 1;
      else
        g := D[:, k - 1] - R*X[:, k + 1:n]*R[k - 1, k + 1:n];
        R11 := R[k - 1, k - 1]*R;
        R22 := R[k, k]*R;
        for i in 1:n loop
          R11[i, i] := R11[i, i] + sgn;
          R22[i, i] := R22[i, i] + sgn;
        end for;
        y := Matrices.solve([R11,R[k - 1, k]*R; R[k, k - 1]*R,R22], cat(1, g, w));
        X[:, k - 1] := y[1:n];
        X[:, k] := y[n + 1:2*n];
        k := k - 2;
      end if;
    end while;

// transform X corresponding to the original form
    if not ATisSchur then
      X := U*X*transpose(U);
    end if;

  elseif n == 1 then
    X[1, 1] := C[1, 1]/(A[1, 1]*A[1, 1] + sgn);
  else
    X := fill(0, 0, 0);
  end if;

end discreteLyapunov;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.discreteSylvester</h2>
<p><strong>Return solution of the discrete-time Sylvester equation A*X*B + sgn*X = C</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>X = Matrices.discreteSylvester(A, B, C);
X = Matrices.discreteSylvester(A, B, C, AisHess, BTisSchur, sgn, eps);</code></pre>
</blockquote>
<h4>Description</h4>
<p>Function <strong>discreteSylvester</strong> computes the solution <strong>X</strong> of the discrete-time Sylvester equation</p>
<blockquote>
<pre><code>A*X*B + sgn*X = C.</code></pre>
</blockquote>
<p>where sgn = 1 or sgn = -1. The algorithm applies the Hessenberg-Schur method proposed by Golub et al [1]. For sgn = -1, the discrete Sylvester equation is also known as Stein equation:</p>
<blockquote>
<pre><code>A*X*B - X + Q = 0.</code></pre>
</blockquote>
<p>In a nutshell, the problem is reduced to the corresponding problem</p>
<blockquote>
<pre><code>H*Y*S&#39; + sgn*Y = F.</code></pre>
</blockquote>
<p>with <strong>H</strong>=<strong>U</strong>'*<strong>A</strong>*<strong>U</strong> is the Hessenberg form of <strong>A</strong> and <strong>S</strong>=<strong>V</strong>'*<strong>B</strong>'*<strong>V</strong> is the real Schur form of <strong>B</strong>', <strong>F</strong>=<strong>U</strong>'*<strong>C</strong>*<strong>V</strong> and <strong>Y</strong>=<strong>U</strong>*<strong>X</strong>*<strong>V</strong>' are appropriate transformations of <strong>C</strong> and <strong>X</strong>. This problem is solved sequently by exploiting the specific forms of <strong>S</strong> and <strong>H</strong>. Finally the solution of the original problem is recovered as <strong>X</strong>=<strong>U</strong>'*<strong>Y</strong>*<strong>V</strong>. The boolean inputs &quot;AisHess&quot; and &quot;BTisSchur&quot; indicate to omit one or both of the transformation to Hessenberg form or Schur form repectively in the case that <strong>A</strong> and/or <strong>B</strong> have already Hessenberg form or Schur respectively.</p>
<h4>References</h4>
<pre><code>[1] Golub, G.H., Nash, S. and Van Loan, C.F.
    A Hessenberg-Schur method for the problem AX + XB = C.
    IEEE Transaction on Automatic Control, AC-24, no. 6, pp. 909-913, 1979.</code></pre>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1.0,   2.0,   3.0;
     6.0,   7.0,   8.0;
     9.0,   2.0,   3.0];

B = [7.0,   2.0,   3.0;
     2.0,   1.0,   2.0;
     3.0,   4.0,   1.0];

C = [271.0,   135.0,   147.0;
     923.0,   494.0,   482.0;
     578.0,   383.0,   287.0];

X = discreteSylvester(A, B, C);

results in:
X = [2.0,   3.0,   6.0;
     4.0,   7.0,   1.0;
     5.0,   3.0,   2.0];</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousSylvester">Matrices.continuousSylvester</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.discreteLyapunov">Matrices.discreteLyapunov</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="9%" />
<col width="23%" />
<col width="29%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix A in A*X*B + sgn*X = C</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[:, size(B, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix B in A*X*B + sgn*X = C</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">C[size(A, 2), size(B, 1)]</td>
<td align="left">
</td>
<td align="left">Rectangular matrix C in A*X*B + sgn*X = C</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">AisHess</td>
<td align="left">false</td>
<td align="left">True if A has already Hessenberg form</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">BTisSchur</td>
<td align="left">false</td>
<td align="left">True if B' has already real Schur form</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">sgn</td>
<td align="left">1</td>
<td align="left">Specifies the sign in A*X*B + sgn*X = C</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">Matrices.norm(A, 1)*10*Model...</td>
<td align="left">Tolerance</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="8%" />
<col width="27%" />
<col width="63%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(A, 2), size(B, 1)]</td>
<td align="left">solution of the discrete Sylvester equation A*X*B + sgn*X = C</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function discreteSylvester 
  &quot;Return solution of the discrete-time Sylvester equation A*X*B + sgn*X = C&quot;
  import Modelica.Math.Matrices;

  input Real A[:,size(A, 1)] &quot;Square matrix A in A*X*B + sgn*X = C&quot;;
  input Real B[:,size(B, 1)] &quot;Square matrix B in A*X*B + sgn*X = C&quot;;
  input Real C[size(A, 2),size(B, 1)] 
    &quot;Rectangular matrix C in A*X*B + sgn*X = C&quot;;
  input Boolean AisHess=false &quot;True if A has already Hessenberg form&quot;;
  input Boolean BTisSchur=false &quot;True if B&#39; has already real Schur form&quot;;
  input Integer sgn=1 &quot;Specifies the sign in A*X*B + sgn*X = C&quot;;
  input Real eps=Matrices.norm(A, 1)*10*Modelica.Constants.eps &quot;Tolerance&quot;;

protected 
  Integer n=size(A, 1);
  Integer m=size(B, 1);
  Real H[n,n] &quot;Hessenberg form  of A, i.e., H=U&#39;AU&quot;;
  Real U[n,n] &quot;Transformation matrix U for H=U&#39;AU&quot;;
  Real S[m,m] &quot;RSF form  of B, i.e., S=Z&#39;BZ&quot;;
  Real Z[m,m] &quot;Transformation matrix Z for S=Z&#39;BZ&quot;;
  Real F[n,m] &quot;Appropriate transformation of the right side C, F=U&#39;*C*Z&quot;;

  Real R22[n,n];
  Real R11[n,n];
  Integer k;

  Real w[n];
  Real g[n];
  Real y[2*n];
  Boolean crit;

public 
  output Real X[size(A, 2),size(B, 1)] 
    &quot;solution of the discrete Sylvester equation A*X*B + sgn*X = C&quot;;

algorithm 
  assert(sgn==1 or sgn==-1,&quot;Input sgn in function Math.Matrices.discreteLyapunov() must be 1 or -1, however it is &quot;+String(sgn));
  X := zeros(n, m);
  k := m;

  if n &gt; 1 and m &gt; 1 then
    if AisHess then
      H := A;
      U := identity(n);
      if BTisSchur then
        S := B;
        Z := identity(m);
        F := C;
      else
        (S,Z) := Matrices.realSchur(transpose(B));
        S := transpose(S);
        F := C*Z;
      end if;
    else
      (H,U) := Matrices.hessenberg(A);
      if BTisSchur then
        S := B;
        Z := identity(m);
        F := transpose(U)*C;
      else
        (S,Z) := Matrices.realSchur(transpose(B));
        S := transpose(S);
        F := transpose(U)*C*Z;
      end if;
    end if;

    while k &gt;0 loop

      w := F[:, k] - H*X[:, k + 1:m]*S[k +1:m,k];
      crit := if k &gt; 1 then abs(S[k-1, k]) &lt; eps else false;

      if (k == 1 or crit) then //real eigenvalue in Schur form
        R22 := S[k, k]*H;
        for i in 1:n loop
          R22[i, i] := R22[i, i] + sgn;
        end for;
        X[:, k] := Matrices.solve(R22, w); // solve one column in X for one real eigenvalue
        k := k - 1;
      else // pair of complex eigenvalues, i.e., 2x2 Schur bump
        g := F[:, k-1] - H*X[:, k + 1:m]*S[k+1 :m,k-1];
        R22 := S[k, k]*H;
        R11 := S[k-1, k-1]*H;
        for i in 1:n loop
          R11[i, i] := R11[i, i] + sgn;
          R22[i, i] := R22[i, i] + sgn;
        end for;
        y := Matrices.solve([R11,S[k,  k-1]*H; S[k-1, k]*H,R22], cat(1, g, w));// solve two columns in X for one conjugated complex pole pair
        X[:, k-1] := y[1:n];
        X[:, k] := y[n + 1:2*n];
        k := k - 2;
      end if;
    end while;

// transform X corresponding to the original form
    if not (AisHess and BTisSchur) then
      X := if AisHess then X*transpose(Z) else if BTisSchur then U*X else U*X*transpose(Z);
    end if;

  elseif n == 1 and m == 1 then // simple scalar equation
    X[1, 1] := C[1, 1]/(A[1, 1]*B[1, 1] + sgn);
  else
    X := fill(0, 0, 0);
  end if;

end discreteSylvester;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.discreteRiccati</h2>
<p><strong>Return solution of discrete-time algebraic Riccati equation A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0 (dare)</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>X = Matrices.discreteRiccati(A, B, R, Q);</code></pre>
<blockquote>
<p>(X, alphaReal, alphaImag) = Matrices.discreteRiccati(A, B, R, Q, true);</p>
</blockquote>
</blockquote>
<h4>Description</h4>
<p>Function <strong>discreteRiccati</strong> computes the solution <strong>X</strong> of the discrete-time algebraic Riccati equation</p>
<blockquote>
<pre><code>A&#39;*X*A - X - A&#39;*X*B*inv(R + B&#39;*X*B)*B&#39;*X*A + Q = 0</code></pre>
</blockquote>
<p>using the Schur vector approach proposed by Laub [1].</p>
<p>It is assumed that <strong>Q</strong> is symmetric and positive semidefinite and <strong>R</strong> is symmetric, nonsingular and positive definite, (<strong>A</strong>,<strong>B</strong>) is stabilizable and (<strong>A</strong>,<strong>Q</strong>) is detectable. Using this method, <strong>A</strong> has also to be invertible.</p>
<p><strong>These assumptions are not checked in this function !!!</strong></p>
<p>The assumptions guarantee that the Hamiltonian matrix.</p>
<blockquote>
<pre><code>H = [A + G*T*Q, -G*T; -T*Q, T]</code></pre>
</blockquote>
<p>with</p>
<blockquote>
<pre><code>-T</code></pre>
<blockquote>
<p>T = A</p>
</blockquote>
</blockquote>
<p>and</p>
<blockquote>
<pre><code>-1</code></pre>
<blockquote>
<p>G = B<em>R</em>B'</p>
</blockquote>
</blockquote>
<p>has no eigenvalue on the unit circle and can be put to an ordered real Schur form</p>
<blockquote>
<pre><code>U&#39;*H*U = S = [S11, S12; 0, S22]</code></pre>
</blockquote>
<p>with orthogonal similarity transformation <strong>U</strong>. <strong>S</strong> is ordered in such a way, that <strong>S11</strong> contains the n stable eigenvalues of the closed loop system with system matrix</p>
<blockquote>
<pre><code>-1</code></pre>
<blockquote>
<p>A - B<em>(R + B'</em>X<em>B)</em>B'<em>X</em>A</p>
</blockquote>
</blockquote>
<p>If <strong>U</strong> is partitioned to</p>
<blockquote>
<pre><code>U = [U11, U12; U21, U22]</code></pre>
</blockquote>
<p>according to <strong>S</strong>, the solution <strong>X</strong> can be calculated by</p>
<blockquote>
<pre><code>X*U11 = U21.</code></pre>
</blockquote>
<p>The algorithm calls LAPACK routines <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dgehrd">dgehrd</a> (to compute the upper Hessenberg matrix of <strong>H</strong>), <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dorghr">dorghr</a> (to calculate the orthogonal matrix from the elementary reflectors as returned from dgehrd), <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dhseqr">dhseqr</a> (to put transformed <strong>H</strong> to Schur form and to calculate the eigenvalues of the closed loop system) and <a href="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK.dtrsen">dtrsen</a> (to compute the ordered real Schur form and matrix <strong>U</strong>).</p>
<h4>References</h4>
<pre><code>[1] Laub, A.J.
    A Schur Method for Solving Algebraic Riccati equations.
    IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.</code></pre>
<h4>Example</h4>
<blockquote>
<pre><code>A  = [4.0    3.0]
     -4.5,  -3.5];

B  = [ 1.0;
      -1.0];

R = [1.0];

Q = [9.0, 6.0;
     6.0, 4.0]</code></pre>
<blockquote>
<p>X = discreteRiccati(A, B, R, Q);</p>
<blockquote>
<p>results in:</p>
</blockquote>
<dl>
<dt>X = [14.5623, 9.7082;</dt>
<dd><p>9.7082, 6.4721];</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.continuousRiccati">Matrices.continuousRiccati</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="11%" />
<col width="29%" />
<col width="24%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, size(A, 1)]</td>
<td align="left">
</td>
<td align="left">Square matrix A in DARE</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">B[size(A, 1), :]</td>
<td align="left">
</td>
<td align="left">Matrix B in DARE</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">R[size(B, 2), size(B, 2)]</td>
<td align="left">identity(size(B, 2))</td>
<td align="left">Matrix R in DARE</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">Q[size(A, 1), size(A, 1)]</td>
<td align="left">identity(size(A, 1))</td>
<td align="left">Matrix Q in DARE</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">refine</td>
<td align="left">false</td>
<td align="left">True for subsequent refinement</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="8%" />
<col width="27%" />
<col width="63%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X[size(A, 1), size(A, 2)]</td>
<td align="left">orthogonal matrix of the Schur vectors associated to ordered rsf</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">alphaReal[size(H, 1)]</td>
<td align="left">Real part of eigenvalue=alphaReal+i*alphaImag</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">alphaImag[size(H, 1)]</td>
<td align="left">Imaginary part of eigenvalue=(alphaReal+i*alphaImag</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function discreteRiccati 
  &quot;Return solution of discrete-time algebraic Riccati equation A&#39;*X*A - X - A&#39;*X*B*inv(R + B&#39;*X*B)*B&#39;*X*A + Q = 0 (dare)&quot;

  import Modelica.Math.Matrices;
  input Real A[:,size(A, 1)] &quot;Square matrix A in DARE&quot;;
  input Real B[size(A, 1),:] &quot;Matrix B in DARE&quot;;
  input Real R[size(B, 2),size(B, 2)]=identity(size(B, 2)) &quot;Matrix R in DARE&quot;;
  input Real Q[size(A, 1),size(A, 1)]=identity(size(A, 1)) &quot;Matrix Q in DARE&quot;;
  input Boolean refine=false &quot;True for subsequent refinement&quot;;

protected 
  Integer n=size(A, 1);
  Real G[size(A, 1),size(A, 1)]=B*Matrices.solve2(R, transpose(B));
  Real AT[n,n]=transpose(A);
  Real LU[n,n];
  Integer p[n];
  Real H[2*n,2*n];
  Real H11[n,n];
  Real H12[n,n];
  Real H21[n,n];
  Real H22[n,n];
  Real H_RSF[2*n,2*n];
  Real Z[size(H, 1),size(H, 2)];
  Real Z11[size(A, 1),size(A, 2)];
  Real Z21[size(A, 1),size(A, 2)];

  Integer info;

public 
  output Real X[size(A, 1),size(A, 2)] 
    &quot;orthogonal matrix of the Schur vectors associated to ordered rsf&quot;;
  output Real alphaReal[size(H, 1)] 
    &quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;;
  output Real alphaImag[size(H, 1)] 
    &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;;
algorithm 
  (LU,p) := Modelica.Math.Matrices.LU(AT);
  H21 := Modelica.Math.Matrices.LU_solve2(
      LU,
      p,
      -Q);
  H22 := Modelica.Math.Matrices.LU_solve2(
      LU,
      p,
      identity(n));
  (LU,p) := Modelica.Math.Matrices.LU(A);
  H12 := Modelica.Math.Matrices.LU_solve2(
      LU,
      p,
      -G);
  H12 := transpose(H12);
  H11 := A - H12*Q;
  H := [H11,H12; H21,H22];
  (H_RSF,Z,alphaReal,alphaImag) := Modelica.Math.Matrices.realSchur(H);
                                                             // put H to Schur form
  (H_RSF,Z,alphaReal,alphaImag) := Matrices.Utilities.reorderRSF(
      H_RSF,
      Z,
      alphaReal,
      alphaImag,
      false);  // ordered Schur form
  Z11 := Z[1:n, 1:n];
  Z21 := Z[n + 1:2*n, 1:n];
  if size(Z11, 1) &gt; 0 then
//  X := transpose(Matrices.solve2(transpose(Z11), transpose(Z21)));
    (X,info) := Matrices.LAPACK.dgesvx(Z11, transpose(Z21));//function does not need to transpose Z11 as solve2 does
    X := transpose(X);
    assert(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LAPACK.dgesvx\&quot; is not possible, because the system has either
no or infinitely many solutions (input A is singular).&quot;);

    if refine then
      X := Modelica.Math.Matrices.Utilities.discreteRiccatiIterative(
          A,
          B,
          R,
          Q,
          X);
    end if;
  else
    X := fill(
        0,
        size(Z21, 1),
        size(Z11, 1));
  end if;

end discreteRiccati;</code></pre>
<hr />
<h2><img src="Modelica.Math.Matrices.sortI.png" alt="image110" /> <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.sort</h2>
<p><strong>Sort the rows or columns of a matrix in ascending or descending order</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>sorted_M = Matrices.sort(M);</code></pre>
<blockquote>
<p>(sorted_M, indices) = Matrices.sort(M, sortRows=true, ascending=true);</p>
</blockquote>
</blockquote>
<h4>Description</h4>
<p>Function <strong>sort</strong>(..) sorts the rows of a Real matrix M in ascending order and returns the result in sorted_M. If the optional argument &quot;sortRows&quot; is <strong>false</strong>, the columns of the matrix are sorted. If the optional argument &quot;ascending&quot; is <strong>false</strong>, the rows or columns are sorted in descending order. In the optional second output argument, the indices of the sorted rows or columns with respect to the original matrix are given, such that</p>
<pre><code>sorted_M = if sortedRow then M[indices,:] else M[:,indices];</code></pre>
<h4>Example</h4>
<blockquote>
<pre><code>(M2, i2) := Matrices.sort([2, 1,  0;
                           2, 0, -1]);
     -&gt; M2 = [2, 0, -1;
              2, 1, 0 ];
        i2 = {2,1};</code></pre>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="14%" />
<col width="12%" />
<col width="60%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">M[:, :]</td>
<td align="left">
</td>
<td align="left">Matrix to be sorted</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">sortRows</td>
<td align="left">true</td>
<td align="left">= true if rows are sorted, otherwise columns</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">ascending</td>
<td align="left">true</td>
<td align="left">= true if ascending order, otherwise descending order</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="9%" />
<col width="42%" />
<col width="48%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">sorted_M[size(M, 1), size(M, 2)]</td>
<td align="left">Sorted matrix</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">indices[if sortRows then size(M, 1) else size(M, 2)]</td>
<td align="left">sorted_M = if sortRows then M[indices,:] else M[:,indices]</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function sort 
  &quot;Sort the rows or columns of a matrix in ascending or descending order&quot;
  extends Modelica.Icons.Function;
  input Real M[:,:] &quot;Matrix to be sorted&quot;;
  input Boolean sortRows = true &quot;= true if rows are sorted, otherwise columns&quot;;
  input Boolean ascending = true 
    &quot;= true if ascending order, otherwise descending order&quot;;
  output Real sorted_M[size(M,1), size(M,2)] = M &quot;Sorted matrix&quot;;
  output Integer indices[if sortRows then size(M,1) else size(M,2)] 
    &quot;sorted_M = if sortRows then M[indices,:] else M[:,indices]&quot;;

  /* shellsort algorithm; should be improved later */
protected 
  Integer gap;
  Integer i;
  Integer j;
  Real wM2[size(M,2)];
  Integer wi;
  Integer nM1 = size(M,1);
  Boolean swap;
  Real sorted_MT[size(M,2), size(M,1)];

encapsulated function greater &quot;Compare whether vector v1 &gt; v2&quot;
    import Modelica;
  extends Modelica.Icons.Function;
    import Modelica.Utilities.Types.Compare;
  input Real v1[:];
  input Real v2[size(v1,1)];
  output Boolean result;
  protected 
  Integer n = size(v1,1);
  Integer i=1;
algorithm 
  result := false;
  while i &lt;= n loop
     if v1[i] &gt; v2[i] then
        result := true;
        i := n;
     elseif v1[i] &lt; v2[i] then
        i := n;
     end if;
     i := i+1;
  end while;
end greater;

encapsulated function less &quot;Compare whether vector v1 &lt; v2&quot;
    import Modelica;
  extends Modelica.Icons.Function;
    import Modelica.Utilities.Types.Compare;
  input Real v1[:];
  input Real v2[size(v1,1)];
  output Boolean result;
  protected 
  Integer n = size(v1,1);
  Integer i=1;
algorithm 
  result := false;
  while i &lt;= n loop
     if v1[i] &lt; v2[i] then
        result := true;
        i := n;
     elseif v1[i] &gt; v2[i] then
        i := n;
     end if;
     i := i+1;
  end while;
end less;
algorithm 
  if not sortRows then
      (sorted_MT,indices) := sort(transpose(M), ascending=ascending);
     sorted_M :=transpose(sorted_MT);
  else
     indices :=1:size(M, 1);
     gap := div(nM1,2);
     while gap &gt; 0 loop
        i := gap;
        while i &lt; nM1 loop
           j := i-gap;
           if j&gt;=0 then
              if ascending then
                 swap := greater(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
              else
                 swap := less(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
              end if;
           else
              swap := false;
           end if;

           while swap loop
              wM2 := sorted_M[j+1,:];
              wi := indices[j+1];
              sorted_M[j+1,:] := sorted_M[j+gap+1,:];
              sorted_M[j+gap+1,:] := wM2;
              indices[j+1] := indices[j+gap+1];
              indices[j+gap+1] := wi;
              j := j - gap;
              if j &gt;= 0 then
                 if ascending then
                    swap := greater(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
                 else
                    swap := less(sorted_M[j+1,:], sorted_M[j+gap+1,:]);
                 end if;
              else
                 swap := false;
              end if;
           end while;
           i := i + 1;
        end while;
        gap := div(gap,2);
     end while;
  end if;
end sort;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.flipLeftRight</h2>
<p><strong>Flip the columns of a matrix in left/right direction</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>A_flr = Matrices.flipLeftRight(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>Function <strong>flipLeftRight</strong> computes from matrix <strong>A</strong> a matrix <strong>A_flr</strong> with flipped columns, i.e., <strong>A_flr</strong>[:,i]=<strong>A</strong>[:,n-i+1], i=1,..., n.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2,  3;
     3, 4,  5;
    -1, 2, -3];

A_flr = flipLeftRight(A);

results in:

A_flr = [3, 2,  1;
         5, 4,  3;
        -3, 2, -1]</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.flipUpDown">Matrices.flipUpDown</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="16%" />
<col width="16%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Matrix to be flipped</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="47%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">Aflip[size(A, 1), size(A, 2)]</td>
<td align="left">Flipped matrix</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function flipLeftRight 
  &quot;Flip the columns of a matrix in left/right direction&quot;

  input Real A[:,:] &quot;Matrix to be flipped&quot;;
  output Real Aflip[size(A, 1),size(A, 2)] &quot;Flipped matrix&quot;;
algorithm 
  Aflip := A[:,{i for i in size(A,2):-1:1}];

end flipLeftRight;</code></pre>
<hr />
<h2><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Modelica.Math.Matrices</a>.flipUpDown</h2>
<p><strong>Flip the rows of a matrix in up/down direction</strong></p>
<h3>Information</h3>
<p>::</p>
<h4>Syntax</h4>
<blockquote>
<pre><code>A_fud = Matrices.flipUpDown(A);</code></pre>
</blockquote>
<h4>Description</h4>
<p>Function <strong>flipUpDown</strong> computes from matrix <strong>A</strong> a matrix <strong>A_fud</strong> with flipped rows, i.e., <strong>A_fud</strong>[i,:]=<strong>A</strong>[n-i+1,:], i=1,..., n.</p>
<h4>Example</h4>
<blockquote>
<pre><code>A = [1, 2,  3;
     3, 4,  5;
    -1, 2, -3];

A_fud = flipUpDown(A);

results in:

A_fud  = [-1, 2, -3;
           3, 4,  5;
           1, 2,  3]</code></pre>
</blockquote>
<h4>See also</h4>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.flipLeftRight">Matrices.flipLeftRight</a></p>
<p>::</p>
<h3>Inputs</h3>
<table>
<col width="12%" />
<col width="16%" />
<col width="16%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">A[:, :]</td>
<td align="left">
</td>
<td align="left">Matrix to be flipped</td>
</tr>
</tbody>
</table>
<h3>Outputs</h3>
<table>
<col width="12%" />
<col width="47%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">Aflip[size(A, 1), size(A, 2)]</td>
<td align="left">Flipped matrix</td>
</tr>
</tbody>
</table>
<h3>Modelica definition</h3>
<pre><code>function flipUpDown &quot;Flip the rows of a matrix in up/down direction&quot;

  input Real A[:,:] &quot;Matrix to be flipped&quot;;
  output Real Aflip[size(A, 1),size(A, 2)] &quot;Flipped matrix&quot;;
algorithm 
  Aflip := A[{i for i in size(A,1):-1:1},:];

end flipUpDown;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:31:48 2010.</p>
</blockquote>
</body>
</html>
