<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Electrical.Spice3.Internal.Mos2</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Electrical.Spice3.Internal.Mos2</h1>
</div>
<h1 id="modelica.electrical.spice3.internal.mos2"><a href="Modelica_Electrical_Spice3_Internal.html#Modelica.Electrical.Spice3.Internal">Modelica.Electrical.Spice3.Internal</a>.Mos2</h1>
<p><strong>Records and functions for Mosfets level 2</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>This package Mos2 contains functions and records with data of the mosfet model level 2.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="80%" />
<col width="19%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineParamsS.png" alt="image7" /> <a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineParams">Mos2ModelLineParams</a></td>
<td align="left">Record for Mosfet model line parameters (for level 2)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineParamsS.png" alt="image8" /> <a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineVariables">Mos2ModelLineVariables</a></td>
<td align="left">Record for Mosfet model line variables (for level 2)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineParamsS.png" alt="image9" /> <a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2Calc">Mos2Calc</a></td>
<td align="left">Further mosfet variables (for level 2)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Electrical.Spice3.Internal.Mos2.mos2ModelLineParamsInitEquationsS.png" alt="image10" /> <a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.mos2ModelLineParamsInitEquations">mos2ModelLineParamsInitEquations</a></td>
<td align="left">Initial precalculation</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Electrical.Spice3.Internal.Mos2.mos2ModelLineParamsInitEquationsS.png" alt="image11" /> <a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.drainCur">drainCur</a></td>
<td align="left">Drain current calculation</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Electrical.Spice3.Internal.Mos2.mos2ModelLineParamsInitEquationsS.png" alt="image12" /> <a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.mos2RenameParameters">mos2RenameParameters</a></td>
<td align="left">Parameter renaming to internal names</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Electrical.Spice3.Internal.Mos2.mos2ModelLineParamsInitEquationsS.png" alt="image13" /> <a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.mos2RenameParametersDev">mos2RenameParametersDev</a></td>
<td align="left">Device parameter renaming to internal names</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="modelica.electrical.spice3.internal.mos2.mos2modellineparams"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2">Modelica.Electrical.Spice3.Internal.Mos2</a>.Mos2ModelLineParams</h1>
<p><strong>Record for Mosfet model line parameters (for level 2)</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>This record Mos1ModelLineParams contains the model line parameters that are used for the mosfet transistors level 2 in SPICE3.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Electrical_Spice3_Internal_Mos.html#Modelica.Electrical.Spice3.Internal.Mos.MosModelLineParams">Mos.MosModelLineParams</a> (Record for Mosfet model line parameters (for level 1, 2, 3 and 6)).</p>
<h2 id="parameters">Parameters</h2>
<table>
<col width="55%" />
<col width="15%" />
<col width="4%" />
<col width="24%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_jctSatCurDensity.start</td>
<td align="left">0.0</td>
<td align="left">JS, Bulk jct. sat. current density, input - use tSatCurDens</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Resistance">Resistance</a></td>
<td align="left">m_sheetResistance.start</td>
<td align="left">0.0</td>
<td align="left">RSH, Sheet resistance [Ohm]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_bulkJctPotential.start</td>
<td align="left">0.8</td>
<td align="left">PB, Bulk junction potential, input - use tBulkPot</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_bulkJctBotGradingCoeff.start</td>
<td align="left">0.5</td>
<td align="left">MJ, Bottom grading coefficient</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_bulkJctSideGradingCoeff.start</td>
<td align="left">0.33</td>
<td align="left">MJSW, Side grading coefficient</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_oxideThickness.start</td>
<td align="left">1.0e-7</td>
<td align="left">TOX, Oxide thickness unit: micron</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_gateSourceOverlapCapFactor.start</td>
<td align="left">0.0</td>
<td align="left">CGS0, Gate-source overlap cap</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_gateDrainOverlapCapFactor.start</td>
<td align="left">0.0</td>
<td align="left">CGD0, Gate-drain overlap cap</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_gateBulkOverlapCapFactor.start</td>
<td align="left">0.0</td>
<td align="left">CGB0, Gate-bulk overlap cap</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_fNcoef.start</td>
<td align="left">0.0</td>
<td align="left">KF, Flicker noise coefficient</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_fNexp.start</td>
<td align="left">1.0</td>
<td align="left">AF, Flicker noise exponent</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_oxideCapFactor.start</td>
<td align="left">0.0</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_vt0.start</td>
<td align="left">0.0</td>
<td align="left">VTO, Threshold voltage [V]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_capBD.start</td>
<td align="left">0.0</td>
<td align="left">CBD, B-D junction capacitance [F]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_capBS.start</td>
<td align="left">0.0</td>
<td align="left">CBS, B-S junction capacitance [F]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.CapacitancePerArea">CapacitancePerArea</a></td>
<td align="left">m_bulkCapFactor.start</td>
<td align="left">0.0</td>
<td align="left">CJ, Bottom junction cap per area [F/m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Permittivity">Permittivity</a></td>
<td align="left">m_sideWallCapFactor.start</td>
<td align="left">0.0</td>
<td align="left">CJSW, Side grading coefficient [F/m]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_fwdCapDepCoeff.start</td>
<td align="left">0.5</td>
<td align="left">FC, Forward bias jct. fit parm.</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_phi.start</td>
<td align="left">0.6</td>
<td align="left">PHI, Surface potential [V]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_gamma.start</td>
<td align="left">0.0</td>
<td align="left">GAMMA, Bulk threshold parameter [V]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.InversePotential">InversePotential</a></td>
<td align="left">m_lambda.start</td>
<td align="left">0.0</td>
<td align="left">Channel-length modulation [1/V]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_substrateDoping.start</td>
<td align="left">0.0</td>
<td align="left">NSUB, Substrate doping</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_gateType.start</td>
<td align="left">1.0</td>
<td align="left">TPG, Gate type</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits_Conversions_NonSIunits.html#Modelica.SIunits.Conversions.NonSIunits.PerArea_cm">PerArea_cm</a></td>
<td align="left">m_surfaceStateDensity.start</td>
<td align="left">0.0</td>
<td align="left">NSS, Gate type [1/cm2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits_Conversions_NonSIunits.html#Modelica.SIunits.Conversions.NonSIunits.Area_cmPerVoltageSecond">Area_cmPerVoltageSecond</a></td>
<td align="left">m_surfaceMobility.start</td>
<td align="left">600.0</td>
<td align="left">UO, Surface mobility [cm2/(V.s)]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">m_latDiff.start</td>
<td align="left">0.0</td>
<td align="left">LD, Lateral diffusion [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Current">Current</a></td>
<td align="left">m_jctSatCur.start</td>
<td align="left">1.0e-14</td>
<td align="left">IS, Bulk junction sat. current [A]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Resistance">Resistance</a></td>
<td align="left">m_drainResistance.start</td>
<td align="left">0</td>
<td align="left">RD, Drain ohmic resistance [Ohm]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Resistance">Resistance</a></td>
<td align="left">m_sourceResistance.start</td>
<td align="left">0</td>
<td align="left">RS, Source ohmic resistance [Ohm]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Transconductance">Transconductance</a></td>
<td align="left">m_transconductance.start</td>
<td align="left">2.0e-5</td>
<td align="left">input - use tTransconductance [A/V2]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>record Mos2ModelLineParams 
  &quot;Record for Mosfet model line parameters (for level 2)&quot;
  extends Mos.MosModelLineParams(
    m_lambda(start=0.0),
    m_transconductance(start=2.0e-5),
    m_bulkJctSideGradingCoeff(start=0.33),
    m_oxideThickness(start=1.0e-7));

  Real m_narrowFactor( start = 0.0) &quot;DELTA, Width effect on threshold&quot;;
  Real m_critFieldExp( start = 0.0) &quot;UEXP, Crit. field exp for mob. deg&quot;;
  Real m_critField( start = 1.0e4) &quot;UCRIT, Crit. field for mob. degradation&quot;;
  Real m_maxDriftVel( start = 0.0) &quot;VMAX, Maximum carrier drift velocity&quot;;
  Real m_junctionDepth( start = 0.0) &quot;XJ, Junction depth&quot;;
  Modelica.SIunits.Charge m_channelCharge( start = 1.0) 
    &quot;NEFF, Total channel charge coeff&quot;;
  Real m_fastSurfaceStateDensity( start = 0.0) 
    &quot;NFS, Fast surface state density&quot;;

end Mos2ModelLineParams;</code></pre>
<hr />
<h1 id="modelica.electrical.spice3.internal.mos2.mos2modellinevariables"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2">Modelica.Electrical.Spice3.Internal.Mos2</a>.Mos2ModelLineVariables</h1>
<p><strong>Record for Mosfet model line variables (for level 2)</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>This record MosModelLineVariables contains the model line variables that are used for the mosfet transistors level 2 SPICE3.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Electrical_Spice3_Internal_Mos.html#Modelica.Electrical.Spice3.Internal.Mos.MosModelLineVariables">Mos.MosModelLineVariables</a> (Record for Mosfet model line variables (for level 1)).</p>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>record Mos2ModelLineVariables 
  &quot;Record for Mosfet model line variables (for level 2)&quot;
  extends Mos.MosModelLineVariables;

  Real m_bulkCapFactor;
  Real m_substrateDoping;
  Real m_xd;

end Mos2ModelLineVariables;</code></pre>
<hr />
<h1 id="modelica.electrical.spice3.internal.mos2.mos2calc"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2">Modelica.Electrical.Spice3.Internal.Mos2</a>.Mos2Calc</h1>
<p><strong>Further mosfet variables (for level 2)</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>This record Mos1Calc contains further mosfet variables (for level 2) that are needed for the calculations.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Electrical_Spice3_Internal_Mos.html#Modelica.Electrical.Spice3.Internal.Mos.MosCalc">Mos.MosCalc</a> (Further mosfet variables (for level 1, 2, 3 and 6)).</p>
<h2 id="parameters-1">Parameters</h2>
<table>
<col width="58%" />
<col width="21%" />
<col width="8%" />
<col width="11%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">m_mode.start</td>
<td align="left">1</td>
<td align="left">Mode</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Transconductance">Transconductance</a></td>
<td align="left">m_tTransconductance.start</td>
<td align="left">0.</td>
<td align="left">[A/V2]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_tSurfMob.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_tPhi.start</td>
<td align="left">0.7</td>
<td align="left">[V]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_tVto.start</td>
<td align="left">1.</td>
<td align="left">[V]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_tSatCurDens.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Current">Current</a></td>
<td align="left">m_tDrainSatCur.start</td>
<td align="left">0.</td>
<td align="left">[A]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Current">Current</a></td>
<td align="left">m_tSourceSatCur.start</td>
<td align="left">0.</td>
<td align="left">[A]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_tCBDb.start</td>
<td align="left">0.</td>
<td align="left">[F]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_tCBDs.start</td>
<td align="left">0.</td>
<td align="left">[F]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_tCBSb.start</td>
<td align="left">0.</td>
<td align="left">[F]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_tCBSs.start</td>
<td align="left">0.</td>
<td align="left">[F]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_tCj.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_tCjsw.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_tBulkPot.start</td>
<td align="left">0.7</td>
<td align="left">[V]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_tDepCap.start</td>
<td align="left">0.35</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_tVbi.start</td>
<td align="left">1.</td>
<td align="left">[V]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_VBScrit.start</td>
<td align="left">0.7</td>
<td align="left">[V]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">m_VBDcrit.start</td>
<td align="left">0.7</td>
<td align="left">[V]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_f1b.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_f2b.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_f3b.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_f1s.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_f2s.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">m_f3s.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">m_dVt.start</td>
<td align="left">0.</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_capgd.start</td>
<td align="left">0.</td>
<td align="left">[F]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_capgs.start</td>
<td align="left">0.</td>
<td align="left">[F]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Capacitance">Capacitance</a></td>
<td align="left">m_capgb.start</td>
<td align="left">0.</td>
<td align="left">[F]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Charge">Charge</a></td>
<td align="left">m_qgs.start</td>
<td align="left">0.</td>
<td align="left">[C]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Charge">Charge</a></td>
<td align="left">m_qgd.start</td>
<td align="left">0.</td>
<td align="left">[C]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Charge">Charge</a></td>
<td align="left">m_qgb.start</td>
<td align="left">0.</td>
<td align="left">[C]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>record Mos2Calc &quot;Further mosfet variables (for level 2)&quot;
  extends Mos.MosCalc;

end Mos2Calc;</code></pre>
<hr />
<h1 id="modelica.electrical.spice3.internal.mos2.mos2modellineparamsinitequations"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2">Modelica.Electrical.Spice3.Internal.Mos2</a>.mos2ModelLineParamsInitEquations</h1>
<p><strong>Initial precalculation</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>This function mos1ModelLineParamsInitEquation does the initial precalculation of the mosfet model line parameters for level 2.</p>
<p>::</p>
<h2 id="inputs">Inputs</h2>
<table>
<col width="64%" />
<col width="7%" />
<col width="5%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineParams">Mos2ModelLineParams</a></td>
<td align="left">in_p</td>
<td align="left">
</td>
<td align="left">Input record model line parameters for MOS2</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal.html#Modelica.Electrical.Spice3.Internal.SpiceConstants">SpiceConstants</a></td>
<td align="left">in_C</td>
<td align="left">
</td>
<td align="left">Spice constants</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">in_m_type</td>
<td align="left">
</td>
<td align="left">Type of MOS transistor</td>
</tr>
</tbody>
</table>
<h2 id="outputs">Outputs</h2>
<table>
<col width="72%" />
<col width="5%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineVariables">Mos2ModelLineVariables</a></td>
<td align="left">out_v</td>
<td align="left">Output record with model line variables</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>function mos2ModelLineParamsInitEquations &quot;Initial precalculation&quot;

  input Mos2ModelLineParams in_p &quot;Input record model line parameters for MOS2&quot;;
  input SpiceConstants in_C &quot;Spice constants&quot;;
  input Integer in_m_type &quot;Type of MOS transistor&quot;;

  output Mos2ModelLineVariables out_v &quot;Output record with model line variables&quot;;

protected 
  Modelica.SIunits.Voltage vtnom;
  Modelica.SIunits.Voltage fermis;
  Real fermig;
  Real wkfng;
  Real wkfngs;
  Real egfet1;
  Real vfb;

algorithm 
  out_v.m_oxideCapFactor   := in_p.m_oxideCapFactor;
  out_v.m_transconductance := in_p.m_transconductance;
  out_v.m_phi              := in_p.m_phi;
  out_v.m_gamma            := in_p.m_gamma;
  out_v.m_vt0              := in_p.m_vt0;
  out_v.m_substrateDoping  := in_p.m_substrateDoping;
  out_v.m_bulkCapFactor    := in_p.m_bulkCapFactor;

  vtnom                  := in_p.m_tnom * in_C.CONSTKoverQ;
  egfet1                 := 1.16 - (7.02e-4 * in_p.m_tnom * in_p.m_tnom) / (in_p.m_tnom + 1108);
  out_v.m_oxideCapFactor := 3.9 * 8.854214871e-12 / in_p.m_oxideThickness;

  if ( not (in_p.m_transconductanceIsGiven &gt; 0.5)) then
    out_v.m_transconductance := in_p.m_surfaceMobility * 1.0e-4 * out_v.m_oxideCapFactor;
  end if;

  if  (in_p.m_substrateDopingIsGiven &gt; 0.5) then
    if ( out_v.m_substrateDoping * 1.0e6 &gt; 1.45e16) then
      if ( not (in_p.m_phiIsGiven &gt; 0.5)) then
        out_v.m_phi := 2 * vtnom * Modelica.Math.log( out_v.m_substrateDoping * 1.0e6 / 1.45e16);
        out_v.m_phi := max( 0.1, out_v.m_phi);
      end if;
      fermis := in_m_type * 0.5 * out_v.m_phi;
      wkfng  := 3.2;
      if ( in_p.m_gateType &lt;&gt; 0) then
        fermig := in_m_type * in_p.m_gateType * 0.5 * egfet1;
        wkfng  := 3.25 + 0.5 * egfet1 - fermig;
      end if;
      wkfngs := wkfng - (3.25 + 0.5 * egfet1 + fermis);
      if ( not (in_p.m_gammaIsGiven &gt; 0.5)) then
        out_v.m_gamma := sqrt(2.0 * 11.70 * 8.854214871e-12 * in_C.CHARGE * out_v.m_substrateDoping
                           * 1.0e6) / out_v.m_oxideCapFactor;
      end if;
      if ( not (in_p.m_vtOIsGiven &gt; 0.5)) then
        vfb         := wkfngs - in_p.m_surfaceStateDensity * 1.0e4 * in_C.CHARGE / out_v.m_oxideCapFactor;
        out_v.m_vt0 := vfb + in_m_type * (out_v.m_gamma * sqrt(out_v.m_phi)+ out_v.m_phi);
      else
        vfb        := out_v.m_vt0 - in_m_type * (out_v.m_gamma * sqrt(out_v.m_phi) + out_v.m_phi);
      end if;
      out_v.m_xd := sqrt( (in_C.EPSSIL + in_C.EPSSIL) / (in_C.CHARGE * out_v.m_substrateDoping * 1.0e6));
    else
      out_v.m_substrateDoping := 0.0;
    end if;
  end if;

  if ( not (in_p.m_bulkCapFactorIsGiven &gt; 0.5)) then
    out_v.m_bulkCapFactor := sqrt( in_C.EPSSIL * in_C.CHARGE * out_v.m_substrateDoping
                              * 1e6 /(2 * in_p.m_bulkJctPotential));
  end if;

end mos2ModelLineParamsInitEquations;</code></pre>
<hr />
<h1 id="modelica.electrical.spice3.internal.mos2.draincur"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2">Modelica.Electrical.Spice3.Internal.Mos2</a>.drainCur</h1>
<p><strong>Drain current calculation</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p>This function drainCur calculates the main currents that flows from drain node to source node (level 2).</p>
<p>::</p>
<h2 id="inputs-1">Inputs</h2>
<table>
<col width="65%" />
<col width="7%" />
<col width="5%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">vbs</td>
<td align="left">
</td>
<td align="left">[V]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">vgs</td>
<td align="left">
</td>
<td align="left">[V]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Voltage">Voltage</a></td>
<td align="left">vds</td>
<td align="left">
</td>
<td align="left">[V]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mosfet.html#Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet">Mosfet</a></td>
<td align="left">in_m</td>
<td align="left">
</td>
<td align="left">Record mosfet</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2Calc">Mos2Calc</a></td>
<td align="left">in_c</td>
<td align="left">
</td>
<td align="left">Input record Mos2Calc</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineParams">Mos2ModelLineParams</a></td>
<td align="left">in_p</td>
<td align="left">
</td>
<td align="left">Input record model line parameters for MOS2</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal.html#Modelica.Electrical.Spice3.Internal.SpiceConstants">SpiceConstants</a></td>
<td align="left">in_C</td>
<td align="left">
</td>
<td align="left">Spice constants</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineVariables">Mos2ModelLineVariables</a></td>
<td align="left">in_vp</td>
<td align="left">
</td>
<td align="left">Input record model line variables</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">in_m_type</td>
<td align="left">
</td>
<td align="left">Type of MOS transistor</td>
</tr>
</tbody>
</table>
<h2 id="outputs-1">Outputs</h2>
<table>
<col width="75%" />
<col width="7%" />
<col width="17%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2Calc">Mos2Calc</a></td>
<td align="left">out_c</td>
<td align="left">Output record Mos2Calc</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>function drainCur &quot;Drain current calculation&quot;

   input Modelica.SIunits.Voltage vbs;
   input Modelica.SIunits.Voltage vgs;
   input Modelica.SIunits.Voltage vds;

   input Mosfet.Mosfet in_m &quot;Record mosfet&quot;;
   input Mos2Calc in_c &quot;Input record Mos2Calc&quot;;
   input Mos2ModelLineParams in_p &quot;Input record model line parameters for MOS2&quot;;
   input SpiceConstants in_C &quot;Spice constants&quot;;
   input Mos2ModelLineVariables in_vp &quot;Input record model line variables&quot;;
   input Integer in_m_type &quot;Type of MOS transistor&quot;;

   output Mos2Calc out_c &quot;Output record Mos2Calc&quot;;

protected 
  Real vt;      // K * T / Q
  Real beta1;
  Real dsrgdb;
  Real d2sdb2;
  Real sphi = 0.0;
  Real sphi3 = 1.0;    // square root of phi
  Real barg;
  Real sarg;
  Real bsarg = 0.0;
  Real sarg3;
  Real d2bdb2;
  Real factor;
  Real dbrgdb;
  Real eta;
  Real vbin;
  Real vth;
  Real dgddb2;
  Real dgddvb;
  Real dgdvds;
  Real gamasd;
  Real gammad;
  Real xn =   1.0;
  Real argg = 0.0;
  Real vgst;
  Real vgsx;
  Real dgdvbs;
  Real body;
  Real bodys = 0.0;
  Real gdbdv;
  Real dodvbs;
  Real dodvds = 0.0;
  Real dxndvd = 0.0;
  Real dxndvb = 0.0;
  Real dudvgs;
  Real dudvds;
  Real dudvbs;
  Real ufact;
  Real ueff;
  Real dsdvgs;
  Real dsdvbs;
  Real dbsrdb;
  Real gdbdvs = 0.0;
  Real dldvgs;
  Real dldvds;
  Real dldvbs;
  Real clfact;
  Real xleff;
  Real deltal;
  Real xwb;
  Real xld;
  Real xlamda = in_p.m_lambda;
  Real phiMinVbs;
  Real tmp;

  Real argss;
  Real argsd;
  Real args = 0.0;
  Real argd = 0.0;
  Real argxs = 0.0;
  Real argxd = 0.0;
  Real dbargs;
  Real dbargd;
  Real dbxws;
  Real dbxwd;
  Real xwd;
  Real xws;
  Real daddb2;
  Real dasdb2;
  Real ddxwd;
  Real cfs;
  Real cdonco;
  Real argv;
  Real gammd2;
  Real arg;
  Real y3;
  Real xvalid = 0.0;
  Real[4] sig1;
  Real[4] sig2;
  Real[4] a4;
  Real[4] b4;
  Real[8] x4;
  Real[8] poly4;
  Real delta4;
  Integer j;
  Integer iknt = 0;
  Integer i;
  Integer jknt = 0;
  Real v1;
  Real v2;
  Real xv;
  Real a1;
  Real b1;
  Real c1;
  Real d1;
  Real b2;
  Real r1;
  Real s1;
  Real s2;
  Real p1;
  Real p0;
  Real p2;
  Real a3;
  Real b3;
  Real sargv;
  Real dldsat;
  Real xlfact;
  Real xdv;
  Real xlv;
  Real vqchan;
  Real dqdsat;
  Real vl;
  Real dfunds;
  Real dfundg;
  Real dfundb;
  Real xls;
  Real dfact;
  Real vdson;
  Real cdson;
  Real gdson;
  Real didvds;
  Real gmw;
  Real gbson;
  Real expg;

algorithm 
   out_c := in_c;

  vt := in_C.CONSTKoverQ * in_C.REFTEMP;

  phiMinVbs := out_c.m_tPhi - vbs;
  if ( vbs &lt;= 0.0) then
    sarg   := sqrt( phiMinVbs);
    dsrgdb := -0.5 / sarg;
    d2sdb2 := 0.5 * dsrgdb / phiMinVbs;
  else
    sphi   :=sqrt(out_c.m_tPhi);
    sphi3  :=out_c.m_tPhi*sphi;
    sarg   :=sphi/(1.0 + 0.5*vbs/out_c.m_tPhi);
    tmp    :=sarg/sphi3;
    dsrgdb :=-0.5*sarg*tmp;
    d2sdb2 :=-dsrgdb*tmp;
  end if;

  if ( (vds-vbs) &gt;= 0) then
    barg   := sqrt( phiMinVbs + vds);
    dbrgdb := -0.5 / barg;
    d2bdb2 := 0.5 * dbrgdb / (phiMinVbs + vds);
  else
    barg   := sphi / (1.0 + 0.5 * (vbs - vds) / out_c.m_tPhi);
    tmp    := barg / sphi3;
    dbrgdb := -0.5 * barg * tmp;
    d2bdb2 := -dbrgdb * tmp;
  end if;

  factor := 0.125 * in_p.m_narrowFactor * 2.0 * Modelica.Constants.pi*in_C.EPSSIL / out_c.m_capOx * out_c.m_lEff;

  eta    := 1.0 + factor;
  vbin   := out_c.m_tVbi * in_m_type + factor * phiMinVbs;
  if ( (in_vp.m_gamma &gt; 0.0) or (in_vp.m_substrateDoping &gt; 0.0)) then
    xwd := in_vp.m_xd * barg;
    xws := in_vp.m_xd * sarg;

    argss  := 0.0;
    argsd  := 0.0;
    dbargs := 0.0;
    dbargd := 0.0;
    dgdvds := 0.0;
    dgddb2 := 0.0;
    if ( in_p.m_junctionDepth &gt; 0) then
      tmp   := 2.0 / in_p.m_junctionDepth;
      argxs := 1.0 + xws * tmp;
      argxd := 1.0 + xwd * tmp;
      args  := sqrt( argxs);
      argd  := sqrt( argxd);
      tmp   := 0.5 * in_p.m_junctionDepth / out_c.m_lEff;
      argss := tmp * (args - 1.0);
      argsd := tmp * (argd - 1.0);
    end if;
    gamasd := in_vp.m_gamma * (1.0 - argss - argsd);
    dbxwd  := in_vp.m_xd * dbrgdb;
    dbxws  := in_vp.m_xd * dsrgdb;
    if ( in_p.m_junctionDepth &gt; 0) then
      tmp    := 0.5 / out_c.m_lEff;
      dbargs := tmp * dbxws / args;
      dbargd := tmp * dbxwd / argd;
      dasdb2 := -in_vp.m_xd * (d2sdb2 + dsrgdb * dsrgdb * in_vp.m_xd
                / (in_p.m_junctionDepth * argxs)) / (out_c.m_lEff * args);
      daddb2 := -in_vp.m_xd * (d2bdb2 + dbrgdb * dbrgdb * in_vp.m_xd
                / (in_p.m_junctionDepth * argxd))
                / (out_c.m_lEff * argd);
      dgddb2 := -0.5 * in_vp.m_gamma * (dasdb2 + daddb2);
    end if;
    dgddvb := -in_vp.m_gamma * (dbargs + dbargd);
    if ( in_p.m_junctionDepth &gt; 0) then
      ddxwd  := -dbxwd;
      dgdvds := -in_vp.m_gamma * 0.5 * ddxwd / (out_c.m_lEff * argd);
    end if;
  else
    gamasd := in_vp.m_gamma;
    gammad := in_vp.m_gamma;
    dgddvb := 0.0;
    dgdvds := 0.0;
    dgddb2 := 0.0;
  end if;

  out_c.m_von   := vbin + gamasd * sarg;
  vth           := out_c.m_von;
  out_c.m_vdsat := 0.0;
  if ( in_p.m_fastSurfaceStateDensity &lt;&gt; 0.0 and out_c.m_capOx &lt;&gt; 0.0) then
    cfs          := in_C.CHARGE * in_p.m_fastSurfaceStateDensity * 1.0e4;
    cdonco       := -(gamasd * dsrgdb + dgddvb * sarg) + factor;
    xn           := 1.0 + cfs / out_c.m_capOx * in_m.m_width * out_c.m_lEff + cdonco;
    tmp          := vt * xn;
    out_c.m_von  := out_c.m_von + tmp;
    argg         := 1.0 / tmp;
    vgst         := vgs - out_c.m_von;
  else
    vgst := vgs - out_c.m_von;
    if ( vgs &lt;= out_c.m_von) then
      // cutoff region
      out_c.m_gds    := 0.0;
      out_c.m_cdrain := 0.0;
      out_c.m_gm     := 0.0;
      out_c.m_gmbs   := 0.0;
      return;
    end if;
  end if;

  sarg3  := sarg * sarg * sarg;
  gammad := gamasd;
  dgdvbs := dgddvb;
  body   := barg * barg * barg - sarg3;
  gdbdv  := 2.0 * gammad * (barg * barg * dbrgdb - sarg * sarg * dsrgdb);
  dodvbs := -factor + dgdvbs * sarg + gammad * dsrgdb;

  if ( (in_p.m_fastSurfaceStateDensity &lt;&gt; 0.0) and (out_c.m_capOx &lt;&gt; 0.0)) then
    dxndvb := 2.0 * dgdvbs * dsrgdb + gammad * d2sdb2 + dgddb2 * sarg;
    dodvbs := dodvbs + vt * dxndvb;
    dxndvd := dgdvds * dsrgdb;
    dodvds := dgdvds * sarg + vt * dxndvd;
  end if;

  // evaluate effective mobility and its derivatives
  ufact  := 1.0;
  ueff   := in_p.m_surfaceMobility * 1e-4;
  dudvgs := 0.0;
  dudvds := 0.0;
  dudvbs := 0.0;
  if (out_c.m_capOx &gt; 0.0) then
    tmp := in_p.m_critField * in_C.EPSSIL * 100 / in_vp.m_oxideCapFactor;
    if (vgst &gt; tmp) then
      ufact  := exp( in_p.m_critFieldExp * Modelica.Math.log( tmp / vgst));
      ueff   := in_p.m_surfaceMobility * 1.0e-4 * ufact;
      dudvgs := -ufact * in_p.m_critFieldExp / vgst;
      dudvds := 0.0;
      dudvbs := in_p.m_critFieldExp * ufact * dodvbs / vgst;
    end if;
  end if;

  // evaluate saturation voltage and its derivatives according to
  // grove-frohman equation
  vgsx   := vgs;
  gammad := gamasd / eta;
  dgdvbs := dgddvb;
  if (in_p.m_fastSurfaceStateDensity &lt;&gt; 0 and out_c.m_capOx &lt;&gt; 0) then
    vgsx := max( vgs, out_c.m_von);
  end if;
  if (gammad &gt; 0) then
    gammd2 := gammad * gammad;
    argv   := (vgsx - vbin) / eta + phiMinVbs;
    if (argv &lt;= 0.0) then
      out_c.m_vdsat := 0.0;
      dsdvgs        := 0.0;
      dsdvbs        := 0.0;
    else
      arg           := sqrt( 1.0 + 4.0 * argv / gammd2);
      out_c.m_vdsat := (vgsx - vbin) / eta + gammd2 * (1.0 - arg) / 2.0;
      out_c.m_vdsat := max( out_c.m_vdsat, 0.0);
      dsdvgs        := (1.0 - 1.0 / arg) / eta;
      dsdvbs        := (gammad * (1.0 - arg) + 2.0 * argv / (gammad * arg))
                       / eta * dgdvbs + 1.0 / arg + factor * dsdvgs;
    end if;
  else
    out_c.m_vdsat := (vgsx - vbin) / eta;
    out_c.m_vdsat := max( out_c.m_vdsat, 0.0);
    dsdvgs        := 1.0;
    dsdvbs        := 0.0;
  end if;

  if (in_p.m_maxDriftVel &gt; 0) then
    // evaluate saturation voltage and its derivatives
    // according to baum&#39;s theory of scattering velocity saturation
    v1 := (vgsx - vbin) / eta + phiMinVbs;
    v2 := phiMinVbs;
    xv := in_p.m_maxDriftVel * out_c.m_lEff / ueff;
    a1 := gammad / 0.75;
    b1 := -2.0 * (v1 + xv);
    c1 := -2.0 * gammad * xv;
    d1 := 2.0 * v1 * (v2 + xv) - v2 * v2 - 4.0 / 3.0 * gammad * sarg3;
    b2 := a1 * c1 - 4.0 * d1;
    r1 := -b1 * b1 / 3.0 + b2;
    s1 := 2.0 * b1 * b1 * (-b1) / 27.0 + b1 * b2 / 3.0 + (-d1) * (a1 * a1 - 4.0 * b1) - c1 * c1;
    s2 := s1 * s1;
    p1 := s2 / 4.0 + r1 * r1 * r1 / 27.0;
    p0 := abs( p1);
    p2 := sqrt( p0);

    sig1[1] :=  1.0;
    sig1[2] := -1.0;
    sig1[3] :=  1.0;
    sig1[4] := -1.0;
    sig2[1] :=  1.0;
    sig2[2] :=  1.0;
    sig2[3] := -1.0;
    sig2[4] := -1.0;

    if (p1 &lt; 0) then
      y3 := 2.0 * exp( Modelica.Math.log( sqrt( s2 / 4.0 + p0)) / 3.0)
            * cos( Modelica.Math.atan( -2.0 * p2 / s1) / 3.0) + b1 / 3.0;
    else
      y3 := exp( Modelica.Math.log( abs( -s1 / 2.0 + p2)) / 3.0)
            + exp( Modelica.Math.log( abs( -s1 / 2.0 - p2)) / 3.0)
            + b1 / 3.0;
    end if;

    a3 := sqrt( a1 * a1 / 4.0 - b1 + y3);
    b3 := sqrt( y3 * y3 / 4.0 - d1);

    for i in 1:4 loop
      a4[i]  := a1/2.0+sig1[i]*a3;
      b4[i]  := y3/2.0+sig2[i]*b3;
      delta4 := a4[i]*a4[i]/4.0-b4[i];
      if (delta4 &gt;= 0) then
        iknt     := iknt+1;
        tmp      := sqrt(delta4);
        x4[iknt] := -a4[i]/2.0+tmp;
        iknt     := iknt+1;
        x4[iknt] := -a4[i]/2.0-tmp;
      end if;
    end for;
    jknt := 0;
    for j in 1:iknt loop
      if (x4[j] &gt; 0) then
        poly4[j] := x4[j]*x4[j]*x4[j]*x4[j]+a1*x4[j]*x4[j]*x4[j];
        poly4[j] := poly4[j]+b1*x4[j]*x4[j]+c1*x4[j]+d1;
        if (abs(poly4[j]) &lt;= 1.0e-6) then
          jknt := jknt+1;
          if (jknt &lt;= 1) then
            xvalid := x4[j];
          end if;
          if (x4[j] &lt;= xvalid) then
            xvalid := x4[j];
          end if;
        end if;
      end if;
    end for;

    if (jknt &gt; 0) then
      out_c.m_vdsat := xvalid * xvalid - phiMinVbs;
    end if;
  end if;

  // evaluate effective channel length and its derivatives
  dldvgs := 0.0;
  dldvds := 0.0;
  dldvbs := 0.0;
  if (vds &lt;&gt; 0.0) then
    gammad :=gamasd;
    if ((vbs - out_c.m_vdsat) &lt;= 0) then
      bsarg  := sqrt(out_c.m_vdsat + phiMinVbs);
      dbsrdb := -0.5 / bsarg;
    else
      bsarg  :=sphi/(1.0 + 0.5*(vbs - out_c.m_vdsat)/out_c.m_tPhi);
      dbsrdb :=-0.5*bsarg*bsarg/sphi3;
    end if;
    bodys  := bsarg * bsarg * bsarg - sarg3;
    gdbdvs := 2.0 * gammad * (bsarg * bsarg * dbsrdb - sarg * sarg * dsrgdb);
    if (in_p.m_maxDriftVel &lt;= 0) then
      if (in_vp.m_substrateDoping &lt;&gt; 0.0 and (xlamda &lt;= 0.0)) then
        argv   := (vds - out_c.m_vdsat) / 4.0;
        sargv  := sqrt(1.0 + argv * argv);
        arg    := sqrt(argv + sargv);
        xlfact := in_vp.m_xd / (out_c.m_lEff * vds);
        xlamda := xlfact * arg;
        dldsat := vds * xlamda / (8.0 * sargv);

        dldvgs := dldsat * dsdvgs;
        dldvds := -xlamda + dldsat;
        dldvbs := dldsat * dsdvbs;
      end if;
    else
      argv   := (vgsx - vbin) / eta - out_c.m_vdsat;
      xdv    := in_vp.m_xd / sqrt(in_p.m_channelCharge);
      xlv    := in_p.m_maxDriftVel * xdv / (2.0 * ueff);
      vqchan := argv - gammad * bsarg;
      dqdsat := -1.0 + gammad * dbsrdb;
      vl     := in_p.m_maxDriftVel *out_c. m_lEff;
      dfunds := vl * dqdsat - ueff * vqchan;
      dfundg := (vl - ueff * out_c.m_vdsat) / eta;
      dfundb := -vl * (1.0 + dqdsat - factor / eta) + ueff *
         (gdbdvs - dgdvbs * bodys / 1.5) / eta;
      dsdvgs := -dfundg / dfunds;
      dsdvbs := -dfundb / dfunds;
      if ((in_vp.m_substrateDoping &lt;&gt; 0.0) and (xlamda &lt;= 0.0)) then
        argv   := vds - out_c.m_vdsat;
        argv   := max(argv,0.0);
        xls    := sqrt(xlv * xlv + argv);
        dldsat := xdv / (2.0 * xls);
        xlfact := xdv / (out_c.m_lEff * vds);
        xlamda := xlfact * (xls - xlv);
        dldsat := dldsat / out_c.m_lEff;

        dldvgs := dldsat * dsdvgs;
        dldvds := -xlamda + dldsat;
        dldvbs := dldsat * dsdvbs;
      end if;
    end if;
  end if;

  // limit channel shortening at punch-through
  xwb    :=in_vp.m_xd*sqrt(out_c.m_tBulkPot);
  xld    :=out_c.m_lEff - xwb;
  clfact :=1.0 - xlamda*vds;
  dldvds :=-xlamda - dldvds;
  xleff  :=out_c.m_lEff*clfact;
  deltal :=xlamda*vds*out_c.m_lEff;
  if (in_vp.m_substrateDoping == 0.0) then
    xwb := 0.25e-6;
  end if;
  if (xleff &lt; xwb) then
    xleff  := xwb / (1.0 + (deltal - xld) / xwb);
    clfact := xleff / out_c.m_lEff;
    dfact  := xleff * xleff / (xwb * xwb);
    dldvgs := dfact * dldvgs;
    dldvds := dfact * dldvds;
    dldvbs := dfact * dldvbs;
  end if;

  // evaluate effective beta (effective kp)
  beta1 := out_c.m_Beta * ufact / clfact;

  // test for mode of operation and branch appropriately
  gammad := gamasd;
  dgdvbs := dgddvb;
  if (vds &lt;= 1.0e-10) then
    if (vgs &lt;= out_c.m_von) then
      if ((in_p.m_fastSurfaceStateDensity == 0.0) or (out_c.m_capOx == 0.0)) then
        out_c.m_gds := 0.0;
      else
        out_c.m_gds := beta1 * (out_c.m_von - vbin - gammad * sarg) * exp(argg * (vgs - out_c.m_von));
      end if;
    else
      out_c.m_gds :=beta1*(vgs - vbin - gammad*sarg);
    end if;
    out_c.m_cdrain :=0.0;
    out_c.m_gm     :=0.0;
    out_c.m_gmbs   :=0.0;
    return;
  end if;

  if (vgs &lt;= out_c.m_von) then
    // subthreshold region
    if (out_c.m_vdsat &lt;= 0) then
      out_c.m_gds    := 0.0;
      if (vgs &gt; vth) then
        return;
      end if;
      out_c.m_cdrain := 0.0;
      out_c.m_gm     := 0.0;
      out_c.m_gmbs   := 0.0;
      return;
    end if;
    vdson := min(out_c.m_vdsat, vds);
    if (vds &gt; out_c.m_vdsat) then
      barg   := bsarg;
      dbrgdb := dbsrdb;
      body   := bodys;
      gdbdv  := gdbdvs;
    end if;
    cdson  := beta1 * ((out_c.m_von - vbin - eta * vdson * 0.5) * vdson - gammad * body / 1.5);
    didvds := beta1 * (out_c.m_von - vbin - eta * vdson - gammad * barg);
    gdson  := -cdson * dldvds / clfact - beta1 * dgdvds * body / 1.5;
    if (vds &lt; out_c.m_vdsat) then
      gdson := gdson + didvds;
    end if;
    gbson := -cdson * dldvbs / clfact + beta1 *
             (dodvbs * vdson + factor * vdson - dgdvbs * body / 1.5 - gdbdv);
    if (vds &gt; out_c.m_vdsat) then
      gbson := gbson + didvds * dsdvbs;
    end if;
    expg           := exp(argg * (vgs - out_c.m_von));
    out_c.m_cdrain := cdson * expg;
    gmw            := out_c.m_cdrain * argg;
    out_c.m_gm     := gmw;
    if (vds &gt; out_c.m_vdsat) then
      out_c.m_gm := gmw + didvds * dsdvgs * expg;
    end if;
    tmp          := gmw * (vgs - out_c.m_von) / xn;
    out_c.m_gds  := gdson * expg - out_c.m_gm * dodvds - tmp * dxndvd;
    out_c.m_gmbs := gbson * expg - out_c.m_gm * dodvbs - tmp * dxndvb;
  elseif (vds &lt;= out_c.m_vdsat) then
    // linear region
    out_c.m_cdrain := beta1 * ((vgs - vbin - eta * vds / 2.0) * vds - gammad * body / 1.5);
    arg            := out_c.m_cdrain * (dudvgs / ufact - dldvgs / clfact);
    out_c.m_gm     := arg + beta1 * vds;
    arg            := out_c.m_cdrain * (dudvds / ufact - dldvds / clfact);
    out_c.m_gds    := arg + beta1 * (vgs - vbin - eta *
                      vds - gammad * barg - dgdvds * body / 1.5);
    arg            := out_c.m_cdrain * (dudvbs / ufact - dldvbs / clfact);
    out_c.m_gmbs   := arg - beta1 * (gdbdv + dgdvbs * body / 1.5 - factor * vds);
  else
    // saturation region
    out_c.m_cdrain := beta1 * ((vgs - vbin - eta *
                     out_c.m_vdsat / 2.0) * out_c.m_vdsat - gammad * bodys / 1.5);
    arg            := out_c.m_cdrain * (dudvgs / ufact - dldvgs / clfact);
    out_c.m_gm     := arg + beta1 * out_c.m_vdsat
                     + beta1 * (vgs - vbin - eta * out_c.m_vdsat - gammad * bsarg) * dsdvgs;
    out_c.m_gds    := -out_c.m_cdrain * dldvds / clfact - beta1 * dgdvds * bodys / 1.5;
    arg            := out_c.m_cdrain * (dudvbs / ufact - dldvbs / clfact);
    out_c.m_gmbs   := arg - beta1 * (gdbdvs + dgdvbs * bodys / 1.5 - factor * out_c.m_vdsat)
                     + beta1 *  (vgs - vbin - eta * out_c.m_vdsat - gammad * bsarg) * dsdvbs;
  end if;

end drainCur;</code></pre>
<hr />
<h1 id="modelica.electrical.spice3.internal.mos2.mos2renameparameters"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2">Modelica.Electrical.Spice3.Internal.Mos2</a>.mos2RenameParameters</h1>
<p><strong>Parameter renaming to internal names</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p>This function mos2RenameParameters assigns the external (given by the user, e.g., RD) technology parameters to the internal parameters (e.g., m_drainResistance). It also does the analysis of the IsGiven values (level 2).</p>
<p>::</p>
<h2 id="inputs-2">Inputs</h2>
<table>
<col width="64%" />
<col width="5%" />
<col width="6%" />
<col width="23%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal.html#Modelica.Electrical.Spice3.Internal.ModelcardMOS2">ModelcardMOS2</a></td>
<td align="left">ex</td>
<td align="left">
</td>
<td align="left">Modelcard with technologie parameters</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal.html#Modelica.Electrical.Spice3.Internal.SpiceConstants">SpiceConstants</a></td>
<td align="left">con</td>
<td align="left">
</td>
<td align="left">Spice constants</td>
</tr>
</tbody>
</table>
<h2 id="outputs-2">Outputs</h2>
<table>
<col width="72%" />
<col width="5%" />
<col width="21%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2.Mos2ModelLineParams">Mos2ModelLineParams</a></td>
<td align="left">intern</td>
<td align="left">Output record model line parameters</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>function mos2RenameParameters &quot;Parameter renaming to internal names&quot;

  input ModelcardMOS2 ex &quot;Modelcard with technologie parameters&quot;;
  input SpiceConstants con &quot;Spice constants&quot;;

  output Mos2ModelLineParams intern &quot;Output record model line parameters&quot;;

algorithm 
   intern.m_narrowFactor := ex.DELTA;           // DELTA, Width effect on threshold
   intern.m_critFieldExp := ex.UEXP;            // UEXP, Crit. field exp for mob. deg
   intern.m_critField := ex.UCRIT;              // UCRIT, Crit. field for mob. degradation
   intern.m_maxDriftVel := ex.VMAX;             // VMAX, Maximum carrier drift velocity
   intern.m_junctionDepth := ex.XJ;             // XJ, Junction depth
   intern.m_channelCharge := ex.NEFF;           // NEFF, Total channel charge coeff
   intern.m_fastSurfaceStateDensity := ex.NFS;  // NFS, Fast surface state density

   intern.m_oxideCapFactor := 0;

    intern.m_vtOIsGiven := if          (ex.VTO &gt; -1e40) then 1 else 0;
    intern.m_vt0 := if         (ex.VTO &gt; -1e40) then ex.VTO else 0;

    intern.m_capBDIsGiven := if          (ex.CBD &gt; -1e40) then 1 else 0;
    intern.m_capBD := if         (ex.CBD &gt; -1e40) then ex.CBD else 0;

    intern.m_capBSIsGiven := if          (ex.CBS &gt; -1e40) then 1 else 0;
    intern.m_capBS := if         (ex.CBS &gt; -1e40) then ex.CBS else 0;

    intern.m_bulkCapFactor := ex.CJ;           // F/(m*m) zero-bias bulk junction bottom cap. per sq-meter of junction area (default 0)
    intern.m_sideWallCapFactor := ex.CJSW;     // F/m zero-bias junction sidewall cap. per meter of junction perimeter (default 0)
    intern.m_fwdCapDepCoeff := ex.FC;          // coefficient for forward-bias depletion capacitance formula (default 0.5)

    intern.m_phiIsGiven := if          (ex.PHI &gt; -1e40) then 1 else 0;
    intern.m_phi := if         (ex.PHI &gt; -1e40) then ex.PHI else 0.6;

    intern.m_gammaIsGiven := if          (ex.GAMMA &gt; -1e40) then 1 else 0;
    intern.m_gamma := if         (ex.GAMMA &gt; -1e40) then ex.GAMMA else 0;

    intern.m_lambda := ex.LAMBDA;              // 1/V channel-length modulation (default 0)

    intern.m_substrateDopingIsGiven := if          (ex.NSUB &gt; -1e40) then 1 else 0;
    intern.m_substrateDoping := if         (ex.NSUB &gt; -1e40) then ex.NSUB else 0;

    intern.m_gateType := ex.TPG;               // type of gate material: +1 opp. to substrate, -1 same as substrate, 0 Al gate (default 1)
    intern.m_surfaceStateDensity := ex.NSS;    // 1/(cm*cm) surface state density (default 0)
    intern.m_surfaceMobility := ex.UO;         // (cm*cm)/(Vs) surface mobility (default 600)
    intern.m_latDiff := ex.LD;                 // m lateral diffusion (default 0)
    intern.m_jctSatCur := ex.IS;               // A bulk junction saturation current (defaul 1e-14)

    intern.m_drainResistanceIsGiven := if 
                                         (ex.RD &gt; -1e40) then 1 else 0;
    intern.m_drainResistance := if 
                                 (ex.RD &gt; -1e40) then ex.RD else 0;

          intern.m_sourceResistanceIsGiven := if 
                                         (ex.RS &gt; -1e40) then 1 else 0;
    intern.m_sourceResistance := if 
                                 (ex.RS &gt; -1e40) then ex.RS else 0;

    intern.m_transconductanceIsGiven := if          (ex.KP &gt; -1e40) then 1 else 0;
    intern.m_transconductance := if         (ex.KP &gt; -1e40) then ex.KP else 2e-5;

  intern.m_tnom := if (ex.TNOM &gt; -1e40) then ex.TNOM + SpiceConstants.CONSTCtoK else 
    300.15;

   intern.m_jctSatCurDensity := ex.JS;             // A/(m*m) bulk junction saturation current per sq-meter of junction area (default 0)
   intern.m_sheetResistance := ex.RSH;             // Ohm drain and source diffusion sheet resistance (default 0)
   intern.m_bulkJctPotential := ex.PB;             // V bulk junction potential (default 0.8)
   intern.m_bulkJctBotGradingCoeff := ex.MJ;       // bulk junction bottom grading coeff. (default 0.5)
   intern.m_bulkJctSideGradingCoeff := ex.MJSW;    // bulk junction sidewall grading coeff. (default 0.5)

   intern.m_oxideThickness := ex.TOX;              // m oxide thickness (default 1e-7)

   intern.m_oxideThicknessIsGiven := if          (ex.TOX &gt; -1e40) then 1 else 0;
   intern.m_oxideThickness := if         (ex.TOX &gt; -1e40) then ex.TOX else 1e-7;

   intern.m_gateSourceOverlapCapFactor := ex.CGSO; // F/m gate-source overlap capacitance per meter channel width (default 0)
   intern.m_gateDrainOverlapCapFactor := ex.CGDO;  // F/m gate-drain overlap capacitance per meter channel width (default 0)
   intern.m_gateBulkOverlapCapFactor := ex.CGBO;   // F/m gate-bulk overlap capacitance per meter channel width (default 0)
   intern.m_fNcoef := ex.KF;                       // flicker-noise coefficient (default 0)
   intern.m_fNexp := ex.AF;                        // flicker-noise exponent (default 1)

end mos2RenameParameters;</code></pre>
<hr />
<h1 id="modelica.electrical.spice3.internal.mos2.mos2renameparametersdev"><a href="Modelica_Electrical_Spice3_Internal_Mos2.html#Modelica.Electrical.Spice3.Internal.Mos2">Modelica.Electrical.Spice3.Internal.Mos2</a>.mos2RenameParametersDev</h1>
<p><strong>Device parameter renaming to internal names</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p>This function mos2RenameParameters assigns the external (given by the user) device parameters to the internal parameters. It also does the analysis of the IsGiven values (level 2).</p>
<p>::</p>
<h2 id="inputs-3">Inputs</h2>
<table>
<col width="52%" />
<col width="4%" />
<col width="5%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal.html#Modelica.Electrical.Spice3.Internal.ModelcardMOS2">ModelcardMOS2</a></td>
<td align="left">ex</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">mtype</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">W</td>
<td align="left">
</td>
<td align="left">Width of channel region [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">L</td>
<td align="left">
</td>
<td align="left">Length of channel region [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Area">Area</a></td>
<td align="left">AD</td>
<td align="left">
</td>
<td align="left">Area of drain diffusion [m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Area">Area</a></td>
<td align="left">AS</td>
<td align="left">
</td>
<td align="left">Area of source diffusion [m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">PD</td>
<td align="left">
</td>
<td align="left">Drain perimeter [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">PS</td>
<td align="left">
</td>
<td align="left">Source perimeter [m]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">NRD</td>
<td align="left">
</td>
<td align="left">Length of drain squares</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">NRS</td>
<td align="left">
</td>
<td align="left">Length of Source squares</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">OFF</td>
<td align="left">
</td>
<td align="left">Optional initial condition: 0 - IC not used, 1 - IC used, not implemented yet</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">IC</td>
<td align="left">
</td>
<td align="left">Initial condition values, not implemented yet</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Temp_C">Temp_C</a></td>
<td align="left">TEMP</td>
<td align="left">
</td>
<td align="left">Temperature [degC]</td>
</tr>
</tbody>
</table>
<h2 id="outputs-3">Outputs</h2>
<table>
<col width="77%" />
<col width="6%" />
<col width="16%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Electrical_Spice3_Internal_Mosfet.html#Modelica.Electrical.Spice3.Internal.Mosfet.Mosfet">Mosfet</a></td>
<td align="left">dev</td>
<td align="left">Output record Mosfet</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>function mos2RenameParametersDev 
  &quot;Device parameter renaming to internal names&quot;
  input ModelcardMOS2 ex;
  input Integer mtype;
  input Modelica.SIunits.Length W &quot;Width of channel region&quot;;
  input Modelica.SIunits.Length L &quot;Length of channel region&quot;;
  input Modelica.SIunits.Area AD &quot;Area of drain diffusion&quot;;
  input Modelica.SIunits.Area AS &quot;Area of source diffusion&quot;;
  input Modelica.SIunits.Length PD &quot;Drain perimeter&quot;;
  input Modelica.SIunits.Length PS &quot;Source perimeter&quot;;
  input Real NRD &quot;Length of drain squares&quot;;
  input Real NRS &quot;Length of Source squares&quot;;
  input Integer OFF 
    &quot;Optional initial condition: 0 - IC not used, 1 - IC used, not implemented yet&quot;;
  input Real IC &quot;Initial condition values, not implemented yet&quot;;
  input Modelica.SIunits.Temp_C TEMP &quot;Temperature&quot;;

  output Mosfet.Mosfet dev &quot;Output record Mosfet&quot;;

algorithm 
/*device parameters*/
  dev.m_len := L;               // L, length of channel region
  dev.m_width := W;             // W, width of channel region
  dev.m_drainArea := AD;        // AD, area of drain diffusion
  dev.m_sourceArea := AS;       // AS, area of source diffusion
  dev.m_drainSquares := NRD;    // NRD, length of drain in squares
  dev.m_sourceSquares := NRS;   // NRS, length of source in squares
  dev.m_drainPerimiter := PD;   // PD, Drain perimeter;
  dev.m_sourcePerimiter := PS;  // PS, Source perimeter

    dev.m_dICVDSIsGiven := if          (IC &gt; -1e40) then 1 else 0;
    dev.m_dICVDS := if         (IC &gt; -1e40) then IC else 0;

    dev.m_dICVGSIsGiven := if          (IC &gt; -1e40) then 1 else 0;
    dev.m_dICVGS := if         (IC &gt; -1e40) then IC else 0;

    dev.m_dICVBSIsGiven := if          (IC &gt; -1e40) then 1 else 0;
    dev.m_dICVBS := if         (IC &gt; -1e40) then IC else 0;

  dev.m_off := OFF;             // non-zero to indicate device is off for dc analysis
  dev.m_bPMOS := mtype;         // P type MOSfet model
  dev.m_nLevel := ex.LEVEL;
  assert(ex.LEVEL== 1, &quot;only MOS Level1 implemented&quot;);
  dev.m_dTemp :=TEMP + SpiceConstants.CONSTCtoK;
end mos2RenameParametersDev;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:29:47 2010.</p>
</body>
</html>
