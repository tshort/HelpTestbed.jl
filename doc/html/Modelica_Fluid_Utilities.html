<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Fluid.Utilities</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Fluid.Utilities</h1>
</div>
<h1 id="modelica.fluid.utilities"><a href="Modelica_Fluid.html#Modelica.Fluid">Modelica.Fluid</a>.Utilities</h1>
<p><strong>Utility models to construct fluid components (should not be used directly)</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="59%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image12" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.checkBoundary">checkBoundary</a></td>
<td align="left">Check whether boundary definition is correct</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image13" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regRoot">regRoot</a></td>
<td align="left">Anti-symmetric square root approximation with finite derivative in the origin</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image14" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regRoot_der">regRoot_der</a></td>
<td align="left">Derivative of regRoot</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image15" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regSquare">regSquare</a></td>
<td align="left">Anti-symmetric square approximation with non-zero derivative in the origin</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image16" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regPow">regPow</a></td>
<td align="left">Anti-symmetric power approximation with non-zero derivative in the origin</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image17" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regRoot2">regRoot2</a></td>
<td align="left">Anti-symmetric approximation of square root with discontinuous factor so that the first derivative is finite and continuous</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image18" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regSquare2">regSquare2</a></td>
<td align="left">Anti-symmetric approximation of square with discontinuous factor so that the first derivative is non-zero and is continuous</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image19" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regStep">regStep</a></td>
<td align="left">Approximation of a general step, such that the characteristic is continuous and differentiable</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Fluid.Utilities.checkBoundaryS.png" alt="image20" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero">evaluatePoly3_derivativeAtZero</a></td>
<td align="left">Evaluate polynomial of order 3 that passes the origin with a predefined derivative</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Fluid.Utilities.regFun3S.png" alt="image21" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.regFun3">regFun3</a></td>
<td align="left">Co-monotonic and C1 smooth regularization function</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Fluid.Utilities.regFun3S.png" alt="image22" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.cubicHermite">cubicHermite</a></td>
<td align="left">Evaluate a cubic Hermite spline</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Fluid.Utilities.regFun3S.png" alt="image23" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities.cubicHermite_withDerivative">cubicHermite_withDerivative</a></td>
<td align="left">Evaluate a cubic Hermite spline, return value and derivative</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image24-modelica.fluid.utilities.checkboundary"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image24" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.checkBoundary</h1>
<p><strong>Check whether boundary definition is correct</strong></p>
<h2 id="information-1">Information</h2>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs">Inputs</h2>
<table>
<col width="14%" />
<col width="27%" />
<col width="28%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">String</td>
<td align="left">mediumName</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">String</td>
<td align="left">substanceNames[:]</td>
<td align="left">
</td>
<td align="left">Names of substances</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">singleState</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">define_p</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">X_boundary[:]</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">String</td>
<td align="left">modelName</td>
<td align="left">&quot;??? boundary ???&quot;</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>function checkBoundary &quot;Check whether boundary definition is correct&quot;
  extends Modelica.Icons.Function;
  input String mediumName;
  input String substanceNames[:] &quot;Names of substances&quot;;
  input Boolean singleState;
  input Boolean define_p;
  input Real X_boundary[:];
  input String modelName = &quot;??? boundary ???&quot;;
protected 
  Integer nX = size(X_boundary,1);
  String X_str;
algorithm 
  assert(not singleState or singleState and define_p, &quot;
Wrong value of parameter define_p (= false) in model \&quot;&quot; + modelName + &quot;\&quot;:
The selected medium \&quot;&quot;
                      + mediumName + &quot;\&quot; has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
&quot;);

  for i in 1:nX loop
    assert(X_boundary[i] &gt;= 0.0, &quot;
Wrong boundary mass fractions in medium \&quot;&quot;
+ mediumName + &quot;\&quot; in model \&quot;&quot; + modelName + &quot;\&quot;:
The boundary value X_boundary(&quot;
                            + String(i) + &quot;) = &quot; + String(
      X_boundary[i]) + &quot;
is negative. It must be positive.
&quot;);
  end for;

  if nX &gt; 0 and abs(sum(X_boundary) - 1.0) &gt; 1.e-10 then
     X_str :=&quot;&quot;;
     for i in 1:nX loop
        X_str :=X_str + &quot;   X_boundary[&quot; + String(i) + &quot;] = &quot; + String(X_boundary[
        i]) + &quot; \&quot;&quot; + substanceNames[i] + &quot;\&quot;\n&quot;;
     end for;
     Modelica.Utilities.Streams.error(
        &quot;The boundary mass fractions in medium \&quot;&quot; + mediumName + &quot;\&quot; in model \&quot;&quot; + modelName + &quot;\&quot;\n&quot; +
        &quot;do not sum up to 1. Instead, sum(X_boundary) = &quot; + String(sum(X_boundary)) + &quot;:\n&quot;
        + X_str);
  end if;
end checkBoundary;</code></pre>
<hr />
<h1 id="image25-modelica.fluid.utilities.regroot"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image25" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regRoot</h1>
<p><strong>Anti-symmetric square root approximation with finite derivative in the origin</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>This function approximates sqrt(abs(x))*sgn(x), such that the derivative is finite and smooth in x=0.</p>
<table>
<col width="26%" />
<col width="41%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Approximation</th>
<th align="left">Range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">y = regRoot(x)</td>
<td align="left">y ~= sqrt(abs(x))*sgn(x)</td>
<td align="left">abs(x) &gt;&gt;delta</td>
</tr>
<tr class="even">
<td align="left">y = regRoot(x)</td>
<td align="left">y ~= x/sqrt(delta)</td>
<td align="left">abs(x) &lt;&lt; delta</td>
</tr>
</tbody>
</table>
<p>With the default value of delta=0.01, the difference between sqrt(x) and regRoot(x) is 16% around x=0.01, 0.25% around x=0.1 and 0.0025% around x=1.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-1">Inputs</h2>
<table>
<col width="9%" />
<col width="10%" />
<col width="13%" />
<col width="66%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">delta</td>
<td align="left">0.01</td>
<td align="left">Range of significant deviation from sqrt(abs(x))*sgn(x)</td>
</tr>
</tbody>
</table>
<h2 id="outputs">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>function regRoot 
  &quot;Anti-symmetric square root approximation with finite derivative in the origin&quot;
  annotation(derivative=Utilities.regRoot_der);
  extends Modelica.Icons.Function;
  input Real x;
  input Real delta=0.01 
    &quot;Range of significant deviation from sqrt(abs(x))*sgn(x)&quot;;
  output Real y;
algorithm 
  y := x/(x*x+delta*delta)^0.25;

end regRoot;</code></pre>
<hr />
<h1 id="image26-modelica.fluid.utilities.regroot_der"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image26" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regRoot_der</h1>
<p><strong>Derivative of regRoot</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-2">Inputs</h2>
<table>
<col width="11%" />
<col width="12%" />
<col width="15%" />
<col width="60%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">delta</td>
<td align="left">0.01</td>
<td align="left">Range of significant deviation from sqrt(x)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">dx</td>
<td align="left">
</td>
<td align="left">Derivative of x</td>
</tr>
</tbody>
</table>
<h2 id="outputs-1">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">dy</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>function regRoot_der &quot;Derivative of regRoot&quot;
  extends Modelica.Icons.Function;
  input Real x;
  input Real delta=0.01 &quot;Range of significant deviation from sqrt(x)&quot;;
  input Real dx &quot;Derivative of x&quot;;
  output Real dy;
algorithm 
  dy := dx*0.5*(x*x+2*delta*delta)/((x*x+delta*delta)^1.25);

end regRoot_der;</code></pre>
<hr />
<h1 id="image27-modelica.fluid.utilities.regsquare"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image27" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regSquare</h1>
<p><strong>Anti-symmetric square approximation with non-zero derivative in the origin</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>This function approximates x^2*sgn(x), such that the derivative is non-zero in x=0.</p>
<table>
<col width="29%" />
<col width="29%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Approximation</th>
<th align="left">Range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">y = regSquare(x)</td>
<td align="left">y ~= x^2*sgn(x)</td>
<td align="left">abs(x) &gt;&gt;delta</td>
</tr>
<tr class="even">
<td align="left">y = regSquare(x)</td>
<td align="left">y ~= x*delta</td>
<td align="left">abs(x) &lt;&lt; delta</td>
</tr>
</tbody>
</table>
<p>With the default value of delta=0.01, the difference between x^2 and regSquare(x) is 41% around x=0.01, 0.4% around x=0.1 and 0.005% around x=1.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-3">Inputs</h2>
<table>
<col width="10%" />
<col width="12%" />
<col width="14%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">delta</td>
<td align="left">0.01</td>
<td align="left">Range of significant deviation from x^2*sgn(x)</td>
</tr>
</tbody>
</table>
<h2 id="outputs-2">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>function regSquare 
  &quot;Anti-symmetric square approximation with non-zero derivative in the origin&quot;
  extends Modelica.Icons.Function;
  input Real x;
  input Real delta=0.01 &quot;Range of significant deviation from x^2*sgn(x)&quot;;
  output Real y;
algorithm 
  y := x*sqrt(x*x+delta*delta);

end regSquare;</code></pre>
<hr />
<h1 id="image28-modelica.fluid.utilities.regpow"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image28" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regPow</h1>
<p><strong>Anti-symmetric power approximation with non-zero derivative in the origin</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p>This function approximates abs(x)^a*sign(x), such that the derivative is positive, finite and smooth in x=0.</p>
<table>
<col width="25%" />
<col width="36%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Approximation</th>
<th align="left">Range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">y = regPow(x)</td>
<td align="left">y ~= abs(x)^a*sgn(x)</td>
<td align="left">abs(x) &gt;&gt;delta</td>
</tr>
<tr class="even">
<td align="left">y = regPow(x)</td>
<td align="left">y ~= x*delta^(a-1)</td>
<td align="left">abs(x) &lt;&lt; delta</td>
</tr>
</tbody>
</table>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-4">Inputs</h2>
<table>
<col width="10%" />
<col width="12%" />
<col width="14%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">a</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">delta</td>
<td align="left">0.01</td>
<td align="left">Range of significant deviation from x^a*sgn(x)</td>
</tr>
</tbody>
</table>
<h2 id="outputs-3">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>function regPow 
  &quot;Anti-symmetric power approximation with non-zero derivative in the origin&quot;
  extends Modelica.Icons.Function;
  input Real x;
  input Real a;
  input Real delta=0.01 &quot;Range of significant deviation from x^a*sgn(x)&quot;;
  output Real y;
algorithm 
  y := x*(x*x+delta*delta)^((a-1)/2);

end regPow;</code></pre>
<hr />
<h1 id="image29-modelica.fluid.utilities.regroot2"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image29" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regRoot2</h1>
<p><strong>Anti-symmetric approximation of square root with discontinuous factor so that the first derivative is finite and continuous</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p>Approximates the function</p>
<pre><code>y = if x ≥ 0 then sqrt(k1*x) else -sqrt(k2*abs(x)), with k1, k2 ≥ 0</code></pre>
<p>in such a way that within the region -x_small ≤ x ≤ x_small, the function is described by two polynomials of third order (one in the region -x_small .. 0 and one within the region 0 .. x_small) such that</p>
<ul>
<li>The derivative at x=0 is finite.</li>
<li>The overall function is continuous with a continuous first derivative everywhere.</li>
<li>If parameter use_yd0 = <strong>false</strong>, the two polynomials are constructed such that the second derivatives at x=0 are identical. If use_yd0 = <strong>true</strong>, the derivative at x=0 is explicitly provided via the additional argument yd0. If necessary, the derivative yd0 is automatically reduced in order that the polynomials are strict monotonically increasing <em>[Fritsch and Carlson, 1980]</em>.</li>
</ul>
<p>Typical screenshots for two different configurations are shown below. The first one with k1=k2=1:</p>
<p>and the second one with k1=1 and k2=3:</p>
<p>The (smooth) derivative of the function with k1=1, k2=3 is shown in the next figure:</p>
<p><strong>Literature</strong></p>
<blockquote>
<dl>
<dt>Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd><p><strong>Monotone piecewise cubic interpolation</strong>. SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</p>
</dd>
</dl>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-5">Inputs</h2>
<table>
<col width="13%" />
<col width="14%" />
<col width="13%" />
<col width="59%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">x_small</td>
<td align="left">0.01</td>
<td align="left">approximation of function for |x| &lt;= x_small</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">k1</td>
<td align="left">1</td>
<td align="left">y = if x&gt;=0 then sqrt(k1*x) else -sqrt(k2*|x|)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">k2</td>
<td align="left">1</td>
<td align="left">y = if x&gt;=0 then sqrt(k1*x) else -sqrt(k2*|x|)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_yd0</td>
<td align="left">false</td>
<td align="left">= true, if yd0 shall be used</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">yd0</td>
<td align="left">1</td>
<td align="left">Desired derivative at x=0: dy/dx = yd0</td>
</tr>
</tbody>
</table>
<h2 id="outputs-4">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">ordinate value</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>function regRoot2 
  &quot;Anti-symmetric approximation of square root with discontinuous factor so that the first derivative is finite and continuous&quot;

  extends Modelica.Icons.Function;
  input Real x &quot;abscissa value&quot;;
  input Real x_small(min=0)=0.01 &quot;approximation of function for |x| &lt;= x_small&quot;;
  input Real k1(min=0)=1 &quot;y = if x&gt;=0 then sqrt(k1*x) else -sqrt(k2*|x|)&quot;;
  input Real k2(min=0)=1 &quot;y = if x&gt;=0 then sqrt(k1*x) else -sqrt(k2*|x|)&quot;;
  input Boolean use_yd0 = false &quot;= true, if yd0 shall be used&quot;;
  input Real yd0(min=0)=1 &quot;Desired derivative at x=0: dy/dx = yd0&quot;;
  output Real y &quot;ordinate value&quot;;
protected 
  encapsulated function regRoot2_utility 
    &quot;Interpolating with two 3-order polynomials with a prescribed derivative at x=0&quot;
    import Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;
     input Real x;
     input Real x1 &quot;approximation of function abs(x) &lt; x1&quot;;
     input Real k1 &quot;y = if x&gt;=0 then sqrt(k1*x) else -sqrt(k2*|x|); k1 &gt;= k2&quot;;
     input Real k2 &quot;y = if x&gt;=0 then sqrt(k1*x) else -sqrt(k2*|x|))&quot;;
     input Boolean use_yd0 &quot;= true, if yd0 shall be used&quot;;
     input Real yd0(min=0) &quot;Desired derivative at x=0: dy/dx = yd0&quot;;
     output Real y;
  protected 
     Real x2;
     Real xsqrt1;
     Real xsqrt2;
     Real y1;
     Real y2;
     Real y1d;
     Real y2d;
     Real w;
     Real y0d;
     Real w1;
     Real w2;
  algorithm 
     if k2 &gt; 0 then
        x2 :=-x1*(k2/k1);
     else
        x2 := -x1;
     end if;

     if x &lt;= x2 then
        y := -sqrt(k2*abs(x));
     else
        y1 :=sqrt(k1*x1);
        y2 :=-sqrt(k2*abs(x2));
        y1d :=sqrt(k1/x1)/2;
        y2d :=sqrt(k2/abs(x2))/2;

        if use_yd0 then
           y0d :=yd0;
        else
           /* Determine derivative, such that first and second derivative
              of left and right polynomial are identical at x=0:
           _
           Basic equations:
              y_right = a1*(x/x1) + a2*(x/x1)^2 + a3*(x/x1)^3
              y_left  = b1*(x/x2) + b2*(x/x2)^2 + b3*(x/x2)^3
              yd_right*x1 = a1 + 2*a2*(x/x1) + 3*a3*(x/x1)^2
              yd_left *x2 = b1 + 2*b2*(x/x2) + 3*b3*(x/x2)^2
              ydd_right*x1^2 = 2*a2 + 6*a3*(x/x1)
              ydd_left *x2^2 = 2*b2 + 6*b3*(x/x2)
           _
           Conditions (6 equations for 6 unknowns):
                     y1 = a1 + a2 + a3
                     y2 = b1 + b2 + b3
                 y1d*x1 = a1 + 2*a2 + 3*a3
                 y2d*x2 = b1 + 2*b2 + 3*b3
                    y0d = a1/x1 = b1/x2
                   y0dd = 2*a2/x1^2 = 2*b2/x2^2
           _
           Derived equations:
              b1 = a1*x2/x1
              b2 = a2*(x2/x1)^2
              b3 = y2 - b1 - b2
                 = y2 - a1*(x2/x1) - a2*(x2/x1)^2
              a3 = y1 - a1 - a2
           _
           Remaining equations
              y1d*x1 = a1 + 2*a2 + 3*(y1 - a1 - a2)
                     = 3*y1 - 2*a1 - a2
              y2d*x2 = a1*(x2/x1) + 2*a2*(x2/x1)^2 +
                       3*(y2 - a1*(x2/x1) - a2*(x2/x1)^2)
                     = 3*y2 - 2*a1*(x2/x1) - a2*(x2/x1)^2
              y0d    = a1/x1
           _
           Solving these equations results in y0d below
           (note, the denominator &quot;(1-w)&quot; is always non-zero, because w is negative)
           */
           w :=x2/x1;
           y0d := ( (3*y2 - x2*y2d)/w - (3*y1 - x1*y1d)*w) /(2*x1*(1 - w));
        end if;

        /* Modify derivative y0d, such that the polynomial is
           monotonically increasing. A sufficient condition is
             0 &lt;= y0d &lt;= sqrt(8.75*k_i/|x_i|)
        */
        w1 :=sqrt(8.75*k1/x1);
        w2 :=sqrt(8.75*k2/abs(x2));
        y0d :=min(y0d, 0.9*min(w1, w2));

        /* Perform interpolation in scaled polynomial:
           y_new = y/y1
           x_new = x/x1
        */
        y := y1*(if x &gt;= 0 then evaluatePoly3_derivativeAtZero(x/x1,1,1,y1d*x1/y1,y0d*x1/y1) else 
                                evaluatePoly3_derivativeAtZero(x/x1,x2/x1,y2/y1,y2d*x1/y1,y0d*x1/y1));
     end if;
  end regRoot2_utility;
algorithm 
  y := smooth(2, if x &gt;= x_small then sqrt(k1*x) else 
                 if x &lt;= -x_small then -sqrt(k2*abs(x)) else 
                 if k1 &gt;= k2 then regRoot2_utility(x,x_small,k1,k2,use_yd0,yd0) else 
                                 -regRoot2_utility(-x,x_small,k2,k1,use_yd0,yd0));
end regRoot2;</code></pre>
<hr />
<h1 id="image30-modelica.fluid.utilities.regsquare2"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image30" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regSquare2</h1>
<p><strong>Anti-symmetric approximation of square with discontinuous factor so that the first derivative is non-zero and is continuous</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p>Approximates the function</p>
<pre><code>y = if x ≥ 0 then k1*x*x else -k2*x*x, with k1, k2 &gt; 0</code></pre>
<p>in such a way that within the region -x_small ≤ x ≤ x_small, the function is described by two polynomials of third order (one in the region -x_small .. 0 and one within the region 0 .. x_small) such that</p>
<ul>
<li>The derivative at x=0 is non-zero (in order that the inverse of the function does not have an infinite derivative).</li>
<li>The overall function is continuous with a continuous first derivative everywhere.</li>
<li>If parameter use_yd0 = <strong>false</strong>, the two polynomials are constructed such that the second derivatives at x=0 are identical. If use_yd0 = <strong>true</strong>, the derivative at x=0 is explicitly provided via the additional argument yd0. If necessary, the derivative yd0 is automatically reduced in order that the polynomials are strict monotonically increasing <em>[Fritsch and Carlson, 1980]</em>.</li>
</ul>
<p>A typical screenshot for k1=1, k2=3 is shown in the next figure:</p>
<p>The (smooth, non-zero) derivative of the function with k1=1, k2=3 is shown in the next figure:</p>
<p><strong>Literature</strong></p>
<blockquote>
<dl>
<dt>Fritsch F.N. and Carlson R.E. (1980):</dt>
<dd><p><strong>Monotone piecewise cubic interpolation</strong>. SIAM J. Numerc. Anal., Vol. 17, No. 2, April 1980, pp. 238-246</p>
</dd>
</dl>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-6">Inputs</h2>
<table>
<col width="13%" />
<col width="14%" />
<col width="13%" />
<col width="58%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">x_small</td>
<td align="left">0.01</td>
<td align="left">approximation of function for |x| &lt;= x_small</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">k1</td>
<td align="left">1</td>
<td align="left">y = (if x&gt;=0 then k1 else k2)*x*|x|</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">k2</td>
<td align="left">1</td>
<td align="left">y = (if x&gt;=0 then k1 else k2)*x*|x|</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_yd0</td>
<td align="left">false</td>
<td align="left">= true, if yd0 shall be used</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">yd0</td>
<td align="left">1</td>
<td align="left">Desired derivative at x=0: dy/dx = yd0</td>
</tr>
</tbody>
</table>
<h2 id="outputs-5">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">ordinate value</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>function regSquare2 
  &quot;Anti-symmetric approximation of square with discontinuous factor so that the first derivative is non-zero and is continuous&quot;
  extends Modelica.Icons.Function;
  input Real x &quot;abscissa value&quot;;
  input Real x_small(min=0)=0.01 &quot;approximation of function for |x| &lt;= x_small&quot;;
  input Real k1(min=0)=1 &quot;y = (if x&gt;=0 then k1 else k2)*x*|x|&quot;;
  input Real k2(min=0)=1 &quot;y = (if x&gt;=0 then k1 else k2)*x*|x|&quot;;
  input Boolean use_yd0 = false &quot;= true, if yd0 shall be used&quot;;
  input Real yd0(min=0)=1 &quot;Desired derivative at x=0: dy/dx = yd0&quot;;
  output Real y &quot;ordinate value&quot;;
protected 
  encapsulated function regSquare2_utility 
    &quot;Interpolating with two 3-order polynomials with a prescribed derivative at x=0&quot;
    import Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;
     input Real x;
     input Real x1 &quot;approximation of function abs(x) &lt; x1&quot;;
     input Real k1 &quot;y = (if x&gt;=0 then k1 else -k2)*x*|x|; k1 &gt;= k2&quot;;
     input Real k2 &quot;y = (if x&gt;=0 then k1 else -k2)*x*|x|&quot;;
     input Boolean use_yd0 = false &quot;= true, if yd0 shall be used&quot;;
     input Real yd0(min=0)=1 &quot;Desired derivative at x=0: dy/dx = yd0&quot;;
     output Real y;
  protected 
     Real x2;
     Real y1;
     Real y2;
     Real y1d;
     Real y2d;
     Real w;
     Real w1;
     Real w2;
     Real y0d;
     Real ww;
  algorithm 
     // x2 :=-x1*(k2/k1)^2;
     x2 := -x1;
     if x &lt;= x2 then
        y := -k2*x^2;
     else
         y1 := k1*x1^2;
         y2 :=-k2*x2^2;
        y1d := k1*2*x1;
        y2d :=-k2*2*x2;
        if use_yd0 then
           y0d :=yd0;
        else
           /* Determine derivative, such that first and second derivative
              of left and right polynomial are identical at x=0:
              see derivation in function regRoot2
           */
           w :=x2/x1;
           y0d := ( (3*y2 - x2*y2d)/w - (3*y1 - x1*y1d)*w) /(2*x1*(1 - w));
        end if;

        /* Modify derivative y0d, such that the polynomial is
           monotonically increasing. A sufficient condition is
             0 &lt;= y0d &lt;= sqrt(5)*k_i*|x_i|
        */
        w1 :=sqrt(5)*k1*x1;
        w2 :=sqrt(5)*k2*abs(x2);
        // y0d :=min(y0d, 0.9*min(w1, w2));
        ww :=0.9*(if w1 &lt; w2 then w1 else w2);
        if ww &lt; y0d then
           y0d :=ww;
        end if;
        y := if x &gt;= 0 then evaluatePoly3_derivativeAtZero(x,x1,y1,y1d,y0d) else 
                            evaluatePoly3_derivativeAtZero(x,x2,y2,y2d,y0d);
     end if;
  end regSquare2_utility;
algorithm 
  y := smooth(2,if x &gt;= x_small then k1*x^2 else 
                if x &lt;= -x_small then -k2*x^2 else 
                if k1 &gt;= k2 then regSquare2_utility(x,x_small,k1,k2,use_yd0,yd0) else 
                                -regSquare2_utility(-x,x_small,k2,k1,use_yd0,yd0));
end regSquare2;</code></pre>
<hr />
<h1 id="image31-modelica.fluid.utilities.regstep"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image31" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regStep</h1>
<p><strong>Approximation of a general step, such that the characteristic is continuous and differentiable</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<p>This function is used to approximate the equation</p>
<pre><code>y = if x &gt; 0 then y1 else y2;</code></pre>
<p>by a smooth characteristic, so that the expression is continuous and differentiable:</p>
<pre><code>y = smooth(1, if x &gt;  x_small then y1 else
              if x &lt; -x_small then y2 else f(y1, y2));</code></pre>
<p>In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used for a smooth transition from y1 to y2.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-7">Inputs</h2>
<table>
<col width="7%" />
<col width="11%" />
<col width="10%" />
<col width="70%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">Abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y1</td>
<td align="left">
</td>
<td align="left">Ordinate value for x &gt; 0</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y2</td>
<td align="left">
</td>
<td align="left">Ordinate value for x &lt; 0</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">x_small</td>
<td align="left">1e-5</td>
<td align="left">Approximation of step for -x_small &lt;= x &lt;= x_small; x_small &gt;= 0 required</td>
</tr>
</tbody>
</table>
<h2 id="outputs-6">Outputs</h2>
<table>
<col width="11%" />
<col width="11%" />
<col width="77%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">Ordinate value to approximate y = if x &gt; 0 then y1 else y2</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>function regStep 
  &quot;Approximation of a general step, such that the characteristic is continuous and differentiable&quot;
  extends Modelica.Icons.Function;
  input Real x &quot;Abscissa value&quot;;
  input Real y1 &quot;Ordinate value for x &gt; 0&quot;;
  input Real y2 &quot;Ordinate value for x &lt; 0&quot;;
  input Real x_small(min=0) = 1e-5 
    &quot;Approximation of step for -x_small &lt;= x &lt;= x_small; x_small &gt;= 0 required&quot;;
  output Real y &quot;Ordinate value to approximate y = if x &gt; 0 then y1 else y2&quot;;
algorithm 
  y := smooth(1, if x &gt;  x_small then y1 else 
                 if x &lt; -x_small then y2 else 
                 if x_small &gt; 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
end regStep;</code></pre>
<hr />
<h1 id="image32-modelica.fluid.utilities.evaluatepoly3_derivativeatzero"><img src="Modelica.Fluid.Utilities.checkBoundaryI.png" alt="image32" /> <a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.evaluatePoly3_derivativeAtZero</h1>
<p><strong>Evaluate polynomial of order 3 that passes the origin with a predefined derivative</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-8">Inputs</h2>
<table>
<col width="11%" />
<col width="11%" />
<col width="15%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">Value for which polynomial shall be evaluated</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">x1</td>
<td align="left">
</td>
<td align="left">Abscissa value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y1</td>
<td align="left">
</td>
<td align="left">y1=f(x1)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y1d</td>
<td align="left">
</td>
<td align="left">First derivative at y1</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y0d</td>
<td align="left">
</td>
<td align="left">First derivative at f(x=0)</td>
</tr>
</tbody>
</table>
<h2 id="outputs-7">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>function evaluatePoly3_derivativeAtZero 
  &quot;Evaluate polynomial of order 3 that passes the origin with a predefined derivative&quot;
  extends Modelica.Icons.Function;
  input Real x &quot;Value for which polynomial shall be evaluated&quot;;
  input Real x1 &quot;Abscissa value&quot;;
  input Real y1 &quot;y1=f(x1)&quot;;
  input Real y1d &quot;First derivative at y1&quot;;
  input Real y0d &quot;First derivative at f(x=0)&quot;;
  output Real y;
protected 
  Real a1;
  Real a2;
  Real a3;
  Real xx;
algorithm 
  a1 := x1*y0d;
  a2 := 3*y1 - x1*y1d - 2*a1;
  a3 := y1 - a2 - a1;
  xx := x/x1;
  y  := xx*(a1 + xx*(a2 + xx*a3));
end evaluatePoly3_derivativeAtZero;</code></pre>
<hr />
<h1 id="modelica.fluid.utilities.regfun3"><a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.regFun3</h1>
<p><strong>Co-monotonic and C1 smooth regularization function</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<p>Approximates a function in a region between <code>x0</code> and <code>x1</code> such that</p>
<ul>
<li>The overall function is continuous with a continuous first derivative everywhere.</li>
<li>The function is co-monotone with the given data points.</li>
</ul>
<p>In this region, a continuation is constructed from the given points <code>(x0, y0)</code>, <code>(x1, y1)</code> and the respective derivatives. For this purpose, a single polynomial of third order or two cubic polynomials with a linear section in between are used <em>[Gasparo and Morandi, 1991]</em>. This algorithm was extended with two additional conditions to avoid saddle points with zero/infinite derivative that lead to integrator step size reduction to zero.</p>
<p>This function was developed for pressure loss correlations properly addressing the static head on top of the established requirements for monotonicity and smoothness. In this case, the present function allows to implement the exact solution in the limit of <code>x1-x0 -&gt; 0</code> or <code>y1-y0 -&gt; 0</code>.</p>
<p>Typical screenshots for two different configurations are shown below. The first one illustrates five different settings of <code>xi</code> and <code>yid</code>:</p>
<p>The second graph shows the continous derivative of this regularization function:</p>
<p><strong>Literature</strong></p>
<blockquote>
<dl>
<dt>Gasparo M. G. and Morandi R. (1991):</dt>
<dd><p><strong>Piecewise cubic monotone interpolation with assigned slopes</strong>. Computing, Vol. 46, Issue 4, December 1991, pp. 355 - 365.</p>
</dd>
</dl>
</blockquote>
<p>::</p>
<h2 id="inputs-9">Inputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="16%" />
<col width="58%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">Abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">x0</td>
<td align="left">
</td>
<td align="left">Lower abscissa value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x1</td>
<td align="left">
</td>
<td align="left">Upper abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y0</td>
<td align="left">
</td>
<td align="left">Ordinate value at lower ordinate value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y1</td>
<td align="left">
</td>
<td align="left">Ordinate value at upper ordinate value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y0d</td>
<td align="left">
</td>
<td align="left">Derivative at lower abscissa value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y1d</td>
<td align="left">
</td>
<td align="left">Derivative at upper abscissa value</td>
</tr>
</tbody>
</table>
<h2 id="outputs-8">Outputs</h2>
<table>
<col width="6%" />
<col width="6%" />
<col width="86%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">Ordinate value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c</td>
<td align="left">Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>function regFun3 &quot;Co-monotonic and C1 smooth regularization function&quot;

  input Real x &quot;Abscissa value&quot;;
  input Real x0 &quot;Lower abscissa value&quot;;
  input Real x1 &quot;Upper abscissa value&quot;;
  input Real y0 &quot;Ordinate value at lower ordinate value&quot;;
  input Real y1 &quot;Ordinate value at upper ordinate value&quot;;
  input Real y0d &quot;Derivative at lower abscissa value&quot;;
  input Real y1d &quot;Derivative at upper abscissa value&quot;;

  output Real y &quot;Ordinate value&quot;;
  output Real c 
    &quot;Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used&quot;;

protected 
  Real h0 &quot;Width of interval i=0&quot;;
  Real Delta0 &quot;Slope of secant on interval i=0&quot;;
  Real xstar &quot;Inflection point of cubic polynomial S0&quot;;
  Real mu &quot;Distance of inflection point and left limit x0&quot;;
  Real eta &quot;Distance of right limit x1 and inflection point&quot;;
  Real omega &quot;Slope of subic polynomial S0 at inflection point&quot;;
  Real rho &quot;Weighting factor of eta and eta_tilde, mu and mu_tilde&quot;;
  Real theta0 &quot;Slope metric&quot;;
  Real mu_tilde &quot;Distance of start of linear section and left limit x0&quot;;
  Real eta_tilde &quot;Distance of right limit x1 and end of linear section&quot;;
  Real xi1 &quot;Start of linear section &quot;;
  Real xi2 &quot;End of linear section &quot;;
  Real a1 &quot;Leading coefficient of cubic on the left&quot;;
  Real a2 &quot;Leading coefficient of cubic on the right&quot;;
  Real const12 &quot;Integration constant of left cubic, linear section&quot;;
  Real const3 &quot;Integration constant of right cubic&quot;;
  Real aux01;
  Real aux02;
  Boolean useSingleCubicPolynomial = false 
    &quot;Indicate to override further logic and use single cubic&quot;;
algorithm 
  assert(x0&lt;x1, &quot;regFun3(): Data points not sorted appropriately (x0 = &quot;+String(x0)+&quot; &gt; x1 = &quot;+String(x1)+&quot;). Please flip arguments.&quot;);

  h0 :=x1 - x0;
  Delta0 :=(y1 - y0)/h0;

  if abs(Delta0)&lt;=0 then
    // Points (x0,y0) and (x1,y1) on horizonzal line
    // Degenerate case as we cannot fulfill the C1 goal an comonotone behaviour at the same time
    y := y0; // == y1
  else
    // Points (x0,y0) and (x1,y1) not on horizonzal line
    if abs(y1d+y0d-2*Delta0)&lt;100*Modelica.Constants.eps then
      xstar := (x1-x0)*(2*y0d+y1d-3*Delta0)*(if (y0d+y1d-2*Delta0)&gt;=0 then 1 else -1)*Modelica.Constants.inf;
    else
      xstar :=1/3*(-3*x0*y0d - 3*x0*y1d + 6*x0*Delta0 - 2*h0*y0d - h0*y1d + 3*h0*
        Delta0)/(-y0d - y1d + 2*Delta0);
    end if;
    mu :=xstar - x0;
    eta :=x1 - xstar;
    omega :=3*(y0d + y1d - 2*Delta0)*(xstar - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*
      Delta0)*(xstar - x0)/h0 + y0d;

    aux01 := 0.25 * sign(Delta0) * min(abs(omega), abs(Delta0)) 
      &quot;Slope c if not using plain cubic S0&quot;;
    if abs(y0d-y1d)&lt;=100*Modelica.Constants.eps then
      // y0 == y1 (value and sign equal) -&gt; resolve indefinite 0/0
      aux02 := y0d;
      if y1 &gt; y0 + y0d*(x1-x0) then
        // If y1 is above the linear extension through (x0/y0)
        // with slope y0d (when slopes are identical)
        //  -&gt; then always used single cubic polynomial
        useSingleCubicPolynomial := true;
      end if;
    elseif abs(y1d+y0d-2*Delta0)&lt;100*Modelica.Constants.eps then
      // (y1d+y0d-2*Delta0) approximately 0 -&gt; avoid division by 0
      aux02 := (6*Delta0*(y1d+y0d-3/2*Delta0)-y1d*y0d-y1d^2-y0d^2)*(if (y1d+y0d-2*Delta0)&gt;=0 then 1 else -1)*Modelica.Constants.inf;
    else
      // Okay, no guarding necessary
      aux02 := (6*Delta0*(y1d+y0d-3/2*Delta0)-y1d*y0d-y1d^2-y0d^2)/(3*(y1d+y0d-2*Delta0));
    end if;

    //aux02 := -1/3*(y0d^2+y0d*y1d-6*y0d*Delta0+y1d^2-6*y1d*Delta0+9*Delta0^2)/(y0d+y1d-2*Delta0);
    //aux02 := -1/3*(6*y1d*y0*x1+y0d*y1d*x1^2-6*y0d*x0*y0+y0d^2*x0^2+y0d^2*x1^2+y1d^2*x1^2+y1d^2*x0^2-2*y0d*x0*y1d*x1-2*x0*y0d^2*x1+y0d*y1d*x0^2+6*y0d*x0*y1-6*y0d*y1*x1+6*y0d*y0*x1-2*x0*y1d^2*x1-6*y1d*y1*x1+6*y1d*x0*y1-6*y1d*x0*y0-18*y1*y0+9*y1^2+9*y0^2)/(y0d*x1^2-2*x0*y0d*x1+y1d*x1^2-2*x0*y1d*x1-2*y1*x1+2*y0*x1+y0d*x0^2+y1d*x0^2+2*x0*y1-2*x0*y0);

    // Test criteria (also used to avoid saddle points that lead to integrator contraction):
    //
    //  1. Cubic is not monotonic (from Gasparo Morandi)
    //       ((mu &gt; 0) and (eta &lt; h0) and (Delta0*omega &lt;= 0))
    //
    //  2. Cubic may be monotonic but the linear section slope c is either too close
    //     to zero or the end point of the linear section is left of the start point
    //     Note however, that the suggested slope has to have the same sign as Delta0.
    //       (abs(aux01)&lt;abs(aux02) and aux02*Delta0&gt;=0)
    //
    //  3. Cubic may be monotonic but the resulting slope in the linear section
    //     is too close to zero (less than 1/10 of Delta0).
    //       (c &lt; Delta0 / 10)
    //
    if (((mu &gt; 0) and (eta &lt; h0) and (Delta0*omega &lt;= 0))
        or (abs(aux01)&lt;abs(aux02) and aux02*Delta0&gt;=0)
        or (abs(aux01)&lt;abs(0.1*Delta0))) and not useSingleCubicPolynomial then
      // NOT monotonic using plain cubic S0, use piecewise function S0 tilde instead
      c := aux01;
      // Avoid saddle points that are co-monotonic but lead to integrator contraction
      if abs(c)&lt;abs(aux02) and aux02*Delta0&gt;=0 then
        c := aux02;
      end if;
      if abs(c)&lt;abs(0.1*Delta0) then
        c := 0.1*Delta0;
      end if;
      theta0 := (y0d*mu + y1d*eta)/h0;
      if abs(theta0 - c)&lt;1e-6 then
        // Slightly reduce c in order to avoid ill-posed problem
        c := (1-1e-6)*theta0;
      end if;
      rho := 3*(Delta0 - c)/(theta0 - c);
      mu_tilde := rho * mu;
      eta_tilde := rho * eta;
      xi1 := x0 + mu_tilde;
      xi2 := x1 - eta_tilde;
      a1 := (y0d - c)/max(mu_tilde^2, 100*Modelica.Constants.eps);
      a2 := (y1d - c)/max(eta_tilde^2, 100*Modelica.Constants.eps);
      const12 := y0 - a1/3*(x0 - xi1)^3 - c*x0;
      const3 := y1 - a2/3*(x1 - xi2)^3 - c*x1;
      // Do actual interpolation
      if (x &lt; xi1) then
        y := a1/3*(x - xi1)^3 + c*x + const12;
      elseif (x &lt; xi2) then
        y := c*x + const12;
      else
        y := a2/3*(x - xi2)^3 + c*x + const3;
      end if;
    else
      // Cubic S0 is monotonic, use it as is
      y := (y0d+y1d-2*Delta0)*(x-x0)^3/h0^2+(-2*y0d-y1d+3*Delta0)*(x-x0)^2/h0+y0d*(x-x0)+y0;
      // Provide a &quot;dummy linear section slope&quot; as the slope of the cubic at x:=(x0+x1)/2
      aux01 := (x0+x1)/2;
      c := 3*(y0d+y1d-2*Delta0)*(aux01-x0)^2/h0^2+2*(-2*y0d-y1d+3*Delta0)*(aux01-x0)/h0+y0d;
    end if;
  end if;

end regFun3;</code></pre>
<hr />
<h1 id="modelica.fluid.utilities.cubichermite"><a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.cubicHermite</h1>
<p><strong>Evaluate a cubic Hermite spline</strong></p>
<h2 id="inputs-10">Inputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="16%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">Abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">x1</td>
<td align="left">
</td>
<td align="left">Lower abscissa value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x2</td>
<td align="left">
</td>
<td align="left">Upper abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y1</td>
<td align="left">
</td>
<td align="left">Lower ordinate value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y2</td>
<td align="left">
</td>
<td align="left">Upper ordinate value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y1d</td>
<td align="left">
</td>
<td align="left">Lower gradient</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y2d</td>
<td align="left">
</td>
<td align="left">Upper gradient</td>
</tr>
</tbody>
</table>
<h2 id="outputs-9">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="44%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">Interpolated ordinate value</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>function cubicHermite &quot;Evaluate a cubic Hermite spline&quot;
  input Real x &quot;Abscissa value&quot;;
  input Real x1 &quot;Lower abscissa value&quot;;
  input Real x2 &quot;Upper abscissa value&quot;;
  input Real y1 &quot;Lower ordinate value&quot;;
  input Real y2 &quot;Upper ordinate value&quot;;
  input Real y1d &quot;Lower gradient&quot;;
  input Real y2d &quot;Upper gradient&quot;;
  output Real y &quot;Interpolated ordinate value&quot;;
protected 
  Real h &quot;Distance between x1 and x2&quot;;
  Real t &quot;abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]&quot;;
  Real h00 &quot;Basis function 00 of cubic Hermite spline&quot;;
  Real h10 &quot;Basis function 10 of cubic Hermite spline&quot;;
  Real h01 &quot;Basis function 01 of cubic Hermite spline&quot;;
  Real h11 &quot;Basis function 11 of cubic Hermite spline&quot;;
  Real aux3 &quot;t cube&quot;;
  Real aux2 &quot;t square&quot;;
algorithm 
  h := x2 - x1;
  if abs(h)&gt;0 then
    // Regular case
    t := (x - x1)/h;

    aux3 :=t^3;
    aux2 :=t^2;

    h00 := 2*aux3 - 3*aux2 + 1;
    h10 := aux3 - 2*aux2 + t;
    h01 := -2*aux3 + 3*aux2;
    h11 := aux3 - aux2;
    y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
  else
    // Degenerate case, x1 and x2 are identical, return step function
    y := (y1 + y2)/2;
  end if;
end cubicHermite;</code></pre>
<hr />
<h1 id="modelica.fluid.utilities.cubichermite_withderivative"><a href="Modelica_Fluid_Utilities.html#Modelica.Fluid.Utilities">Modelica.Fluid.Utilities</a>.cubicHermite_withDerivative</h1>
<p><strong>Evaluate a cubic Hermite spline, return value and derivative</strong></p>
<h2 id="inputs-11">Inputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="16%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x</td>
<td align="left">
</td>
<td align="left">Abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">x1</td>
<td align="left">
</td>
<td align="left">Lower abscissa value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x2</td>
<td align="left">
</td>
<td align="left">Upper abscissa value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y1</td>
<td align="left">
</td>
<td align="left">Lower ordinate value</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y2</td>
<td align="left">
</td>
<td align="left">Upper ordinate value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y1d</td>
<td align="left">
</td>
<td align="left">Lower gradient</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y2d</td>
<td align="left">
</td>
<td align="left">Upper gradient</td>
</tr>
</tbody>
</table>
<h2 id="outputs-10">Outputs</h2>
<table>
<col width="12%" />
<col width="15%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">y</td>
<td align="left">Interpolated ordinate value</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">dy_dx</td>
<td align="left">Derivative dy/dx at abscissa value x</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>function cubicHermite_withDerivative 
  &quot;Evaluate a cubic Hermite spline, return value and derivative&quot;
  input Real x &quot;Abscissa value&quot;;
  input Real x1 &quot;Lower abscissa value&quot;;
  input Real x2 &quot;Upper abscissa value&quot;;
  input Real y1 &quot;Lower ordinate value&quot;;
  input Real y2 &quot;Upper ordinate value&quot;;
  input Real y1d &quot;Lower gradient&quot;;
  input Real y2d &quot;Upper gradient&quot;;
  output Real y &quot;Interpolated ordinate value&quot;;
  output Real dy_dx &quot;Derivative dy/dx at abscissa value x&quot;;
protected 
  Real h &quot;Distance between x1 and x2&quot;;
  Real t &quot;abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]&quot;;
  Real h00 &quot;Basis function 00 of cubic Hermite spline&quot;;
  Real h10 &quot;Basis function 10 of cubic Hermite spline&quot;;
  Real h01 &quot;Basis function 01 of cubic Hermite spline&quot;;
  Real h11 &quot;Basis function 11 of cubic Hermite spline&quot;;

  Real h00d &quot;d/dt h00&quot;;
  Real h10d &quot;d/dt h10&quot;;
  Real h01d &quot;d/dt h01&quot;;
  Real h11d &quot;d/dt h11&quot;;

  Real aux3 &quot;t cube&quot;;
  Real aux2 &quot;t square&quot;;
algorithm 
  h := x2 - x1;
  if abs(h)&gt;0 then
    // Regular case
    t := (x - x1)/h;

    aux3 :=t^3;
    aux2 :=t^2;

    h00 := 2*aux3 - 3*aux2 + 1;
    h10 := aux3 - 2*aux2 + t;
    h01 := -2*aux3 + 3*aux2;
    h11 := aux3 - aux2;

    h00d := 6*(aux2 - t);
    h10d := 3*aux2 - 4*t + 1;
    h01d := 6*(t - aux2);
    h11d := 3*aux2 - 2*t;

    y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
    dy_dx := y1*h00d/h + y1d*h10d + y2*h01d/h + y2d*h11d;
  else
    // Degenerate case, x1 and x2 are identical, return step function
    y := (y1 + y2)/2;
    dy_dx := sign(y2 - y1)*Modelica.Constants.inf;
  end if;
end cubicHermite_withDerivative;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:31:25 2010.</p>
</body>
</html>
