<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Mechanics.Rotational.Components</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Mechanics.Rotational.Components</h1>
</div>
<h1 id="modelica.mechanics.rotational.components"><a href="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational">Modelica.Mechanics.Rotational</a>.Components</h1>
<p><strong>Components for 1D rotational mechanical drive trains</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>This package contains basic components 1D mechanical rotational drive trains.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="59%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.FixedS.png" alt="image19" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Fixed">Fixed</a></td>
<td align="left">Flange fixed in housing at a given angle</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.InertiaS.png" alt="image20" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Inertia">Inertia</a></td>
<td align="left">1D-rotational component with inertia</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.DiscS.png" alt="image21" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Disc">Disc</a></td>
<td align="left">1-dim. rotational rigid component without inertia, where right flange is rotated by a fixed angle with respect to left flange</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.SpringS.png" alt="image22" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Spring">Spring</a></td>
<td align="left">Linear 1D rotational spring</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.DamperS.png" alt="image23" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Damper">Damper</a></td>
<td align="left">Linear 1D rotational damper</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.SpringDamperS.png" alt="image24" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.SpringDamper">SpringDamper</a></td>
<td align="left">Linear 1D rotational spring and damper in parallel</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.ElastoBacklashS.png" alt="image25" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.ElastoBacklash">ElastoBacklash</a></td>
<td align="left">Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.BearingFrictionS.png" alt="image26" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.BearingFriction">BearingFriction</a></td>
<td align="left">Coulomb friction in bearings</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.BrakeS.png" alt="image27" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Brake">Brake</a></td>
<td align="left">Brake based on Coulomb friction</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.ClutchS.png" alt="image28" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Clutch">Clutch</a></td>
<td align="left">Clutch based on Coulomb friction</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.OneWayClutchS.png" alt="image29" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.OneWayClutch">OneWayClutch</a></td>
<td align="left">Series connection of freewheel and clutch</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.IdealGearS.png" alt="image30" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.IdealGear">IdealGear</a></td>
<td align="left">Ideal gear without inertia</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.LossyGearS.png" alt="image31" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.LossyGear">LossyGear</a></td>
<td align="left">Gear with mesh efficiency and bearing friction (stuck/rolling possible)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.IdealPlanetaryS.png" alt="image32" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.IdealPlanetary">IdealPlanetary</a></td>
<td align="left">Ideal planetary gear box</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.GearboxS.png" alt="image33" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Gearbox">Gearbox</a></td>
<td align="left">Realistic model of a gearbox (based on LossyGear)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.IdealGearR2TS.png" alt="image34" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.IdealGearR2T">IdealGearR2T</a></td>
<td align="left">Gearbox transforming rotational into translational motion</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.IdealRollingWheelS.png" alt="image35" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.IdealRollingWheel">IdealRollingWheel</a></td>
<td align="left">Simple 1-dim. model of an ideal rolling wheel without inertia</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.InitializeFlangeS.png" alt="image36" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.InitializeFlange">InitializeFlange</a></td>
<td align="left">Initializes a flange with pre-defined angle, speed and angular acceleration (usually, this is reference data from a control bus)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.Rotational.Components.RelativeStatesS.png" alt="image37" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.RelativeStates">RelativeStates</a></td>
<td align="left">Definition of relative state variables</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image38-modelica.mechanics.rotational.components.fixed"><img src="Modelica.Mechanics.Rotational.Components.FixedI.png" alt="image38" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Fixed</h1>
<p><strong>Flange fixed in housing at a given angle</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>The <strong>flange</strong> of a 1D rotational mechanical system is <strong>fixed</strong> at an angle phi0 in the <strong>housing</strong>. May be used:</p>
<ul>
<li>to connect a compliant element, such as a spring or a damper, between an inertia or gearbox component and the housing.</li>
<li>to fix a rigid element, such as an inertia, with a specific angle to the housing.</li>
</ul>
<p>::</p>
<h2 id="parameters">Parameters</h2>
<table>
<col width="49%" />
<col width="7%" />
<col width="9%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi0</td>
<td align="left">0</td>
<td align="left">Fixed offset angle of housing [rad]</td>
</tr>
</tbody>
</table>
<h2 id="connectors">Connectors</h2>
<table>
<col width="70%" />
<col width="6%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange</td>
<td align="left">(right) flange fixed in housing</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>model Fixed &quot;Flange fixed in housing at a given angle&quot;
  parameter SI.Angle phi0=0 &quot;Fixed offset angle of housing&quot;;

  Interfaces.Flange_b flange &quot;(right) flange fixed in housing&quot;;

equation 
  flange.phi = phi0;
end Fixed;</code></pre>
<hr />
<h1 id="image39-modelica.mechanics.rotational.components.inertia"><img src="Modelica.Mechanics.Rotational.Components.InertiaI.png" alt="image39" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Inertia</h1>
<p><strong>1D-rotational component with inertia</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>Rotational component with <strong>inertia</strong> and two rigidly connected flanges.</p>
<p>::</p>
<h2 id="parameters-1">Parameters</h2>
<table>
<col width="45%" />
<col width="8%" />
<col width="12%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">J</td>
<td align="left">
</td>
<td align="left">Moment of inertia [kg.m2]</td>
</tr>
<tr class="even">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi.start</td>
<td align="left">
</td>
<td align="left">Absolute rotation angle of component [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w.start</td>
<td align="left">
</td>
<td align="left">Absolute angular velocity of component (= der(phi)) [rad/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">a.start</td>
<td align="left">
</td>
<td align="left">Absolute angular acceleration of component (= der(w)) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.default</td>
<td align="left">Priority to use phi and w as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-1">Connectors</h2>
<table>
<col width="74%" />
<col width="9%" />
<col width="16%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Left flange of shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Right flange of shaft</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>model Inertia &quot;1D-rotational component with inertia&quot;
  import SI = Modelica.SIunits;
  Rotational.Interfaces.Flange_a flange_a &quot;Left flange of shaft&quot;;
  Rotational.Interfaces.Flange_b flange_b &quot;Right flange of shaft&quot;;
  parameter SI.Inertia J(min=0, start=1) &quot;Moment of inertia&quot;;
  parameter StateSelect stateSelect=StateSelect.default 
    &quot;Priority to use phi and w as states&quot;;
  SI.Angle phi(stateSelect=stateSelect) &quot;Absolute rotation angle of component&quot;;
  SI.AngularVelocity w(stateSelect=stateSelect) 
    &quot;Absolute angular velocity of component (= der(phi))&quot;;
  SI.AngularAcceleration a 
    &quot;Absolute angular acceleration of component (= der(w))&quot;;

equation 
  phi = flange_a.phi;
  phi = flange_b.phi;
  w = der(phi);
  a = der(w);
  J*a = flange_a.tau + flange_b.tau;
end Inertia;</code></pre>
<hr />
<h1 id="image40-modelica.mechanics.rotational.components.disc"><img src="Modelica.Mechanics.Rotational.Components.DiscI.png" alt="image40" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Disc</h1>
<p><strong>1-dim. rotational rigid component without inertia, where right flange is rotated by a fixed angle with respect to left flange</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>Rotational component with two rigidly connected flanges without <strong>inertia</strong>. The right flange is rotated by the fixed angle &quot;deltaPhi&quot; with respect to the left flange.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges">Rotational.Interfaces.PartialTwoFlanges</a> (Partial model for a component with two rotational 1-dim. shaft flanges).</p>
<h2 id="parameters-2">Parameters</h2>
<table>
<col width="31%" />
<col width="6%" />
<col width="6%" />
<col width="54%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">deltaPhi</td>
<td align="left">0</td>
<td align="left">Fixed rotation of left flange with respect to right flange (= flange_b.phi - flange_a.phi) [rad]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-2">Connectors</h2>
<table>
<col width="74%" />
<col width="9%" />
<col width="16%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>model Disc 
  &quot;1-dim. rotational rigid component without inertia, where right flange is rotated by a fixed angle with respect to left flange&quot;
  import SI = Modelica.SIunits;
  extends Rotational.Interfaces.PartialTwoFlanges;
  parameter SI.Angle deltaPhi=0 
    &quot;Fixed rotation of left flange with respect to right flange (= flange_b.phi - flange_a.phi)&quot;;
  SI.Angle phi &quot;Absolute rotation angle of component&quot;;

equation 
  flange_a.phi = phi - deltaPhi/2;
  flange_b.phi = phi + deltaPhi/2;
  0 = flange_a.tau + flange_b.tau;
end Disc;</code></pre>
<hr />
<h1 id="image41-modelica.mechanics.rotational.components.spring"><img src="Modelica.Mechanics.Rotational.Components.SpringI.png" alt="image41" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Spring</h1>
<p><strong>Linear 1D rotational spring</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>A <strong>linear 1D rotational spring</strong>. The component can be connected either between two inertias/gears to describe the shaft elasticity, or between a inertia/gear and the housing (component Fixed), to describe a coupling of the element with the housing via a spring.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialCompliant">Modelica.Mechanics.Rotational.Interfaces.PartialCompliant</a> (Partial model for the compliant connection of two rotational 1-dim. shaft flanges).</p>
<h2 id="parameters-3">Parameters</h2>
<table>
<col width="49%" />
<col width="9%" />
<col width="6%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalSpringConstant">RotationalSpringConstant</a></td>
<td align="left">c</td>
<td align="left">
</td>
<td align="left">Spring constant [N.m/rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel0</td>
<td align="left">0</td>
<td align="left">Unstretched spring angle [rad]</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel.start</td>
<td align="left">0</td>
<td align="left">Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-3">Connectors</h2>
<table>
<col width="61%" />
<col width="7%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Left flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Right flange of compliant 1-dim. rotational component</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>model Spring &quot;Linear 1D rotational spring&quot;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialCompliant;
  parameter SI.RotationalSpringConstant c(final min=0, start=1.0e5) 
    &quot;Spring constant&quot;;
  parameter SI.Angle phi_rel0=0 &quot;Unstretched spring angle&quot;;

equation 
  tau = c*(phi_rel - phi_rel0);
end Spring;</code></pre>
<hr />
<h1 id="image42-modelica.mechanics.rotational.components.damper"><img src="Modelica.Mechanics.Rotational.Components.DamperI.png" alt="image42" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Damper</h1>
<p><strong>Linear 1D rotational damper</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p><strong>Linear, velocity dependent damper</strong> element. It can be either connected between an inertia or gear and the housing (component Fixed), or between two inertia/gear elements.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates">Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates</a> (Partial model for the compliant connection of two rotational 1-dim. shaft flanges where the relative angle and speed are used as preferred states), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-4">Parameters</h2>
<table>
<col width="47%" />
<col width="9%" />
<col width="10%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalDampingConstant">RotationalDampingConstant</a></td>
<td align="left">d</td>
<td align="left">
</td>
<td align="left">Damping constant [N.m.s/rad]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel.start</td>
<td align="left">0</td>
<td align="left">Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity (= der(phi_rel)) [rad/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">a_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration (= der(w_rel)) [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_nominal</td>
<td align="left">1e-4</td>
<td align="left">Nominal value of phi_rel (used for scaling) [rad]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use phi_rel and w_rel as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-4">Connectors</h2>
<table>
<col width="56%" />
<col width="6%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Left flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Right flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>model Damper &quot;Linear 1D rotational damper&quot;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;
  parameter SI.RotationalDampingConstant d(final min=0, start=0) 
    &quot;Damping constant&quot;;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
equation 
  tau = d*w_rel;
  lossPower = tau*w_rel;
end Damper;</code></pre>
<hr />
<h1 id="image43-modelica.mechanics.rotational.components.springdamper"><img src="Modelica.Mechanics.Rotational.Components.SpringDamperI.png" alt="image43" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.SpringDamper</h1>
<p><strong>Linear 1D rotational spring and damper in parallel</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p>A <strong>spring</strong> and <strong>damper</strong> element <strong>connected in parallel</strong>. The component can be connected either between two inertias/gears to describe the shaft elasticity and damping, or between an inertia/gear and the housing (component Fixed), to describe a coupling of the element with the housing via a spring/damper.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates">Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates</a> (Partial model for the compliant connection of two rotational 1-dim. shaft flanges where the relative angle and speed are used as preferred states), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-5">Parameters</h2>
<table>
<col width="47%" />
<col width="9%" />
<col width="10%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalSpringConstant">RotationalSpringConstant</a></td>
<td align="left">c</td>
<td align="left">
</td>
<td align="left">Spring constant [N.m/rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalDampingConstant">RotationalDampingConstant</a></td>
<td align="left">d</td>
<td align="left">
</td>
<td align="left">Damping constant [N.m.s/rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel0</td>
<td align="left">0</td>
<td align="left">Unstretched spring angle [rad]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel.start</td>
<td align="left">0</td>
<td align="left">Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity (= der(phi_rel)) [rad/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">a_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration (= der(w_rel)) [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_nominal</td>
<td align="left">1e-4</td>
<td align="left">Nominal value of phi_rel (used for scaling) [rad]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use phi_rel and w_rel as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-5">Connectors</h2>
<table>
<col width="56%" />
<col width="6%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Left flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Right flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>model SpringDamper 
  &quot;Linear 1D rotational spring and damper in parallel&quot;
  import SI = Modelica.SIunits;
  parameter SI.RotationalSpringConstant c(final min=0, start=1.0e5) 
    &quot;Spring constant&quot;;
  parameter SI.RotationalDampingConstant d(final min=0, start=0) 
    &quot;Damping constant&quot;;
  parameter SI.Angle phi_rel0=0 &quot;Unstretched spring angle&quot;;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
protected 
  Modelica.SIunits.Torque tau_c &quot;Spring torque&quot;;
  Modelica.SIunits.Torque tau_d &quot;Damping torque&quot;;
equation 
  tau_c = c*(phi_rel - phi_rel0);
  tau_d = d*w_rel;
  tau = tau_c + tau_d;
  lossPower = tau_d*w_rel;
end SpringDamper;</code></pre>
<hr />
<h1 id="image44-modelica.mechanics.rotational.components.elastobacklash"><img src="Modelica.Mechanics.Rotational.Components.ElastoBacklashI.png" alt="image44" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.ElastoBacklash</h1>
<p><strong>Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p>This element consists of a <strong>backlash</strong> element <strong>connected in series</strong> to a <strong>spring</strong> and <strong>damper</strong> element which are <strong>connected in parallel</strong>. The spring constant shall be non-zero, otherwise the component cannot be used.</p>
<p>In combination with components IdealGear, the ElastoBacklash model can be used to model a gear box with backlash, elasticity and damping.</p>
<p>During initialization, the backlash characteristic is replaced by a continuous approximation in the backlash region, in order to reduce problems during initialization, especially for inverse models.</p>
<p>If the backlash b is smaller as 1e-10 rad (especially, if b=0), then the backlash is ignored and the component reduces to a spring/damper element in parallel.</p>
<p>In the backlash region (-b/2 ≤ flange_b.phi - flange_a.phi - phi_rel0 ≤ b/2) no torque is exerted (flange_b.tau = 0). Outside of this region, contact is present and the contact torque is basically computed with a linear spring/damper characteristic:</p>
<pre><code>desiredContactTorque = c*phi_contact + d*der(phi_contact)

         phi_contact = phi_rel - phi_rel0 - b/2 if phi_rel - phi_rel0 &gt;  b/2
                     = phi_rel - phi_rel0 + b/2 if phi_rel - phi_rel0 &lt; -b/2

         phi_rel     = flange_b.phi - flange_a.phi;</code></pre>
<p>This torque characteristic leads to the following difficulties:</p>
<ol>
<li>If the damper torque becomes larger as the spring torque and with opposite sign, the contact torque would be &quot;pulling/sticking&quot; which is unphysical, since during contact only pushing torques can occur.</li>
<li>When contact occurs with a non-zero relative speed (which is the usual situation), the damping torque has a non-zero value and therefore the contact torque changes discontinuously at phi_rel = phi_rel0. Again, this is not physical because the torque can only change continuously. (Note, this component is not an idealized model where a steep characteristic is approximated by a discontinuity, but it shall model the steep characteristic.)</li>
</ol>
<p>In the literature there are several proposals to fix problem (2). However, there seems to be no proposal to avoid sticking. For this reason, the most simple approach is used in the ElastoBacklash model, to fix both problems by slight changes to the linear spring/damper characteristic:</p>
<pre><code>// Torque characteristic when phi_rel &gt; phi_rel0
if phi_rel - phi_rel0 &lt; b/2 then
   tau_c = 0;          // spring torque
   tau_d = 0;          // damper torque
   flange_b.tau = 0;
else
   tau_c = c*(phi_rel - phi_rel0);    // spring torque
   tau_d = d*der(phi_rel);            // damper torque
   flange_b.tau = if tau_c + tau_d ≤ 0 then 0 else tau_c + min( tau_c, tau_d );
end if;</code></pre>
<p>Note, when sticking would occur (tau_c + tau_d ≤ 0), then the contact torque is explicitly set to zero. The &quot;min(tau_c, tau_d)&quot; part in the if-expression, limits the damping torque when it is pushing. This means that at the start of the contact (phi_rel - phi_rel0 = b/2), the damping torque is zero and is continuous. The effect of both modifications is that the absolute value of the damping torque is always limited by the absolute value of the spring torque: |tau_d| ≤ |tau_c|.</p>
<p>In the next figure, a typical simulation with the ElastoBacklash model is shown (<a href="Modelica_Mechanics_Rotational_Examples.html#Modelica.Mechanics.Rotational.Examples.Backlash">Examples.Backlash</a>) where the different effects are visualized:</p>
<ol>
<li>Curve 1 (elastoBacklash1.tau) is the unmodified contact torque, i.e., the linear spring/damper characteristic. A pulling/sticking torque is present at the end of the contact.</li>
<li>Curve 2 (elastoBacklash2.tau) is the contact torque, where the torque is explicitly set to zero when pulling/sticking occurs. The contact torque is discontinuous at begin of contact.</li>
<li>Curve 3 (elastoBacklash3.tau) is the ElastoBacklash model of this library. No discontinuity and no pulling/sticking occurs.</li>
</ol>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates">Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates</a> (Partial model for the compliant connection of two rotational 1-dim. shaft flanges where the relative angle and speed are used as preferred states), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-6">Parameters</h2>
<table>
<col width="47%" />
<col width="9%" />
<col width="10%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalSpringConstant">RotationalSpringConstant</a></td>
<td align="left">c</td>
<td align="left">
</td>
<td align="left">Spring constant (c &gt; 0 required) [N.m/rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalDampingConstant">RotationalDampingConstant</a></td>
<td align="left">d</td>
<td align="left">
</td>
<td align="left">Damping constant [N.m.s/rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">b</td>
<td align="left">0</td>
<td align="left">Total backlash [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel0</td>
<td align="left">0</td>
<td align="left">Unstretched spring angle [rad]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="even">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel.start</td>
<td align="left">0</td>
<td align="left">Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity (= der(phi_rel)) [rad/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">a_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration (= der(w_rel)) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_nominal</td>
<td align="left">1e-4</td>
<td align="left">Nominal value of phi_rel (used for scaling) [rad]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use phi_rel and w_rel as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-6">Connectors</h2>
<table>
<col width="56%" />
<col width="6%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Left flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Right flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>model ElastoBacklash 
  &quot;Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)&quot;
  import SI = Modelica.SIunits;

  parameter SI.RotationalSpringConstant c(final min=Modelica.Constants.small, start=1.0e5) 
    &quot;Spring constant (c &gt; 0 required)&quot;;
  parameter SI.RotationalDampingConstant d(final min=0, start = 0) 
    &quot;Damping constant&quot;;
  parameter SI.Angle b(final min=0) = 0 &quot;Total backlash&quot;;
  parameter SI.Angle phi_rel0=0 &quot;Unstretched spring angle&quot;;

  extends Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
protected 
  final parameter SI.Angle bMax = b/2 
    &quot;Backlash in range bMin &lt;= phi_rel - phi_rel0 &lt;= bMax&quot;;
  final parameter SI.Angle bMin = -bMax 
    &quot;Backlash in range bMin &lt;= phi_rel - phi_rel0 &lt;= bMax&quot;;
  SI.Torque tau_c;
  SI.Torque tau_d;
  SI.Angle phi_diff =  phi_rel - phi_rel0;

  // A minimum backlash is defined in order to avoid an infinite
  // number of state events if backlash b is set to zero.
  constant SI.Angle bEps = 1e-10 &quot;Minimum backlash&quot;;

equation 
    if initial() then
     /* During initialization the characteristic is modified, in order that
        it is a strict monoton rising function. Otherwise, initialization might
        result in a singular system when the characteristic has to be
        inverted. The characteristic is modified in the range 1.5*bMin &lt;= phi_rel - phi_rel0 &lt;= 1.5 bMax,
        so that in this range a linear characteristic is present that approaches the original
        function continuously at its limits, e.g.,
          original:  tau(1.5*bMax) = c*(phi_diff - bMax)
                                   = c*(0.5*bMax)
          initial :  tau(1.5*bMax) = (c/3)*phi_diff
                                   = (c/3)*(3/2)*bMax
                                   = (c/2)*bMax
     */
     tau_c = if phi_diff &gt; 1.5*bMax then c*(phi_diff - bMax) else 
             if phi_diff &lt; 1.5*bMin then c*(phi_diff - bMin) else (c/3)*phi_diff;
     tau_d = d*w_rel;
     tau   = tau_c + tau_d;
     lossPower = tau_d*w_rel;
  else
 /*
     if abs(b) &lt;= bEps then
        tau_c = c*phi_diff;
        tau_d = d*w_rel;
        tau   = tau_c + tau_d;
     elseif phi_diff &gt; bMax then
        tau_c = c*(phi_diff - bMax);
        tau_d = d*w_rel;
        tau   = smooth(0, noEvent(if tau_c + tau_d &lt;= 0 then 0 else tau_c + min(tau_c,tau_d)));
     elseif phi_diff &lt; bMin then
        tau_c = c*(phi_diff - bMin);
        tau_d = d*w_rel;
        tau   = smooth(0, noEvent(if tau_c + tau_d &gt;= 0 then 0 else tau_c + max(tau_c,tau_d)));
     else
        tau_c = 0;
        tau_d = 0;
        tau   = 0;
     end if;

     This is written in the form below, in order that parameter &quot;b&quot;
     is not evaluated during translation (i.e., in the above form
     it cannot be changed anymore after translation).
   */

     tau_c = if abs(b) &lt;= bEps then c*phi_diff else 
             if phi_diff &gt; bMax then c*(phi_diff - bMax) else 
             if phi_diff &lt; bMin then c*(phi_diff - bMin) else 0;
     tau_d = d*w_rel;
     tau   = if abs(b) &lt;= bEps then tau_c + tau_d else 
               if phi_diff &gt; bMax then 
                  smooth(0, noEvent(if tau_c + tau_d &lt;= 0 then 0 else tau_c + min(tau_c,tau_d))) else 
               if phi_diff &lt; bMin then 
                  smooth(0, noEvent(if tau_c + tau_d &gt;= 0 then 0 else tau_c + max(tau_c,tau_d))) else 0;
     lossPower =  if abs(b) &lt;= bEps then tau_d*w_rel else 
                    if phi_diff &gt; bMax then 
                       smooth(0, noEvent(if tau_c + tau_d &lt;= 0 then 0 else min(tau_c,tau_d)*w_rel)) else 
                    if phi_diff &lt; bMin then 
                       smooth(0, noEvent(if tau_c + tau_d &gt;= 0 then 0 else max(tau_c,tau_d)*w_rel)) else 0;
  end if;
end ElastoBacklash;</code></pre>
<hr />
<h1 id="image45-modelica.mechanics.rotational.components.bearingfriction"><img src="Modelica.Mechanics.Rotational.Components.BearingFrictionI.png" alt="image45" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.BearingFriction</h1>
<p><strong>Coulomb friction in bearings</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<p>This element describes <strong>Coulomb friction</strong> in <strong>bearings</strong>, i.e., a frictional torque acting between a flange and the housing. The positive sliding friction torque &quot;tau&quot; has to be defined by table &quot;tau_pos&quot; as function of the absolute angular velocity &quot;w&quot;. E.g.</p>
<pre><code>w | tau</code></pre>
<blockquote>
<dl>
<dt>---+----- 0 | 0</dt>
<dd><p>1 | 2 2 | 5 3 | 8</p>
</dd>
</dl>
</blockquote>
<p>gives the following table:</p>
<pre><code>tau_pos = [0, 0; 1, 2; 2, 5; 3, 8];</code></pre>
<p>Currently, only linear interpolation in the table is supported. Outside of the table, extrapolation through the last two table entries is used. It is assumed that the negative sliding friction force has the same characteristic with negative values. Friction is modelled in the following way:</p>
<p>When the absolute angular velocity &quot;w&quot; is not zero, the friction torque is a function of w and of a constant normal force. This dependency is defined via table tau_pos and can be determined by measurements, e.g., by driving the gear with constant velocity and measuring the needed motor torque (= friction torque).</p>
<p>When the absolute angular velocity becomes zero, the elements connected by the friction element become stuck, i.e., the absolute angle remains constant. In this phase the friction torque is calculated from a torque balance due to the requirement, that the absolute acceleration shall be zero. The elements begin to slide when the friction torque exceeds a threshold value, called the maximum static friction torque, computed via:</p>
<pre><code>maximum_static_friction = peak * sliding_friction(w=0)  (peak &gt;= 1)</code></pre>
<p>This procedure is implemented in a &quot;clean&quot; way by state events and leads to continuous/discrete systems of equations if friction elements are dynamically coupled which have to be solved by appropriate numerical methods. The method is described in:</p>
<p>Otter M., Elmqvist H., and Mattsson S.E. (1999):</p>
<p><strong>Hybrid Modeling in Modelica based on the Synchronous Data Flow Principle</strong>. CACSD'99, Aug. 22.-26, Hawaii.</p>
<p>More precise friction models take into account the elasticity of the material when the two elements are &quot;stuck&quot;, as well as other effects, like hysteresis. This has the advantage that the friction element can be completely described by a differential equation without events. The drawback is that the system becomes stiff (about 10-20 times slower simulation) and that more material constants have to be supplied which requires more sophisticated identification. For more details, see the following references, especially (Armstrong and Canudas de Witt 1996):</p>
<p>Armstrong B. (1991):</p>
<p><strong>Control of Machines with Friction</strong>. Kluwer Academic Press, Boston MA.</p>
<p>Armstrong B., and Canudas de Wit C. (1996):</p>
<p><strong>Friction Modeling and Compensation.</strong> The Control Handbook, edited by W.S.Levine, CRC Press, pp. 1369-1382.</p>
<p>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):</p>
<p><strong>A new model for control of systems with friction.</strong> IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2">Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2</a> (Partial model for a component with two rotational 1-dim. shaft flanges and a support used for textual modeling, i.e., for elementary models), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialFriction">Rotational.Interfaces.PartialFriction</a> (Partial model of Coulomb friction elements), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-7">Parameters</h2>
<table>
<col width="29%" />
<col width="8%" />
<col width="5%" />
<col width="57%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useSupport</td>
<td align="left">false</td>
<td align="left">= true, if support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">tau_pos[:, 2]</td>
<td align="left">[0, 1]</td>
<td align="left">[w,tau] Positive sliding friction characteristic (w&gt;=0)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">peak</td>
<td align="left">1</td>
<td align="left">peak*tau_pos[1,2] = Maximum friction torque for w==0</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">startForward.start</td>
<td align="left"><strong>false</strong></td>
<td align="left">true, if w_rel=0 and start of forward sliding</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">startBackward.start</td>
<td align="left"><strong>false</strong></td>
<td align="left">true, if w_rel=0 and start of backward sliding</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">locked.start</td>
<td align="left">false</td>
<td align="left">true, if w_rel=0 and not sliding</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_small</td>
<td align="left">1.0e10</td>
<td align="left">Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-7">Connectors</h2>
<table>
<col width="56%" />
<col width="6%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Support">Support</a></td>
<td align="left">support</td>
<td align="left">Support/housing of component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>model BearingFriction &quot;Coulomb friction in bearings &quot;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;

  parameter Real tau_pos[:, 2]=[0, 1] 
    &quot;[w,tau] Positive sliding friction characteristic (w&gt;=0)&quot;;
  parameter Real peak(final min=1) = 1 
    &quot;peak*tau_pos[1,2] = Maximum friction torque for w==0&quot;;

  extends Rotational.Interfaces.PartialFriction;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

  SI.Angle phi &quot;Angle between shaft flanges (flange_a, flange_b) and support&quot;;
  SI.Torque tau &quot;Friction torque&quot;;
  SI.AngularVelocity w &quot;Absolute angular velocity of flange_a and flange_b&quot;;
  SI.AngularAcceleration a 
    &quot;Absolute angular acceleration of flange_a and flange_b&quot;;

equation 
  // Constant auxiliary variables
  tau0 = Modelica.Math.tempInterpol1(0, tau_pos, 2);
  tau0_max = peak*tau0;
  free = false;

  phi = flange_a.phi - phi_support;
  flange_b.phi = flange_a.phi;

  // Angular velocity and angular acceleration of flanges
  w = der(phi);
  a = der(w);
  w_relfric = w;
  a_relfric = a;

  // Friction torque
  flange_a.tau + flange_b.tau - tau = 0;

  // Friction torque
  tau = if locked then sa*unitTorque else 
       (if startForward then         Modelica.Math.tempInterpol1( w, tau_pos, 2) else 
        if startBackward then       -Modelica.Math.tempInterpol1(-w, tau_pos, 2) else 
        if pre(mode) == Forward then Modelica.Math.tempInterpol1( w, tau_pos, 2) else 
                                    -Modelica.Math.tempInterpol1(-w, tau_pos, 2));
  lossPower = tau*w_relfric;
end BearingFriction;</code></pre>
<hr />
<h1 id="image46-modelica.mechanics.rotational.components.brake"><img src="Modelica.Mechanics.Rotational.Components.BrakeI.png" alt="image46" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Brake</h1>
<p><strong>Brake based on Coulomb friction</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<p>This component models a <strong>brake</strong>, i.e., a component where a frictional torque is acting between the housing and a flange and a controlled normal force presses the flange to the housing in order to increase friction. The normal force fn has to be provided as input signal f_normalized in a normalized form (0 ≤ f_normalized ≤ 1), fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the brake is modelled in the following way:</p>
<p>When the absolute angular velocity &quot;w&quot; is not zero, the friction torque is a function of the velocity dependent friction coefficient mue(w) , of the normal force &quot;fn&quot;, and of a geometry constant &quot;cgeo&quot; which takes into account the geometry of the device and the assumptions on the friction distributions:</p>
<pre><code>frictional_torque = cgeo * mue(w) * fn</code></pre>
<p>Typical values of coefficients of friction:</p>
<pre><code>dry operation   :  mue = 0.2 .. 0.4
operating in oil:  mue = 0.05 .. 0.1</code></pre>
<p>When plates are pressed together, where <strong>ri</strong> is the inner radius, <strong>ro</strong> is the outer radius and <strong>N</strong> is the number of friction interfaces, the geometry constant is calculated in the following way under the assumption of a uniform rate of wear at the interfaces:</p>
<pre><code>cgeo = N*(r0 + ri)/2</code></pre>
<p>The positive part of the friction characteristic <strong>mue</strong>(w), w &gt;= 0, is defined via table mue_pos (first column = w, second column = mue). Currently, only linear interpolation in the table is supported.</p>
<p>When the absolute angular velocity becomes zero, the elements connected by the friction element become stuck, i.e., the absolute angle remains constant. In this phase the friction torque is calculated from a torque balance due to the requirement, that the absolute acceleration shall be zero. The elements begin to slide when the friction torque exceeds a threshold value, called the maximum static friction torque, computed via:</p>
<pre><code>frictional_torque = peak * cgeo * mue(w=0) * fn   (peak &gt;= 1)</code></pre>
<p>This procedure is implemented in a &quot;clean&quot; way by state events and leads to continuous/discrete systems of equations if friction elements are dynamically coupled. The method is described in:</p>
<p>Otter M., Elmqvist H., and Mattsson S.E. (1999):</p>
<p><strong>Hybrid Modeling in Modelica based on the Synchronous Data Flow Principle</strong>. CACSD'99, Aug. 22.-26, Hawaii.</p>
<p>More precise friction models take into account the elasticity of the material when the two elements are &quot;stuck&quot;, as well as other effects, like hysteresis. This has the advantage that the friction element can be completely described by a differential equation without events. The drawback is that the system becomes stiff (about 10-20 times slower simulation) and that more material constants have to be supplied which requires more sophisticated identification. For more details, see the following references, especially (Armstrong and Canudas de Witt 1996):</p>
<p>Armstrong B. (1991):</p>
<p><strong>Control of Machines with Friction</strong>. Kluwer Academic Press, Boston MA.</p>
<p>Armstrong B., and Canudas de Wit C. (1996):</p>
<p><strong>Friction Modeling and Compensation.</strong> The Control Handbook, edited by W.S.Levine, CRC Press, pp. 1369-1382.</p>
<p>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):</p>
<p><strong>A new model for control of systems with friction.</strong> IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2">Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2</a> (Partial model for a component with two rotational 1-dim. shaft flanges and a support used for textual modeling, i.e., for elementary models), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialFriction">Rotational.Interfaces.PartialFriction</a> (Partial model of Coulomb friction elements), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-8">Parameters</h2>
<table>
<col width="29%" />
<col width="8%" />
<col width="5%" />
<col width="57%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useSupport</td>
<td align="left">false</td>
<td align="left">= true, if support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">mue_pos[:, 2]</td>
<td align="left">[0, 0.5]</td>
<td align="left">[w,mue] positive sliding friction coefficient (w_rel&gt;=0)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">peak</td>
<td align="left">1</td>
<td align="left">peak*mue_pos[1,2] = maximum value of mue for w_rel==0</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">cgeo</td>
<td align="left">1</td>
<td align="left">Geometry constant containing friction distribution assumption</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Force">Force</a></td>
<td align="left">fn_max</td>
<td align="left">
</td>
<td align="left">Maximum normal force [N]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">startForward.start</td>
<td align="left"><strong>false</strong></td>
<td align="left">true, if w_rel=0 and start of forward sliding</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">startBackward.start</td>
<td align="left"><strong>false</strong></td>
<td align="left">true, if w_rel=0 and start of backward sliding</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">locked.start</td>
<td align="left">false</td>
<td align="left">true, if w_rel=0 and not sliding</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_small</td>
<td align="left">1.0e10</td>
<td align="left">Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-8">Connectors</h2>
<table>
<col width="50%" />
<col width="7%" />
<col width="41%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Support">Support</a></td>
<td align="left">support</td>
<td align="left">Support/housing of component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">f_normalized</td>
<td align="left">Normalized force signal 0..1 (normal force = fn_max*f_normalized; brake is active if &gt; 0)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>model Brake &quot;Brake based on Coulomb friction &quot;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;

  parameter Real mue_pos[:, 2]=[0, 0.5] 
    &quot;[w,mue] positive sliding friction coefficient (w_rel&gt;=0)&quot;;
  parameter Real peak(final min=1) = 1 
    &quot;peak*mue_pos[1,2] = maximum value of mue for w_rel==0&quot;;
  parameter Real cgeo(final min=0) = 1 
    &quot;Geometry constant containing friction distribution assumption&quot;;
  parameter SI.Force fn_max(final min=0, start=1) &quot;Maximum normal force&quot;;

  extends Rotational.Interfaces.PartialFriction;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

  SI.Angle phi &quot;Angle between shaft flanges (flange_a, flange_b) and support&quot;;
  SI.Torque tau &quot;Brake friction torqu&quot;;
  SI.AngularVelocity w &quot;Absolute angular velocity of flange_a and flange_b&quot;;
  SI.AngularAcceleration a 
    &quot;Absolute angular acceleration of flange_a and flange_b&quot;;

  Real mue0 &quot;Friction coefficient for w=0 and forward sliding&quot;;
  SI.Force fn &quot;Normal force (=fn_max*f_normalized)&quot;;

  // Constant auxiliary variable
  Modelica.Blocks.Interfaces.RealInput f_normalized 
    &quot;Normalized force signal 0..1 (normal force = fn_max*f_normalized; brake is active if &gt; 0)&quot;;


equation 
  mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);

  phi = flange_a.phi - phi_support;
  flange_b.phi = flange_a.phi;

  // Angular velocity and angular acceleration of flanges flange_a and flange_b
  w = der(phi);
  a = der(w);
  w_relfric = w;
  a_relfric = a;

  // Friction torque, normal force and friction torque for w_rel=0
  flange_a.tau + flange_b.tau - tau = 0;
  fn = fn_max*f_normalized;
  tau0 = mue0*cgeo*fn;
  tau0_max = peak*tau0;
  free = fn &lt;= 0;

  // Friction torque
  tau = if locked then sa*unitTorque else 
        if free then   0 else 
        cgeo*fn*(if startForward then         Modelica.Math.tempInterpol1( w, mue_pos, 2) else 
                 if startBackward then       -Modelica.Math.tempInterpol1(-w, mue_pos, 2) else 
                 if pre(mode) == Forward then Modelica.Math.tempInterpol1( w, mue_pos, 2) else 
                                             -Modelica.Math.tempInterpol1(-w, mue_pos, 2));
  lossPower = tau*w_relfric;
end Brake;</code></pre>
<hr />
<h1 id="image47-modelica.mechanics.rotational.components.clutch"><img src="Modelica.Mechanics.Rotational.Components.ClutchI.png" alt="image47" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Clutch</h1>
<p><strong>Clutch based on Coulomb friction</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<p>This component models a <strong>clutch</strong>, i.e., a component with two flanges where friction is present between the two flanges and these flanges are pressed together via a normal force. The normal force fn has to be provided as input signal f_normalized in a normalized form (0 ≤ f_normalized ≤ 1), fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the clutch is modelled in the following way:</p>
<p>When the relative angular velocity is not zero, the friction torque is a function of the velocity dependent friction coefficient mue(w_rel) , of the normal force &quot;fn&quot;, and of a geometry constant &quot;cgeo&quot; which takes into account the geometry of the device and the assumptions on the friction distributions:</p>
<pre><code>frictional_torque = cgeo * mue(w_rel) * fn</code></pre>
<p>Typical values of coefficients of friction:</p>
<pre><code>dry operation   :  mue = 0.2 .. 0.4
operating in oil:  mue = 0.05 .. 0.1</code></pre>
<p>When plates are pressed together, where <strong>ri</strong> is the inner radius, <strong>ro</strong> is the outer radius and <strong>N</strong> is the number of friction interfaces, the geometry constant is calculated in the following way under the assumption of a uniform rate of wear at the interfaces:</p>
<pre><code>cgeo = N*(r0 + ri)/2</code></pre>
<p>The positive part of the friction characteristic <strong>mue</strong>(w_rel), w_rel &gt;= 0, is defined via table mue_pos (first column = w_rel, second column = mue). Currently, only linear interpolation in the table is supported.</p>
<p>When the relative angular velocity becomes zero, the elements connected by the friction element become stuck, i.e., the relative angle remains constant. In this phase the friction torque is calculated from a torque balance due to the requirement, that the relative acceleration shall be zero. The elements begin to slide when the friction torque exceeds a threshold value, called the maximum static friction torque, computed via:</p>
<pre><code>frictional_torque = peak * cgeo * mue(w_rel=0) * fn   (peak &gt;= 1)</code></pre>
<p>This procedure is implemented in a &quot;clean&quot; way by state events and leads to continuous/discrete systems of equations if friction elements are dynamically coupled. The method is described in:</p>
<p>Otter M., Elmqvist H., and Mattsson S.E. (1999):</p>
<p><strong>Hybrid Modeling in Modelica based on the Synchronous Data Flow Principle</strong>. CACSD'99, Aug. 22.-26, Hawaii.</p>
<p>More precise friction models take into account the elasticity of the material when the two elements are &quot;stuck&quot;, as well as other effects, like hysteresis. This has the advantage that the friction element can be completely described by a differential equation without events. The drawback is that the system becomes stiff (about 10-20 times slower simulation) and that more material constants have to be supplied which requires more sophisticated identification. For more details, see the following references, especially (Armstrong and Canudas de Witt 1996):</p>
<p>Armstrong B. (1991):</p>
<p><strong>Control of Machines with Friction</strong>. Kluwer Academic Press, Boston MA.</p>
<p>Armstrong B., and Canudas de Wit C. (1996):</p>
<p><strong>Friction Modeling and Compensation.</strong> The Control Handbook, edited by W.S.Levine, CRC Press, pp. 1369-1382.</p>
<p>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):</p>
<p><strong>A new model for control of systems with friction.</strong> IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Icons.html#Modelica.Mechanics.Rotational.Icons.Clutch">Modelica.Mechanics.Rotational.Icons.Clutch</a> (Icon of a clutch), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates">Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates</a> (Partial model for the compliant connection of two rotational 1-dim. shaft flanges where the relative angle and speed are used as preferred states), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialFriction">Rotational.Interfaces.PartialFriction</a> (Partial model of Coulomb friction elements), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-9">Parameters</h2>
<table>
<col width="30%" />
<col width="8%" />
<col width="7%" />
<col width="53%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">mue_pos[:, 2]</td>
<td align="left">[0, 0.5]</td>
<td align="left">[w,mue] positive sliding friction coefficient (w_rel&gt;=0)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">peak</td>
<td align="left">1</td>
<td align="left">peak*mue_pos[1,2] = maximum value of mue for w_rel==0</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cgeo</td>
<td align="left">1</td>
<td align="left">Geometry constant containing friction distribution assumption</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Force">Force</a></td>
<td align="left">fn_max</td>
<td align="left">
</td>
<td align="left">Maximum normal force [N]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="even">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel.start</td>
<td align="left">0</td>
<td align="left">Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity (= der(phi_rel)) [rad/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">a_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration (= der(w_rel)) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">startForward.start</td>
<td align="left"><strong>false</strong></td>
<td align="left">true, if w_rel=0 and start of forward sliding</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">startBackward.start</td>
<td align="left"><strong>false</strong></td>
<td align="left">true, if w_rel=0 and start of backward sliding</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">locked.start</td>
<td align="left">false</td>
<td align="left">true, if w_rel=0 and not sliding</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_nominal</td>
<td align="left">1e-4</td>
<td align="left">Nominal value of phi_rel (used for scaling) [rad]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use phi_rel and w_rel as states</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_small</td>
<td align="left">1.0e10</td>
<td align="left">Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-9">Connectors</h2>
<table>
<col width="50%" />
<col width="7%" />
<col width="41%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Left flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Right flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">f_normalized</td>
<td align="left">Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>model Clutch &quot;Clutch based on Coulomb friction&quot;
  extends Modelica.Mechanics.Rotational.Icons.Clutch;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;

  parameter Real mue_pos[:, 2]=[0, 0.5] 
    &quot;[w,mue] positive sliding friction coefficient (w_rel&gt;=0)&quot;;
  parameter Real peak(final min=1) = 1 
    &quot;peak*mue_pos[1,2] = maximum value of mue for w_rel==0&quot;;
  parameter Real cgeo(final min=0) = 1 
    &quot;Geometry constant containing friction distribution assumption&quot;;
  parameter SI.Force fn_max(final min=0, start=1) &quot;Maximum normal force&quot;;

  Modelica.SIunits.AngularAcceleration a_rel(start=0) 
    &quot;Relative angular acceleration (= der(w_rel))&quot;;
  extends Rotational.Interfaces.PartialFriction;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

  Real mue0 &quot;Friction coefficient for w=0 and forward sliding&quot;;
  SI.Force fn &quot;Normal force (fn=fn_max*f_normalized)&quot;;
  Modelica.Blocks.Interfaces.RealInput f_normalized 
    &quot;Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)&quot;;


equation 
  // Constant auxiliary variable
  mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);

  // Relative quantities
  w_relfric = w_rel;
  a_relfric = a_rel;

  // Normal force and friction torque for w_rel=0
  fn = fn_max*f_normalized;
  free = fn &lt;= 0;
  tau0 = mue0*cgeo*fn;
  tau0_max = peak*tau0;

  // Friction torque
  tau = if locked then sa*unitTorque else 
        if free then   0 else 
        cgeo*fn*(if startForward then         Modelica.Math.tempInterpol1( w_rel, mue_pos, 2) else 
                 if startBackward then       -Modelica.Math.tempInterpol1(-w_rel, mue_pos, 2) else 
                 if pre(mode) == Forward then Modelica.Math.tempInterpol1( w_rel, mue_pos, 2) else 
                                             -Modelica.Math.tempInterpol1(-w_rel, mue_pos, 2));
  lossPower = tau*w_relfric;
end Clutch;</code></pre>
<hr />
<h1 id="image48-modelica.mechanics.rotational.components.onewayclutch"><img src="Modelica.Mechanics.Rotational.Components.OneWayClutchI.png" alt="image48" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.OneWayClutch</h1>
<p><strong>Series connection of freewheel and clutch</strong></p>
<h2 id="information-11">Information</h2>
<p>::</p>
<p>This component models a <strong>one-way clutch</strong>, i.e., a component with two flanges where friction is present between the two flanges and these flanges are pressed together via a normal force. These flanges maybe sliding with respect to each other Parallel connection of ClutchCombi and of FreeWheel. The element is introduced to resolve the ambiguity of the constraint torques of the elements.</p>
<p>A one-way-clutch is an element where a clutch is connected in parallel to a free wheel. This special element is provided, because such a parallel connection introduces an ambiguity into the model (the constraint torques are not uniquely defined when both elements are stuck) and this element resolves it by introducing <strong>one</strong> constraint torque and not two.</p>
<p>Note, initial values have to be chosen for the model, such that the relative speed of the one-way-clutch &gt;= 0. Otherwise, the configuration is physically not possible and an error occurs.</p>
<p>The normal force fn has to be provided as input signal f_normalized in a normalized form (0 ≤ f_normalized ≤ 1), fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the clutch is modelled in the following way:</p>
<p>When the relative angular velocity is positive, the friction torque is a function of the velocity dependent friction coefficient mue(w_rel) , of the normal force &quot;fn&quot;, and of a geometry constant &quot;cgeo&quot; which takes into account the geometry of the device and the assumptions on the friction distributions:</p>
<pre><code>frictional_torque = cgeo * mue(w_rel) * fn</code></pre>
<p>Typical values of coefficients of friction:</p>
<pre><code>dry operation   :  mue = 0.2 .. 0.4
operating in oil:  mue = 0.05 .. 0.1</code></pre>
<p>When plates are pressed together, where <strong>ri</strong> is the inner radius, <strong>ro</strong> is the outer radius and <strong>N</strong> is the number of friction interfaces, the geometry constant is calculated in the following way under the assumption of a uniform rate of wear at the interfaces:</p>
<pre><code>cgeo = N*(r0 + ri)/2</code></pre>
<p>The positive part of the friction characteristic <strong>mue</strong>(w_rel), w_rel &gt;= 0, is defined via table mue_pos (first column = w_rel, second column = mue). Currently, only linear interpolation in the table is supported.</p>
<p>When the relative angular velocity becomes zero, the elements connected by the friction element become stuck, i.e., the relative angle remains constant. In this phase the friction torque is calculated from a torque balance due to the requirement, that the relative acceleration shall be zero. The elements begin to slide when the friction torque exceeds a threshold value, called the maximum static friction torque, computed via:</p>
<pre><code>frictional_torque = peak * cgeo * mue(w_rel=0) * fn   (peak &gt;= 1)</code></pre>
<p>This procedure is implemented in a &quot;clean&quot; way by state events and leads to continuous/discrete systems of equations if friction elements are dynamically coupled. The method is described in:</p>
<p>Otter M., Elmqvist H., and Mattsson S.E. (1999):</p>
<p><strong>Hybrid Modeling in Modelica based on the Synchronous Data Flow Principle</strong>. CACSD'99, Aug. 22.-26, Hawaii.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Icons.html#Modelica.Mechanics.Rotational.Icons.Clutch">Modelica.Mechanics.Rotational.Icons.Clutch</a> (Icon of a clutch), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates">Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates</a> (Partial model for the compliant connection of two rotational 1-dim. shaft flanges where the relative angle and speed are used as preferred states), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-10">Parameters</h2>
<table>
<col width="30%" />
<col width="6%" />
<col width="8%" />
<col width="54%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">mue_pos[:, 2]</td>
<td align="left">[0, 0.5]</td>
<td align="left">[w,mue] positive sliding friction coefficient (w_rel&gt;=0)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">peak</td>
<td align="left">1</td>
<td align="left">peak*mue_pos[1,2] = maximum value of mue for w_rel==0</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cgeo</td>
<td align="left">1</td>
<td align="left">Geometry constant containing friction distribution assumption</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Force">Force</a></td>
<td align="left">fn_max</td>
<td align="left">
</td>
<td align="left">Maximum normal force [N]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
<tr class="even">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_rel.start</td>
<td align="left">0</td>
<td align="left">Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity (= der(phi_rel)) [rad/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">a_rel.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration (= der(w_rel)) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi_nominal</td>
<td align="left">1e-4</td>
<td align="left">Nominal value of phi_rel (used for scaling) [rad]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use phi_rel and w_rel as states</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_small</td>
<td align="left">1e10</td>
<td align="left">Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-10">Connectors</h2>
<table>
<col width="50%" />
<col width="7%" />
<col width="41%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Left flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Right flange of compliant 1-dim. rotational component</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">f_normalized</td>
<td align="left">Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>model OneWayClutch &quot;Series connection of freewheel and clutch&quot;
  extends Modelica.Mechanics.Rotational.Icons.Clutch;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialCompliantWithRelativeStates;

  parameter Real mue_pos[:, 2]=[0, 0.5] 
    &quot;[w,mue] positive sliding friction coefficient (w_rel&gt;=0)&quot;;
  parameter Real peak(final min=1) = 1 
    &quot;peak*mue_pos[1,2] = maximum value of mue for w_rel==0&quot;;
  parameter Real cgeo(final min=0) = 1 
    &quot;Geometry constant containing friction distribution assumption&quot;;
  parameter SI.Force fn_max(final min=0, start=1) &quot;Maximum normal force&quot;;
  parameter SI.AngularVelocity w_small=1e10 
    &quot;Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)&quot;;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;

  Real u &quot;Normalized force input signal (0..1)&quot;;
  SI.Force fn &quot;Normal force (fn=fn_max*inPort.signal)&quot;;
  Boolean startForward(start=false) 
    &quot;true, if w_rel=0 and start of forward sliding or w_rel &gt; w_small&quot;;
  Boolean locked(start=false) &quot;true, if w_rel=0 and not sliding&quot;;
  Boolean stuck(start=false) &quot;w_rel=0 (locked or start forward sliding)&quot;;

protected 
  SI.Torque tau0 &quot;Friction torque for w=0 and sliding&quot;;
  SI.Torque tau0_max &quot;Maximum friction torque for w=0 and locked&quot;;
  Real mue0 &quot;Friction coefficient for w=0 and sliding&quot;;
  Boolean free &quot;true, if frictional element is not active&quot;;
  Real sa(final unit=&quot;1&quot;) 
    &quot;Path parameter of tau = f(a_rel) Friction characteristic&quot;;
  constant Real eps0=1.0e-4 &quot;Relative hysteresis epsilon&quot;;
  SI.Torque tau0_max_low &quot;Lowest value for tau0_max&quot;;
  parameter Real peak2=max([peak, 1 + eps0]);
  constant SI.AngularAcceleration unitAngularAcceleration = 1;
  constant SI.Torque unitTorque = 1;
public 
  Modelica.Blocks.Interfaces.RealInput f_normalized 
    &quot;Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)&quot;;


equation 
  // Constant auxiliary variable
  mue0 = Modelica.Math.tempInterpol1(0, mue_pos, 2);
  tau0_max_low = eps0*mue0*cgeo*fn_max;

  // Normal force and friction torque for w_rel=0
  u = f_normalized;
  free = u &lt;= 0;
  fn = if free then 0 else fn_max*u;
  tau0 = mue0*cgeo*fn;
  tau0_max = if free then tau0_max_low else peak2*tau0;

  /* Friction characteristic
       (locked is introduced to help the Modelica translator determining
       the different structural configurations, if for each configuration
       special code shall be generated)
    */
  startForward = pre(stuck) and (sa &gt; tau0_max/unitTorque or pre(startForward) and sa &gt;
    tau0/unitTorque or w_rel &gt; w_small) or initial() and (w_rel &gt; 0);
  locked = pre(stuck) and not startForward;

  // acceleration and friction torque
  a_rel = unitAngularAcceleration* (if locked then 0 else sa - tau0/unitTorque);
  tau = if locked then sa*unitTorque else (if free then 0 else cgeo*fn*
    Modelica.Math.tempInterpol1(w_rel, mue_pos, 2));

  // Determine configuration
  stuck = locked or w_rel &lt;= 0;

  lossPower = if stuck then 0 else tau*w_rel;
end OneWayClutch;</code></pre>
<hr />
<h1 id="image49-modelica.mechanics.rotational.components.idealgear"><img src="Modelica.Mechanics.Rotational.Components.IdealGearI.png" alt="image49" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.IdealGear</h1>
<p><strong>Ideal gear without inertia</strong></p>
<h2 id="information-12">Information</h2>
<p>::</p>
<p>This element characterices any type of gear box which is fixed in the ground and which has one driving shaft and one driven shaft. The gear is <strong>ideal</strong>, i.e., it does not have inertia, elasticity, damping or backlash. If these effects have to be considered, the gear has to be connected to other elements in an appropriate way.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Icons.html#Modelica.Mechanics.Rotational.Icons.Gear">Modelica.Mechanics.Rotational.Icons.Gear</a> (Rotational gear icon), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2">Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2</a> (Partial model for a component with two rotational 1-dim. shaft flanges and a support used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-11">Parameters</h2>
<table>
<col width="11%" />
<col width="13%" />
<col width="11%" />
<col width="63%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useSupport</td>
<td align="left">false</td>
<td align="left">= true, if support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">ratio</td>
<td align="left">
</td>
<td align="left">Transmission ratio (flange_a.phi/flange_b.phi)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-11">Connectors</h2>
<table>
<col width="70%" />
<col width="8%" />
<col width="20%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Support">Support</a></td>
<td align="left">support</td>
<td align="left">Support/housing of component</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>model IdealGear &quot;Ideal gear without inertia&quot;
  extends Modelica.Mechanics.Rotational.Icons.Gear;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;
  parameter Real ratio(start=1) 
    &quot;Transmission ratio (flange_a.phi/flange_b.phi)&quot;;
  Modelica.SIunits.Angle phi_a &quot;Angle between left shaft flange and support&quot;;
  Modelica.SIunits.Angle phi_b &quot;Angle between right shaft flange and support&quot;;

equation 
  phi_a = flange_a.phi - phi_support;
  phi_b = flange_b.phi - phi_support;
  phi_a = ratio*phi_b;
  0 = ratio*flange_a.tau + flange_b.tau;
end IdealGear;</code></pre>
<hr />
<h1 id="image50-modelica.mechanics.rotational.components.lossygear"><img src="Modelica.Mechanics.Rotational.Components.LossyGearI.png" alt="image50" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.LossyGear</h1>
<p><strong>Gear with mesh efficiency and bearing friction (stuck/rolling possible)</strong></p>
<h2 id="information-13">Information</h2>
<p>::</p>
<p>This component models the gear ratio and the <strong>losses</strong> of a standard gear box in a <strong>reliable</strong> way including the stuck phases that may occur at zero speed. The gear boxes that can be handeled are fixed in the ground or on a moving support, have one input and one output shaft, and are essentially described by the equations:</p>
<blockquote>
<pre><code>flange_a.phi  = i*flange_b.phi;</code></pre>
<blockquote>
<p>-(flange_b.tau - tau_bf_b) = i<em>eta_mf</em>(flange_a.tau - tau_bf_a);</p>
<p>// or -flange_b.tau = i<em>eta_mf</em>(flange_a.tau - tau_bf_a - tau_bf_b/(i*eta_mf));</p>
</blockquote>
</blockquote>
<p>where</p>
<ul>
<li><strong>i</strong> is the constant <strong>gear ratio</strong>,</li>
<li><strong>eta_mf</strong> = eta_mf(w_a) is the <strong>mesh efficiency</strong> due to the friction between the teeth of the gear wheels,</li>
<li><strong>tau_bf_a</strong> = tau_bf_a(w_a) is the <strong>bearing friction torque</strong> on the flange_a side,</li>
<li><strong>tau_bf_b</strong> = tau_bf_b(w_a) is the <strong>bearing friction torque</strong> on the flange_b side, and</li>
<li><strong>w_a</strong> = der(flange_a.phi) is the speed of flange_a</li>
</ul>
<p>The loss terms &quot;eta_mf&quot;, &quot;tau_bf_a&quot; and &quot;tau_bf_b&quot; are functions of the <em>absolute value</em> of the input shaft speed w_a and of the energy flow direction. They are defined by parameter <strong>lossTable[:,5]</strong> where the columns of this table have the following meaning:</p>
<table>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="23%" />
<col width="23%" />
<tbody>
<tr class="odd">
<td align="left">|w_a|</td>
<td align="left">eta_mf1</td>
<td align="left">eta_mf2</td>
<td align="left">|tau_bf1|</td>
<td align="left">|tau_bf2|</td>
</tr>
<tr class="even">
<td align="left">...</td>
<td align="left">...</td>
<td align="left">...</td>
<td align="left">...</td>
<td align="left">...</td>
</tr>
<tr class="odd">
<td align="left">...</td>
<td align="left">...</td>
<td align="left">...</td>
<td align="left">...</td>
<td align="left">...</td>
</tr>
</tbody>
</table>
<p>with</p>
<table>
<col width="13%" />
<col width="86%" />
<tbody>
<tr class="odd">
<td align="left">|w_a|</td>
<td align="left">Absolute value of angular velocity of input shaft flange_a</td>
</tr>
<tr class="even">
<td align="left">eta_mf1</td>
<td align="left">Mesh efficiency in case that flange_a is driving</td>
</tr>
<tr class="odd">
<td align="left">eta_mf2</td>
<td align="left">Mesh efficiency in case that flange_b is driving</td>
</tr>
<tr class="even">
<td align="left">|tau_bf1|</td>
<td align="left"><dl>
<dt>Absolute resultant bearing friction torque with respect to flange_a in case that flange_a is driving</dt>
<dd><p>(= |tau_bf_a*eta_mf1 + tau_bf_b/i|)</p>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left">|tau_bf2|</td>
<td align="left"><dl>
<dt>Absolute resultant bearing friction torque with respect to flange_a in case that flange_b is driving</dt>
<dd><p>(= |tau_bf_a/eta_mf2 + tau_bf_b/i|)</p>
</dd>
</dl></td>
</tr>
</tbody>
</table>
<p>With these variables, the mesh efficiency and the bearing friction are formally defined as:</p>
<blockquote>
<pre><code>if (flange_a.tau - tau_bf_a)*w_a &gt; 0 or
   (flange_a.tau - tau_bf_a) == 0 and w_a &gt; 0 then
   eta_mf := eta_mf1
   tau_bf := tau_bf1
elseif (flange_a.tau - tau_bf_a)*w_a &lt; 0 or
       (flange_a.tau - tau_bf_a) == 0 and w_a &lt; 0 then
   eta_mf := 1/eta_mf2
   tau_bf := tau_bf2
else // w_a == 0
   eta_mf and tau_bf are computed such that der(w_a) = 0
end if;
-flange_b.tau = i*(eta_mf*flange_a.tau - tau_bf);</code></pre>
</blockquote>
<p>Note, that the losses are modeled in a physically meaningful way taking into account that at zero speed the movement may be locked due to the friction in the gear teeth and/or in the bearings. Due to this important property, this component can be used in situations where the combination of the components Modelica.Mechanics.Rotational.IdealGear and Modelica.Mechanics.Rotational.GearEfficiency will fail because, e.g., chattering occurs when using the Modelica.Mechanics.Rotational.GearEfficiency model.</p>
<h3 id="acknowledgement">Acknowledgement:</h3>
<ul>
<li>The essential idea to model efficiency in this way is from Christoph Pelchen, ZF Friedrichshafen.</li>
<li>The article (Pelchen et.al. 2002), see Literature below, and the first implementation of LossyGear (up to version 3.1 of package Modelica) contained a bug leading to a non-converging solution in cases where the driving side is not obvious. This was pointed out by Christian Bertsch and Max Westenkirchner, Bosch, and Christian Bertsch proposed a concrete solution how to fix this bug, see Literature below.</li>
</ul>
<h3 id="literature">Literature</h3>
<ul>
<li>Pelchen C., `Schweiger

<ol start="3" style="list-style-type: upper-alpha">
<li>&lt;<a href="http://www.robotic.dlr.de/Christian.Schweiger/">http://www.robotic.dlr.de/Christian.Schweiger/</a>&gt;`_, and `Otter</li>
</ol>
M. &lt;<a href="http://www.robotic.dlr.de/Martin.Otter/">http://www.robotic.dlr.de/Martin.Otter/</a>&gt;`_: &quot;<a href="http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf">Modeling and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</a>,&quot; in <em>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</em> pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics, Deutsches Zentrum für Luft-und Raumfahrt e. V., March 18-19, 2002.</li>
<li>Bertsch C. (2009): &quot;Problem with model LossyGear and a proposed solution&quot;, Ticket <a href="http://trac.modelica.org/Modelica/ticket/108">#108</a>, Sept. 11, 2009.</li>
</ul>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Icons.html#Modelica.Mechanics.Rotational.Icons.Gear">Modelica.Mechanics.Rotational.Icons.Gear</a> (Rotational gear icon), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2">Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2</a> (Partial model for a component with two rotational 1-dim. shaft flanges and a support used for textual modeling, i.e., for elementary models), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT">Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for textual modeling, i.e., for elementary models).</p>
<h2 id="parameters-12">Parameters</h2>
<table>
<col width="9%" />
<col width="16%" />
<col width="16%" />
<col width="58%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useSupport</td>
<td align="left">false</td>
<td align="left">= true, if support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">ratio</td>
<td align="left">
</td>
<td align="left">Transmission ratio (flange_a.phi/flange_b.phi)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">lossTable[:, 5]</td>
<td align="left">[0, 1, 1, 0, 0]</td>
<td align="left">Array for mesh efficiencies and bearing friction depending on speed</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if heatPort is enabled</td>
</tr>
</tbody>
</table>
<h2 id="connectors-12">Connectors</h2>
<table>
<col width="56%" />
<col width="6%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Support">Support</a></td>
<td align="left">support</td>
<td align="left">Support/housing of component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-12">Modelica definition</h2>
<pre><code>model LossyGear 
  &quot;Gear with mesh efficiency and bearing friction (stuck/rolling possible)&quot;

  extends Modelica.Mechanics.Rotational.Icons.Gear;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialElementaryTwoFlangesAndSupport2;

  parameter Real ratio(start=1) 
    &quot;Transmission ratio (flange_a.phi/flange_b.phi)&quot;;
  parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0] 
    &quot;Array for mesh efficiencies and bearing friction depending on speed&quot;;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialElementaryConditionalHeatPortWithoutT;
  Modelica.SIunits.Angle phi_a &quot;Angle between left shaft flange and support&quot;;
  Modelica.SIunits.Angle phi_b &quot;Angle between right shaft flange and support&quot;;

  Real sa(final unit=&quot;1&quot;) &quot;Path parameter for acceleration and torque loss&quot;;
  SI.AngularVelocity w_a &quot;Angular velocity of flange_a with respect to support&quot;;
  SI.AngularAcceleration a_a 
    &quot;Angular acceleration of flange_a with respect to support&quot;;

  Real interpolation_result[1, size(lossTable, 2) - 1];
  Real eta_mf1;
  Real eta_mf2;
  Real tau_bf_a &quot;Bearing friction torque on flange_a side&quot;;
  Real tau_eta 
    &quot;Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau)&quot;;

  Real tau_bf1;
  Real tau_bf2;

  Real quadrant1;
  Real quadrant2;
  Real quadrant3;
  Real quadrant4;

  // quadrant values for angular verlocities near zero
  Real quadrant1_p; // w=0+
  Real quadrant2_p; // w=0+
  Real quadrant3_m; // w=0-
  Real quadrant4_m; // w=0-

  SI.Torque tauLoss 
    &quot;Torque loss due to friction in the gear teeth and in the bearings&quot;;
  SI.Torque tauLossMax &quot;Torque loss for positive speed&quot;;
  SI.Torque tauLossMin &quot;Torque loss for negative speed&quot;;

  SI.Torque tauLossMax_p &quot;Torque loss for positive speed&quot;;
  SI.Torque tauLossMin_m &quot;Torque loss for negative speed&quot;;

  Boolean tau_aPos(start=true) 
    &quot;Only for backwards compatibility (was previously: true, if torque of flange_a is not negative)&quot;;
  Boolean tau_etaPos(start=true) &quot;true, if torque tau_eta is not negative&quot;;
  Boolean startForward(start=false) &quot;true, if starting to roll forward&quot;;
  Boolean startBackward(start=false) &quot;true, if starting to roll backward&quot;;
  Boolean locked(start=false) &quot;true, if gear is locked&quot;;

  Boolean ideal &quot;true, if losses are neglected&quot;;

  constant Integer Unknown=3 &quot;Value of mode is not known&quot;;
  constant Integer Free=2 &quot;Element is not active&quot;;
  constant Integer Forward=1 &quot;w_a &gt; 0 (forward rolling)&quot;;
  constant Integer Stuck=0 
    &quot;w_a = 0 (forward rolling, locked or backward rolling)&quot;;
  constant Integer Backward=-1 &quot;w_a &lt; 0 (backward rolling)&quot;;
  Integer mode(
    final min=Backward,
    final max=Unknown,
    start=Free,
    fixed=true);

  SI.Torque tau_eta_p &quot;tau_eta assuming positive omega&quot;;
  SI.Torque tau_eta_m &quot;tau_eta assuming negative omega&quot;;
protected 
  constant SI.AngularAcceleration unitAngularAcceleration = 1;
  constant SI.Torque unitTorque = 1;

  // get friction and eta information for omega=0
  parameter Real interpolation_result_0[1, size(lossTable, 2) - 1] =  Modelica.Math.tempInterpol2(0, lossTable, {2,3,4,5});
  parameter Real eta_mf1_0 = interpolation_result_0[1, 1];
  parameter Real eta_mf2_0 = interpolation_result_0[1, 2];
  parameter Real tau_bf1_0 = abs(interpolation_result_0[1, 3]);
  parameter Real tau_bf2_0 = abs(interpolation_result_0[1, 4]);
  parameter Real tau_bf_a_0= if Modelica.Math.isEqual(eta_mf1_0, 1.0, Modelica.Constants.eps) and 
                                Modelica.Math.isEqual(eta_mf2_0, 1.0, Modelica.Constants.eps) then 
                                tau_bf1_0/2 else 
                                (tau_bf1_0-tau_bf2_0)/(eta_mf1_0-1.0/eta_mf2_0);
                             // For eta_mf1_0=eta_mf2_0=1 the given bearing
                             // friction can not be separated into a part
                             // on side A or B, so it is done arbitrarily.
                             // Calculate tau_bf_a_0 from the following equations
                             //  tau_bf1_0=eta_mf1_0*tau_bf_a_0 + 1/ratio a_0
                             //  tau_bf2_0=1/eta_mf2*tau_bf_a_0 + 1/ratio tau_bf_a_0
equation 
  assert(abs(ratio) &gt; 0,
    &quot;Error in initialization of LossyGear: ratio may not be zero&quot;);

  ideal = Modelica.Math.Matrices.isEqual(lossTable, [0, 1, 1, 0, 0], Modelica.Constants.eps);

  interpolation_result = if ideal then [1, 1, 0, 0] else 
    Modelica.Math.tempInterpol2(noEvent(abs(w_a)), lossTable, {2,3,4,5});
  eta_mf1 = interpolation_result[1, 1];
  eta_mf2 = interpolation_result[1, 2];
  tau_bf1 = noEvent(abs(interpolation_result[1, 3]));
  tau_bf2 = noEvent(abs(interpolation_result[1, 4]));

  if Modelica.Math.isEqual(eta_mf1, 1.0, Modelica.Constants.eps) and 
     Modelica.Math.isEqual(eta_mf2, 1.0, Modelica.Constants.eps) then
     // For eta_mf1=eta_mf2=1 the given bearing friction can not be
     // separated into a part on side A or B, so it is done arbitrarily.
     tau_bf_a = tau_bf1/2;
  else
    //calculate tau_bf_a from the following equations
    //tau_bf1 = eta_mf1*tau_bf_a + tau_bf_b / ratio
    //tau_bf2 = 1/eta_mf2*tau_bf_a + tau_bf_b / ratio
    tau_bf_a=(tau_bf1-tau_bf2)/(eta_mf1-1.0/eta_mf2);
  end if;

  phi_a = flange_a.phi - phi_support;
  phi_b = flange_b.phi - phi_support;
  phi_a = ratio*phi_b;

  // Torque balance (no inertias)
  0 = flange_b.tau + ratio*(flange_a.tau - tauLoss);

  // Speed for friction element
  w_a = der(phi_a);
  a_a = der(w_a);

  // Determine driving side
     //assuming positive omega
     tau_eta_p=flange_a.tau-tau_bf_a_0;
     //assuming negative omega
     tau_eta_m=flange_a.tau+tau_bf_a_0;

  // assuming w&gt;=0, take value at w=0 to decide rolling/stuck mode
  quadrant1_p = (1 - eta_mf1_0)*flange_a.tau + tau_bf1_0;
  quadrant2_p = (1 - 1/eta_mf2_0)*flange_a.tau + tau_bf2_0;
  tauLossMax_p = if noEvent(tau_eta_p&gt;0) then quadrant1_p else quadrant2_p;

  // assuming w&lt;=0, take value at w=0 to decide rolling/stuck mode
  quadrant4_m = (1 - 1/eta_mf2_0)*flange_a.tau - tau_bf2_0;
  quadrant3_m = (1 - eta_mf1_0)*flange_a.tau - tau_bf1_0;
  tauLossMin_m = if noEvent(tau_eta_m&gt;0) then quadrant4_m else quadrant3_m;

  quadrant1 = (1 - eta_mf1)*flange_a.tau + tau_bf1;
  quadrant2 = (1 - 1/eta_mf2)*flange_a.tau + tau_bf2;
  quadrant4 = (1 - 1/eta_mf2)*flange_a.tau - tau_bf2;
  quadrant3 = (1 - eta_mf1)*flange_a.tau - tau_bf1;

  //tau eta: only for determination of driving side for calculation of tauloss
  tau_eta = if ideal then flange_a.tau else 
                 (if locked then flange_a.tau else 
                 (if (startForward or pre(mode) == Forward) then flange_a.tau-tau_bf_a else 
                 flange_a.tau+tau_bf_a));

  // Torque Losses
  tau_etaPos = tau_eta &gt;= 0;
  tau_aPos   = tau_etaPos;
  tauLossMax = if tau_etaPos then quadrant1 else quadrant2;
  tauLossMin = if tau_etaPos then quadrant4 else quadrant3;

  // Determine rolling/stuck mode when w_rel = 0
  startForward = pre(mode) == Stuck and sa &gt; tauLossMax_p/unitTorque or initial() and w_a &gt; 0;
  startBackward = pre(mode) == Stuck and sa &lt; tauLossMin_m/unitTorque or initial() and w_a &lt; 0;
  locked = not (ideal or pre(mode) == Forward or startForward or pre(mode) == Backward or startBackward);

  /* Parameterized curve description a_a = f1(sa), tauLoss = f2(sa)
       In comparison to Modelica.Mechanics.Rotational.FrictionBase it is possible
       to simplify the following expression as mode == Stuck is assured in case
       of startForward or startBackward */
  tauLoss = if ideal then 0 else (if locked then sa*unitTorque else (if (startForward or 
        pre(mode) == Forward) then tauLossMax else tauLossMin));

  a_a = unitAngularAcceleration*(if locked then 0 else sa - tauLoss/unitTorque);

  /* Finite state machine to fix configuration after the computation above
       The above equations are only dependent on pre(mode) and not on the actual
       value of mode. This prevents loops. So mode can be determined in one step. */
  mode = if ideal then Free else (if (pre(mode) == Forward or startForward)
     and w_a &gt; 0 then Forward else if (pre(mode) == Backward or startBackward)
     and w_a &lt; 0 then Backward else Stuck);

  lossPower = tauLoss*w_a;
end LossyGear;</code></pre>
<hr />
<h1 id="image51-modelica.mechanics.rotational.components.idealplanetary"><img src="Modelica.Mechanics.Rotational.Components.IdealPlanetaryI.png" alt="image51" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.IdealPlanetary</h1>
<p><strong>Ideal planetary gear box</strong></p>
<h2 id="information-14">Information</h2>
<p>::</p>
<p>The IdealPlanetary gear box is an ideal gear without inertia, elasticity, damping or backlash consisting of an inner <strong>sun</strong> wheel, an outer <strong>ring</strong> wheel and a <strong>planet</strong> wheel located between sun and ring wheel. The bearing of the planet wheel shaft is fixed in the planet <strong>carrier</strong>. The component can be connected to other elements at the sun, ring and/or carrier flanges. It is not possible to connect to the planet wheel. If inertia shall not be neglected, the sun, ring and carrier inertias can be easily added by attaching inertias (= model Inertia) to the corresponding connectors. The inertias of the planet wheels are always neglected.</p>
<p>The icon of the planetary gear signals that the sun and carrier flanges are on the left side and the ring flange is on the right side of the gear box. However, this component is generic and is valid independantly how the flanges are actually placed (e.g., sun wheel may be placed on the right side instead on the left side in reality).</p>
<p>The ideal planetary gearbox is uniquely defined by the ratio of the number of ring teeth zr with respect to the number of sun teeth zs. For example, if there are 100 ring teeth and 50 sun teeth then ratio = zr/zs = 2. The number of planet teeth zp has to fulfill the following relationship:</p>
<pre><code>zp := (zr - zs) / 2</code></pre>
<p>Therefore, in the above example zp = 25 is required.</p>
<p>According to the overall convention, the positive direction of all vectors, especially the absolute angular velocities and cut-torques in the flanges, are along the axis vector displayed in the icon.</p>
<p>::</p>
<h2 id="parameters-13">Parameters</h2>
<table>
<col width="10%" />
<col width="11%" />
<col width="13%" />
<col width="65%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">ratio</td>
<td align="left">
</td>
<td align="left">Number of ring_teeth/sun_teeth (e.g., ratio=100/50)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-13">Connectors</h2>
<table>
<col width="74%" />
<col width="7%" />
<col width="18%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">sun</td>
<td align="left">Flange of sun shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">carrier</td>
<td align="left">Flange of carrier shaft</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">ring</td>
<td align="left">Flange of ring shaft</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-13">Modelica definition</h2>
<pre><code>model IdealPlanetary &quot;Ideal planetary gear box&quot;
  parameter Real ratio(start=100/50) 
    &quot;Number of ring_teeth/sun_teeth (e.g., ratio=100/50)&quot;;

  // kinematic relationship
  Interfaces.Flange_a sun &quot;Flange of sun shaft&quot;;
  Interfaces.Flange_a carrier &quot;Flange of carrier shaft&quot;;
  Interfaces.Flange_b ring &quot;Flange of ring shaft&quot;;

equation 
  (1 + ratio)*carrier.phi = sun.phi + ratio*ring.phi;

  // torque balance (no inertias)
  ring.tau = ratio*sun.tau;
  carrier.tau = -(1 + ratio)*sun.tau;
end IdealPlanetary;</code></pre>
<hr />
<h1 id="image52-modelica.mechanics.rotational.components.gearbox"><img src="Modelica.Mechanics.Rotational.Components.GearboxI.png" alt="image52" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.Gearbox</h1>
<p><strong>Realistic model of a gearbox (based on LossyGear)</strong></p>
<h2 id="information-15">Information</h2>
<p>::</p>
<p>This component models the essential effects of a gearbox, in particular</p>
<p>in component <strong>lossyGear</strong></p>
<ul>
<li>gear <strong>efficiency</strong> due to friction between the teeth</li>
<li><strong>bearing friction</strong></li>
</ul>
<p>in component <strong>elastoBacklash</strong></p>
<ul>
<li>gear <strong>elasticity</strong></li>
<li><strong>damping</strong></li>
<li><strong>backlash</strong></li>
</ul>
<p>The inertia of the gear wheels is not modeled. If necessary, inertia has to be taken into account by connecting components of model Inertia to the left and/or the right flange of component Gearbox.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Icons.html#Modelica.Mechanics.Rotational.Icons.Gearbox">Modelica.Mechanics.Rotational.Icons.Gearbox</a> (Icon of gear box), <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport">Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport</a> (Partial model for a component with two rotational 1-dim. shaft flanges and a support used for graphical modeling, i.e., the model is build up by drag-and-drop from elementary components), <a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort">Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort</a> (Partial model to include a conditional HeatPort in order to dissipate losses, used for graphical modeling, i.e., for bulding modelsby drag-and-drop).</p>
<h2 id="parameters-14">Parameters</h2>
<table>
<col width="41%" />
<col width="8%" />
<col width="9%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useSupport</td>
<td align="left">false</td>
<td align="left">= true, if support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">ratio</td>
<td align="left">
</td>
<td align="left">Transmission ratio (flange_a.phi/flange_b.phi)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">lossTable[:, 5]</td>
<td align="left">[0, 1, 1, 0, 0]</td>
<td align="left">Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalSpringConstant">RotationalSpringConstant</a></td>
<td align="left">c</td>
<td align="left">
</td>
<td align="left">Gear elasticity (spring constant) [N.m/rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.RotationalDampingConstant">RotationalDampingConstant</a></td>
<td align="left">d</td>
<td align="left">
</td>
<td align="left">(relative) gear damping [N.m.s/rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">b</td>
<td align="left">0</td>
<td align="left">Total backlash [rad]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useHeatPort</td>
<td align="left">false</td>
<td align="left">=true, if HeatPort is enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Temperature">Temperature</a></td>
<td align="left">T</td>
<td align="left">293.15</td>
<td align="left">Fixed device temperature if useHeatPort = false [K]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use phi_rel and w_rel as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-14">Connectors</h2>
<table>
<col width="56%" />
<col width="6%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Support">Support</a></td>
<td align="left">support</td>
<td align="left">Support/housing of component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Thermal_HeatTransfer_Interfaces.html#Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a">HeatPort_a</a></td>
<td align="left">heatPort</td>
<td align="left">Optional port to which dissipated losses are transported in form of heat</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-14">Modelica definition</h2>
<pre><code>model Gearbox &quot;Realistic model of a gearbox (based on LossyGear)&quot;
  extends Modelica.Mechanics.Rotational.Icons.Gearbox;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlangesAndSupport;

  parameter Real ratio(start=1) 
    &quot;Transmission ratio (flange_a.phi/flange_b.phi)&quot;;
  parameter Real lossTable[:, 5]=[0, 1, 1, 0, 0] 
    &quot;Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)&quot;;
  parameter SI.RotationalSpringConstant c(final min=Modelica.Constants.small, start=1.0e5) 
    &quot;Gear elasticity (spring constant)&quot;;
  parameter SI.RotationalDampingConstant d(final min=0, start=0) 
    &quot;(relative) gear damping&quot;;
  parameter SI.Angle b(final min=0) = 0 &quot;Total backlash&quot;;
  parameter StateSelect stateSelect=StateSelect.prefer 
    &quot;Priority to use phi_rel and w_rel as states&quot;;
  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort(
     final T=293.15);
  Modelica.SIunits.Angle phi_rel(start=0, stateSelect=stateSelect, nominal=1e-4)=
    flange_b.phi - lossyGear.flange_b.phi 
    &quot;Relative rotation angle over gear elasticity (= flange_b.phi - lossyGear.flange_b.phi)&quot;;
  Modelica.SIunits.AngularVelocity w_rel(start=0, stateSelect=stateSelect) = der(phi_rel) 
    &quot;Relative angular velocity over gear elasticity (= der(phi_rel))&quot;;
  Modelica.SIunits.AngularAcceleration a_rel(start=0) = der(w_rel) 
    &quot;Relative angular acceleration over gear elasticity (= der(w_rel))&quot;;

  Rotational.Components.LossyGear lossyGear(final ratio=ratio, final 
      lossTable =                                                              lossTable,
    final useSupport=true,
    final useHeatPort=true);
  Rotational.Components.ElastoBacklash elastoBacklash(
    final b=b,
    final c=c,
    final phi_rel0=0,
    final d=d,
    final useHeatPort=true);
equation 
  connect(flange_a, lossyGear.flange_a);
  connect(lossyGear.flange_b, elastoBacklash.flange_a);
  connect(elastoBacklash.flange_b, flange_b);
  connect(elastoBacklash.heatPort, internalHeatPort);
  connect(lossyGear.heatPort, internalHeatPort);
  connect(lossyGear.support, internalSupport);
end Gearbox;</code></pre>
<hr />
<h1 id="image53-modelica.mechanics.rotational.components.idealgearr2t"><img src="Modelica.Mechanics.Rotational.Components.IdealGearR2TI.png" alt="image53" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.IdealGearR2T</h1>
<p><strong>Gearbox transforming rotational into translational motion</strong></p>
<h2 id="information-16">Information</h2>
<p>::</p>
<p>This is an ideal mass- and inertialess gearbox which transforms a 1D-rotational into a 1D-translational motion. If elasticity, damping or backlash has to be considered, this ideal gearbox has to be connected with corresponding elements. This component defines the kinematic constraint:</p>
<pre><code>(flangeR.phi - internalSupportR.phi) = ratio*(flangeT.s - internalSupportT.s);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialElementaryRotationalToTranslational">Rotational.Interfaces.PartialElementaryRotationalToTranslational</a> (Partial model to transform rotational into translational motion).</p>
<h2 id="parameters-15">Parameters</h2>
<table>
<col width="9%" />
<col width="13%" />
<col width="9%" />
<col width="67%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useSupportR</td>
<td align="left">false</td>
<td align="left">= true, if rotational support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useSupportT</td>
<td align="left">false</td>
<td align="left">= true, if translational support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">ratio</td>
<td align="left">
</td>
<td align="left">Transmission ratio (flange_a.phi/flange_b.s) [rad/m]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-15">Connectors</h2>
<table>
<col width="66%" />
<col width="7%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flangeR</td>
<td align="left">Flange of rotational shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flangeT</td>
<td align="left">Flange of translational rod</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Support">Support</a></td>
<td align="left">supportR</td>
<td align="left">Rotational support/housing of component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Support">Support</a></td>
<td align="left">supportT</td>
<td align="left">Translational support/housing of component</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-15">Modelica definition</h2>
<pre><code>model IdealGearR2T 
  &quot;Gearbox transforming rotational into translational motion&quot;
  extends Rotational.Interfaces.PartialElementaryRotationalToTranslational;
  parameter Real ratio(final unit=&quot;rad/m&quot;, start=1) 
    &quot;Transmission ratio (flange_a.phi/flange_b.s)&quot;;

equation 
  (flangeR.phi - internalSupportR.phi) = ratio*(flangeT.s - internalSupportT.s);
  0 = ratio*flangeR.tau + flangeT.f;
end IdealGearR2T;</code></pre>
<hr />
<h1 id="image54-modelica.mechanics.rotational.components.idealrollingwheel"><img src="Modelica.Mechanics.Rotational.Components.IdealRollingWheelI.png" alt="image54" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.IdealRollingWheel</h1>
<p><strong>Simple 1-dim. model of an ideal rolling wheel without inertia</strong></p>
<h2 id="information-17">Information</h2>
<p>::</p>
<p>A simple kinematic model of a rolling wheel which has no inertia and no rolling resistance. This component defines the kinematic constraint:</p>
<pre><code>(flangeR.phi - internalSupportR.phi)*wheelRadius = (flangeT.s - internalSupportT.s);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialElementaryRotationalToTranslational">Rotational.Interfaces.PartialElementaryRotationalToTranslational</a> (Partial model to transform rotational into translational motion).</p>
<h2 id="parameters-16">Parameters</h2>
<table>
<col width="37%" />
<col width="9%" />
<col width="6%" />
<col width="46%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useSupportR</td>
<td align="left">false</td>
<td align="left">= true, if rotational support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useSupportT</td>
<td align="left">false</td>
<td align="left">= true, if translational support flange enabled, otherwise implicitly grounded</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">radius</td>
<td align="left">
</td>
<td align="left">Wheel radius [m]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-16">Connectors</h2>
<table>
<col width="66%" />
<col width="7%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flangeR</td>
<td align="left">Flange of rotational shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flangeT</td>
<td align="left">Flange of translational rod</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Support">Support</a></td>
<td align="left">supportR</td>
<td align="left">Rotational support/housing of component</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Support">Support</a></td>
<td align="left">supportT</td>
<td align="left">Translational support/housing of component</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-16">Modelica definition</h2>
<pre><code>model IdealRollingWheel 
  &quot;Simple 1-dim. model of an ideal rolling wheel without inertia&quot;

  extends Rotational.Interfaces.PartialElementaryRotationalToTranslational;
  parameter Modelica.SIunits.Distance radius(start=0.3) &quot;Wheel radius&quot;;

equation 
  (flangeR.phi - internalSupportR.phi)*radius = (flangeT.s - internalSupportT.s);
  0 = radius*flangeT.f + flangeR.tau;
end IdealRollingWheel;</code></pre>
<hr />
<h1 id="image55-modelica.mechanics.rotational.components.initializeflange"><img src="Modelica.Mechanics.Rotational.Components.InitializeFlangeI.png" alt="image55" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.InitializeFlange</h1>
<p><strong>Initializes a flange with pre-defined angle, speed and angular acceleration (usually, this is reference data from a control bus)</strong></p>
<h2 id="information-18">Information</h2>
<p>::</p>
<p>This component is used to optionally initialize the angle, speed, and/or angular acceleration of the flange to which this component is connected. Via parameters use_phi_start, use_w_start, use_a_start the corresponding input signals phi_start, w_start, a_start are conditionally activated. If an input is activated, the corresponding flange property is initialized with the input value at start time.</p>
<p>For example, if &quot;use_phi_start = true&quot;, then flange.phi is initialized with the value of the input signal &quot;phi_start&quot; at the start time.</p>
<p>Additionally, it is optionally possible to define the &quot;StateSelect&quot; attribute of the flange angle and the flange speed via paramater &quot;stateSelection&quot;.</p>
<p>This component is especially useful when the initial values of a flange shall be set according to reference signals of a controller that are provided via a signal bus.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon">Modelica.Blocks.Interfaces.BlockIcon</a> (Basic graphical layout of input/output block).</p>
<h2 id="parameters-17">Parameters</h2>
<table>
<col width="10%" />
<col width="12%" />
<col width="15%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_phi_start</td>
<td align="left">true</td>
<td align="left">= true, if initial angle is defined by input phi_start, otherwise not initialized</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">use_w_start</td>
<td align="left">true</td>
<td align="left">= true, if initial speed is defined by input w_start, otherwise not initialized</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_a_start</td>
<td align="left">true</td>
<td align="left">= true, if initial angular acceleration is defined by input a_start, otherwise not initialized</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.default</td>
<td align="left">Priority to use flange angle and speed as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-17">Connectors</h2>
<table>
<col width="66%" />
<col width="8%" />
<col width="24%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">phi_start</td>
<td align="left">Initial angle of flange</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">w_start</td>
<td align="left">Initial speed of flange</td>
</tr>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">a_start</td>
<td align="left">Initial angular acceleration of flange</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange</td>
<td align="left">Flange that is initialized</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-17">Modelica definition</h2>
<pre><code>model InitializeFlange 
  &quot;Initializes a flange with pre-defined angle, speed and angular acceleration (usually, this is reference data from a control bus)&quot;
  extends Modelica.Blocks.Interfaces.BlockIcon;
  parameter Boolean use_phi_start = true 
    &quot;= true, if initial angle is defined by input phi_start, otherwise not initialized&quot;;
  parameter Boolean use_w_start = true 
    &quot;= true, if initial speed is defined by input w_start, otherwise not initialized&quot;;
  parameter Boolean use_a_start = true 
    &quot;= true, if initial angular acceleration is defined by input a_start, otherwise not initialized&quot;;

  parameter StateSelect stateSelect=StateSelect.default 
    &quot;Priority to use flange angle and speed as states&quot;;

  Modelica.Blocks.Interfaces.RealInput phi_start if use_phi_start 
    &quot;Initial angle of flange&quot;;
  Modelica.Blocks.Interfaces.RealInput w_start if use_w_start 
    &quot;Initial speed of flange&quot;;
  Modelica.Blocks.Interfaces.RealInput a_start if use_a_start 
    &quot;Initial angular acceleration of flange&quot;;
  Interfaces.Flange_b flange &quot;Flange that is initialized&quot;;

  Modelica.SIunits.Angle phi_flange(stateSelect=stateSelect)=flange.phi 
    &quot;Flange angle&quot;;
  Modelica.SIunits.AngularVelocity w_flange(stateSelect=stateSelect)= der(phi_flange) 
    &quot;= der(phi_flange)&quot;;

protected 
  encapsulated model Set_phi_start &quot;Set phi_start&quot;
    import Modelica;
    extends Modelica.Blocks.Interfaces.BlockIcon;
    Modelica.Blocks.Interfaces.RealInput phi_start &quot;Start angle&quot;;

    Modelica.Mechanics.Rotational.Interfaces.Flange_b flange;
  initial equation 
    flange.phi = phi_start;
  equation 
    flange.tau = 0;

  end Set_phi_start;

  encapsulated model Set_w_start &quot;Set w_start&quot;
    import Modelica;
    extends Modelica.Blocks.Interfaces.BlockIcon;
    Modelica.Blocks.Interfaces.RealInput w_start &quot;Start angular velocity&quot;;

    Modelica.Mechanics.Rotational.Interfaces.Flange_b flange;
  initial equation 
    der(flange.phi) = w_start;
  equation 
    flange.tau = 0;

  end Set_w_start;

  encapsulated model Set_a_start &quot;Set a_start&quot;
    import Modelica;
    extends Modelica.Blocks.Interfaces.BlockIcon;
    Modelica.Blocks.Interfaces.RealInput a_start &quot;Start angular acceleration&quot;;

    Modelica.Mechanics.Rotational.Interfaces.Flange_b flange(phi(stateSelect=StateSelect.avoid));

    Modelica.SIunits.AngularVelocity w = der(flange.phi);
  initial equation 
    der(w) = a_start;
  equation 
    flange.tau = 0;
  end Set_a_start;

  encapsulated model Set_flange_tau &quot;Set flange.tau to zero&quot;
    import Modelica;
    extends Modelica.Blocks.Interfaces.BlockIcon;
    Modelica.Mechanics.Rotational.Interfaces.Flange_b flange;
  equation 
    flange.tau = 0;
  end Set_flange_tau;
protected 
  Set_phi_start set_phi_start if use_phi_start;
  Set_w_start set_w_start if use_w_start;
  Set_a_start set_a_start if use_a_start;
  Set_flange_tau set_flange_tau;
equation 
  connect(set_phi_start.phi_start, phi_start);
  connect(set_phi_start.flange, flange);
  connect(set_w_start.flange, flange);
  connect(set_w_start.w_start, w_start);
  connect(set_a_start.a_start, a_start);
  connect(set_a_start.flange, flange);
  connect(set_flange_tau.flange, flange);
end InitializeFlange;</code></pre>
<hr />
<h1 id="image56-modelica.mechanics.rotational.components.relativestates"><img src="Modelica.Mechanics.Rotational.Components.RelativeStatesI.png" alt="image56" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components">Modelica.Mechanics.Rotational.Components</a>.RelativeStates</h1>
<p><strong>Definition of relative state variables</strong></p>
<h2 id="information-19">Information</h2>
<p>::</p>
<p>Usually, the absolute angle and the absolute angular velocity of Modelica.Mechanics.Rotational.Components.Inertia models are used as state variables. In some circumstances, relative quantities are better suited, e.g., because it may be easier to supply initial values. In such cases, model <strong>RelativeStates</strong> allows the definition of state variables in the following way:</p>
<ul>
<li>Connect an instance of this model between two flange connectors.</li>
<li>The <strong>relative rotation angle</strong> and the <strong>relative angular velocity</strong> between the two connectors are used as <strong>state variables</strong>.</li>
</ul>
<p>An example is given in the next figure</p>
<p>Here, the relative angle and the relative angular velocity between the two inertias are used as state variables. Additionally, the simulator selects either the absolute angle and absolute angular velocity of model inertia1 or of model inertia2 as state variables.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges">Rotational.Interfaces.PartialTwoFlanges</a> (Partial model for a component with two rotational 1-dim. shaft flanges).</p>
<h2 id="parameters-18">Parameters</h2>
<table>
<col width="13%" />
<col width="13%" />
<col width="18%" />
<col width="55%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use the relative angle and relative speed as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-18">Connectors</h2>
<table>
<col width="74%" />
<col width="9%" />
<col width="16%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-18">Modelica definition</h2>
<pre><code>model RelativeStates &quot;Definition of relative state variables&quot;
  extends Rotational.Interfaces.PartialTwoFlanges;
  parameter StateSelect stateSelect=StateSelect.prefer 
    &quot;Priority to use the relative angle and relative speed as states&quot;;
  SI.Angle phi_rel(start=0, stateSelect=stateSelect) 
    &quot;Relative rotation angle used as state variable&quot;;
  SI.AngularVelocity w_rel(start=0, stateSelect=stateSelect) 
    &quot;Relative angular velocity used as state variable&quot;;
  SI.AngularAcceleration a_rel(start=0) &quot;Relative angular acceleration&quot;;

equation 
  phi_rel = flange_b.phi - flange_a.phi;
  w_rel = der(phi_rel);
  a_rel = der(w_rel);
  flange_a.tau = 0;
  flange_b.tau = 0;
end RelativeStates;</code></pre>
<hr />
<h1 id="modelica.mechanics.rotational.components.initializeflange.set_phi_start-modelica.mechanics.rotational.components.initializeflange.set_phi_start"><img src="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_phi_startI.png" alt="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_phi_start" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.InitializeFlange">Modelica.Mechanics.Rotational.Components.InitializeFlange</a>.Set_phi_start</h1>
<p><strong>Set phi_start</strong></p>
<h2 id="information-20">Information</h2>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon">Modelica.Blocks.Interfaces.BlockIcon</a> (Basic graphical layout of input/output block).</p>
<h2 id="connectors-19">Connectors</h2>
<table>
<col width="78%" />
<col width="10%" />
<col width="10%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">phi_start</td>
<td align="left">Start angle</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-19">Modelica definition</h2>
<pre><code>encapsulated model Set_phi_start &quot;Set phi_start&quot;
  import Modelica;
  extends Modelica.Blocks.Interfaces.BlockIcon;
  Modelica.Blocks.Interfaces.RealInput phi_start &quot;Start angle&quot;;

  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange;
initial equation 
  flange.phi = phi_start;
equation 
  flange.tau = 0;

end Set_phi_start;</code></pre>
<hr />
<h1 id="modelica.mechanics.rotational.components.initializeflange.set_w_start-modelica.mechanics.rotational.components.initializeflange.set_w_start"><img src="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_phi_startI.png" alt="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_w_start" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.InitializeFlange">Modelica.Mechanics.Rotational.Components.InitializeFlange</a>.Set_w_start</h1>
<p><strong>Set w_start</strong></p>
<h2 id="information-21">Information</h2>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon">Modelica.Blocks.Interfaces.BlockIcon</a> (Basic graphical layout of input/output block).</p>
<h2 id="connectors-20">Connectors</h2>
<table>
<col width="74%" />
<col width="8%" />
<col width="17%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">w_start</td>
<td align="left">Start angular velocity</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-20">Modelica definition</h2>
<pre><code>encapsulated model Set_w_start &quot;Set w_start&quot;
  import Modelica;
  extends Modelica.Blocks.Interfaces.BlockIcon;
  Modelica.Blocks.Interfaces.RealInput w_start &quot;Start angular velocity&quot;;

  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange;
initial equation 
  der(flange.phi) = w_start;
equation 
  flange.tau = 0;

end Set_w_start;</code></pre>
<hr />
<h1 id="modelica.mechanics.rotational.components.initializeflange.set_a_start-modelica.mechanics.rotational.components.initializeflange.set_a_start"><img src="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_phi_startI.png" alt="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_a_start" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.InitializeFlange">Modelica.Mechanics.Rotational.Components.InitializeFlange</a>.Set_a_start</h1>
<p><strong>Set a_start</strong></p>
<h2 id="information-22">Information</h2>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon">Modelica.Blocks.Interfaces.BlockIcon</a> (Basic graphical layout of input/output block).</p>
<h2 id="connectors-21">Connectors</h2>
<table>
<col width="72%" />
<col width="8%" />
<col width="19%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">a_start</td>
<td align="left">Start angular acceleration</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-21">Modelica definition</h2>
<pre><code>encapsulated model Set_a_start &quot;Set a_start&quot;
  import Modelica;
  extends Modelica.Blocks.Interfaces.BlockIcon;
  Modelica.Blocks.Interfaces.RealInput a_start &quot;Start angular acceleration&quot;;

  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange(phi(stateSelect=StateSelect.avoid));

  Modelica.SIunits.AngularVelocity w = der(flange.phi);
initial equation 
  der(w) = a_start;
equation 
  flange.tau = 0;
end Set_a_start;</code></pre>
<hr />
<h1 id="modelica.mechanics.rotational.components.initializeflange.set_flange_tau-modelica.mechanics.rotational.components.initializeflange.set_flange_tau"><img src="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_flange_tauI.png" alt="Modelica.Mechanics.Rotational.Components.InitializeFlange.Set_flange_tau" /> <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.InitializeFlange">Modelica.Mechanics.Rotational.Components.InitializeFlange</a>.Set_flange_tau</h1>
<p><strong>Set flange.tau to zero</strong></p>
<h2 id="information-23">Information</h2>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon">Modelica.Blocks.Interfaces.BlockIcon</a> (Basic graphical layout of input/output block).</p>
<h2 id="connectors-22">Connectors</h2>
<table>
<col width="80%" />
<col width="7%" />
<col width="11%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-22">Modelica definition</h2>
<pre><code>encapsulated model Set_flange_tau &quot;Set flange.tau to zero&quot;
  import Modelica;
  extends Modelica.Blocks.Interfaces.BlockIcon;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange;
equation 
  flange.tau = 0;
end Set_flange_tau;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:30:46 2010.</p>
</body>
</html>
