<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Math.Nonlinear</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Math.Nonlinear</h1>
</div>
<h1 id="modelica.math.nonlinear"><a href="Modelica_Math.html#Modelica.Math">Modelica.Math</a>.Nonlinear</h1>
<p><strong>Library of functions operating on nonlinear equations</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>This package contains functions to perform tasks such as numerically integrating a function, or solving a nonlinear algebraic equation system. The common feature of the functions in this package is that the nonlinear characteristics are passed as user defineable functions.</p>
<p>For details about how to define and to use functions as input arguments to functions, see <a href="../../ModelicaReference/help/ModelicaReference_Classes.html#ModelicaReference.Classes.Function">ModelicaReference.Classes.Function</a> or the Modelica Language Specification, Chapter 12.4.2.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="60%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Nonlinear.ExamplesS.png" alt="image4" /> <a href="Modelica_Math_Nonlinear_Examples.html#Modelica.Math.Nonlinear.Examples">Examples</a></td>
<td align="left">Examples demonstrating the usage of the functions in package Nonlinear</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Nonlinear.InterfacesS.png" alt="image5" /> <a href="Modelica_Math_Nonlinear_Interfaces.html#Modelica.Math.Nonlinear.Interfaces">Interfaces</a></td>
<td align="left">Interfaces for functions</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Nonlinear.quadratureLobattoS.png" alt="image6" /> <a href="Modelica_Math_Nonlinear.html#Modelica.Math.Nonlinear.quadratureLobatto">quadratureLobatto</a></td>
<td align="left">Return the integral of an integrand function using an adaptive Lobatto rule</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Nonlinear.quadratureLobattoS.png" alt="image7" /> <a href="Modelica_Math_Nonlinear.html#Modelica.Math.Nonlinear.solveOneNonlinearEquation">solveOneNonlinearEquation</a></td>
<td align="left">Solve f(u) = 0 in a very reliable and efficient way (f(u_min) and f(u_max) must have different signs)</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="modelica.math.nonlinear.quadraturelobatto"><a href="Modelica_Math_Nonlinear.html#Modelica.Math.Nonlinear">Modelica.Math.Nonlinear</a>.quadratureLobatto</h1>
<p><strong>Return the integral of an integrand function using an adaptive Lobatto rule</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<h3 id="syntax">Syntax</h3>
<blockquote>
<pre><code>quadratureLobatto(function f(), a, b);
quadratureLobatto(function f(), a, b, tolerance=100*Modelica.Constants.eps);</code></pre>
</blockquote>
<h3 id="description">Description</h3>
<p>Compute definite integral over function f(u,...) from u=a up to u=b using the adaptive Lobatto rule according to:</p>
<blockquote>
<dl>
<dt>Walter Gander:</dt>
<dd><p><strong>Adaptive Quadrature - Revisited</strong>. 1998. <a href="ftp://ftp.inf.ethz.ch/doc/tech-reports/1998/306.ps"><a href="ftp://ftp.inf.ethz.ch/doc/tech-reports/1998/306.ps">ftp://ftp.inf.ethz.ch/doc/tech-reports/1998/306.ps</a></a></p>
</dd>
</dl>
</blockquote>
<h3 id="example">Example</h3>
<p>See the examples in <a href="Modelica_Math_Nonlinear_Examples.html#Modelica.Math.Nonlinear.Examples">Modelica.Math.Nonlinear.Examples</a>.</p>
<p>::</p>
<h2 id="inputs">Inputs</h2>
<table>
<col width="59%" />
<col width="6%" />
<col width="14%" />
<col width="19%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Math_Nonlinear_Interfaces.html#Modelica.Math.Nonlinear.Interfaces.partialScalarFunction">partialScalarFunction</a></td>
<td align="left">f</td>
<td align="left">
</td>
<td align="left">Integrand function</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">a</td>
<td align="left">
</td>
<td align="left">Lower limit of integration interval</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">b</td>
<td align="left">
</td>
<td align="left">Upper limit of integration interval</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">tolerance</td>
<td align="left">100*Modelica.Constants.eps</td>
<td align="left">Relative tolerance for integral value</td>
</tr>
</tbody>
</table>
<h2 id="outputs">Outputs</h2>
<table>
<col width="12%" />
<col width="18%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">integral</td>
<td align="left">integral value</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>function quadratureLobatto 
  &quot;Return the integral of an integrand function using an adaptive Lobatto rule&quot;
  input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction
                                                       f &quot;Integrand function&quot;;
  input Real a &quot;Lower limit of integration interval&quot;;
  input Real b &quot;Upper limit of integration interval&quot;;
  input Real tolerance = 100*Modelica.Constants.eps 
    &quot;Relative tolerance for integral value&quot;;
  output Real integral &quot;integral value&quot;;

protected 
  constant Real x1=0.942882415695480;
  constant Real x2=0.641853342345781;
  constant Real x3=0.236383199662150;
  constant Real eps=10*Modelica.Constants.eps;
  Real m;
  Real h;
  Real alpha;
  Real beta;
  Real x[13];
  Real y[13];
  Real fa;
  Real fb;
  Real i1;
  Real i2;
  Real is;
  Real erri1;
  Real erri2;
  Real R;
  Real tol;
  Integer s;

  function quadStep &quot;Recursive function used by quadrature&quot;
    input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction
                                                         f;
    input Real a &quot;Right interval end&quot;;
    input Real b &quot;Left interval end&quot;;
    input Real fa &quot;Function value at a&quot;;
    input Real fb &quot;Function value at b&quot;;
    input Real is &quot;First approximation of the integral&quot;;
    output Real I &quot;integral value&quot;;
  protected 
    Real m;
    Real h;
    Real alpha;
    Real beta;
    Real x[5];
    Real y[5];
    Real mll;
    Real ml;
    Real mr;
    Real mrr;
    Real fmll;
    Real fml;
    Real fm;
    Real fmr;
    Real fmrr;
    Real i1;
    Real i2;
  algorithm 
    h := (b - a)/2;
    m := (a + b)/2;
    alpha := sqrt(2/3);
    beta := 1/sqrt(5);
    mll := m - alpha*h;
    ml := m - beta*h;
    mr := m + beta*h;
    mrr := m + alpha*h;
    x := {mll,ml,m,mr,mrr};
    for i in 1:size(x,1) loop
      y[i] := f(x[i]);
    end for;
    fmll := y[1];
    fml := y[2];
    fm := y[3];
    fmr := y[4];
    fmrr := y[5];
    i2 := (h/6)*(fa + fb + 5*(fml + fmr));
    i1 := (h/1470)*(77*(fa + fb) + 432*(fmll + fmrr) + 625*(fml + fmr) +
      672*fm);

    if (is + (i1 - i2) == is) or (mll &lt;= a) or (b &lt;= mrr) then
      I := i1;

    else
      I := quadStep(f, a, mll, fa, fmll, is) +
           quadStep(f, mll, ml, fmll, fml, is) +
           quadStep(f, ml, m, fml, fm, is) +
           quadStep(f, m, mr, fm, fmr, is) +
           quadStep(f, mr, mrr, fmr, fmrr, is) +
           quadStep(f, mrr, b, fmrr, fb, is);
    end if;
  end quadStep;

algorithm 
  /*
        Numerically evaluate integral using adaptive
        Lobatto rule.
        see Walter Gander: Adaptive Quadrature - Revisited, 1998
                        ftp.inf.ethz.ch in doc/tech-reports/1998/306.ps

        x[:] are the nodes
        y[:] = f(x[:]) are function values at the nodes
        */
  tol := tolerance;
  m := (a + b)/2;
  h := (b - a)/2;
  alpha := sqrt(2/3);
  beta := 1/sqrt(5);
  x := {a,
        m - x1*h,
        m - alpha*h,
        m - x2*h,
        m - beta*h,
        m - x3*h,
        m,
        m + x3*h,
        m + beta*h,
        m + x2*h,
        m + alpha*h,
        m + x1*h,
        b};
  for i in 1:size(x,1) loop
    y[i] := f(x[i]);
  end for;
  fa := y[1];
  fb := y[13];
  i2 := (h/6)*(y[1] + y[13] + 5*(y[5] + y[9]));
  i1 := (h/1470)*(77*(y[1] + y[13]) + 432*(y[3] + y[11]) + 625*(y[5] + y[9])
     + 672*y[7]);
  is := h*(.0158271919734802*(y[1] + y[13]) +.0942738402188500 *(y[2] + y[
    12]) +.155071987336585 *(y[3] + y[11]) +.188821573960182 *(y[4] + y[10])
     +.199773405226859 *(y[5] + y[9]) +.224926465333340 *(y[6] + y[8]) +.242611071901408
                    *y[7]);
  s := sign(is);
  if (s == 0) then
    s := 1;
  end if;
  erri1 := abs(i1 - is);
  erri2 := abs(i2 - is);
  R := 1;
  if (erri2 &lt;&gt; 0) then
    R := erri1/erri2;
  end if;
  if (R &gt; 0 and R &lt; 1) then
    tol := tol/R;
  end if;
  is := s*abs(is)*tol/eps;
  if (is == 0) then
    is := b - a;
  end if;
  integral := quadStep(
        f,
        a,
        b,
        fa,
        fb,
        is);

end quadratureLobatto;</code></pre>
<hr />
<h1 id="modelica.math.nonlinear.solveonenonlinearequation"><a href="Modelica_Math_Nonlinear.html#Modelica.Math.Nonlinear">Modelica.Math.Nonlinear</a>.solveOneNonlinearEquation</h1>
<p><strong>Solve f(u) = 0 in a very reliable and efficient way (f(u_min) and f(u_max) must have different signs)</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<h3 id="syntax-1">Syntax</h3>
<blockquote>
<pre><code>solveOneNonlinearEquation(function f(), u_min, u_max);
solveOneNonlinearEquation(function f(), u_min, u_max, tolerance=100*Modelica.Constants.eps);</code></pre>
</blockquote>
<h3 id="description-1">Description</h3>
<p>This function determines the solution of <strong>one non-linear algebraic equation</strong> &quot;y=f(u)&quot; in <strong>one unknown</strong> &quot;u&quot; in a reliable way. It is one of the best numerical algorithms for this purpose. As input, the nonlinear function f(u) has to be given, as well as an interval u_min, u_max that contains the solution, i.e., &quot;f(u_min)&quot; and &quot;f(u_max)&quot; must have a different sign. The function computes a smaller interval in which a sign change is present using the relative tolerance &quot;tolerance&quot; that can be given as 4th input argument.</p>
<p>The interval reduction is performed using inverse quadratic interpolation (interpolating with a quadratic polynomial through the last 3 points and computing the zero). If this fails, bisection is used, which always reduces the interval by a factor of 2. The inverse quadratic interpolation method has superlinear convergence. This is roughly the same convergence rate as a globally convergent Newton method, but without the need to compute derivatives of the non-linear function. The solver function is a direct mapping of the Algol 60 procedure &quot;zero&quot; to Modelica, from:</p>
<blockquote>
<dl>
<dt>Brent R.P.:</dt>
<dd><p><strong>Algorithms for Minimization without derivatives</strong>. Prentice Hall, 1973, pp. 58-59. Download: <a href="http://wwwmaths.anu.edu.au/~brent/pd/rpb011i.pdf"><a href="http://wwwmaths.anu.edu.au/~brent/pd/rpb011i.pdf">http://wwwmaths.anu.edu.au/~brent/pd/rpb011i.pdf</a></a> Errata and new print: <a href="http://wwwmaths.anu.edu.au/~brent/pub/pub011.html"><a href="http://wwwmaths.anu.edu.au/~brent/pub/pub011.html">http://wwwmaths.anu.edu.au/~brent/pub/pub011.html</a></a></p>
</dd>
</dl>
</blockquote>
<h3 id="example-1">Example</h3>
<p>See the examples in <a href="Modelica_Math_Nonlinear_Examples.html#Modelica.Math.Nonlinear.Examples">Modelica.Math.Nonlinear.Examples</a>.</p>
<p>::</p>
<h2 id="inputs-1">Inputs</h2>
<table>
<col width="57%" />
<col width="6%" />
<col width="14%" />
<col width="21%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Math_Nonlinear_Interfaces.html#Modelica.Math.Nonlinear.Interfaces.partialScalarFunction">partialScalarFunction</a></td>
<td align="left">f</td>
<td align="left">
</td>
<td align="left">Function y = f(u); u is computed so that y=0</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">u_min</td>
<td align="left">
</td>
<td align="left">Lower bound of search intervall</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">u_max</td>
<td align="left">
</td>
<td align="left">Upper bound of search intervall</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">tolerance</td>
<td align="left">100*Modelica.Constants.eps</td>
<td align="left">Relative tolerance of solution u</td>
</tr>
</tbody>
</table>
<h2 id="outputs-1">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="73%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">u</td>
<td align="left">Value of independent variable u so that f(u) = 0</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>function solveOneNonlinearEquation 
  &quot;Solve f(u) = 0 in a very reliable and efficient way (f(u_min) and f(u_max) must have different signs)&quot;
  import Modelica.Utilities.Streams.error;

  input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction
                                                       f 
    &quot;Function y = f(u); u is computed so that y=0&quot;;
  input Real u_min &quot;Lower bound of search intervall&quot;;
  input Real u_max &quot;Upper bound of search intervall&quot;;
  input Real tolerance=100*Modelica.Constants.eps 
    &quot;Relative tolerance of solution u&quot;;
  output Real u &quot;Value of independent variable u so that f(u) = 0&quot;;

protected 
  constant Real eps=Modelica.Constants.eps &quot;machine epsilon&quot;;
  Real a=u_min &quot;Current best minimum interval value&quot;;
  Real b=u_max &quot;Current best maximum interval value&quot;;
  Real c &quot;Intermediate point a &lt;= c &lt;= b&quot;;
  Real d;
  Real e &quot;b - a&quot;;
  Real m;
  Real s;
  Real p;
  Real q;
  Real r;
  Real tol;
  Real fa &quot;= f(a)&quot;;
  Real fb &quot;= f(b)&quot;;
  Real fc;
  Boolean found=false;
algorithm 
  // Check that f(u_min) and f(u_max) have different sign
  fa := f(u_min);
  fb := f(u_max);
  fc := fb;
  if fa &gt; 0.0 and fb &gt; 0.0 or fa &lt; 0.0 and fb &lt; 0.0 then
    error(
      &quot;The arguments u_min and u_max to solveOneNonlinearEquation(..)\n&quot; +
      &quot;do not bracket the root of the single non-linear equation:\n&quot; +
      &quot;  u_min  = &quot; + String(u_min) + &quot;\n&quot; + &quot;  u_max  = &quot; + String(u_max)
       + &quot;\n&quot; + &quot;  fa = f(u_min) = &quot; + String(fa) + &quot;\n&quot; +
      &quot;  fb = f(u_max) = &quot; + String(fb) + &quot;\n&quot; +
      &quot;fa and fb must have opposite sign which is not the case&quot;);
  end if;

  // Initialize variables
  c := a;
  fc := fa;
  e := b - a;
  d := e;

  // Search loop
  while not found loop
    if abs(fc) &lt; abs(fb) then
      a := b;
      b := c;
      c := a;
      fa := fb;
      fb := fc;
      fc := fa;
    end if;

    tol := 2*eps*abs(b) + tolerance;
    m := (c - b)/2;

    if abs(m) &lt;= tol or fb == 0.0 then
      // root found (interval is small enough)
      found := true;
      u := b;
    else
      // Determine if a bisection is needed
      if abs(e) &lt; tol or abs(fa) &lt;= abs(fb) then
        e := m;
        d := e;
      else
        s := fb/fa;
        if a == c then
          // linear interpolation
          p := 2*m*s;
          q := 1 - s;
        else
          // inverse quadratic interpolation
          q := fa/fc;
          r := fb/fc;
          p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
          q := (q - 1)*(r - 1)*(s - 1);
        end if;

        if p &gt; 0 then
          q := -q;
        else
          p := -p;
        end if;

        s := e;
        e := d;
        if 2*p &lt; 3*m*q - abs(tol*q) and p &lt; abs(0.5*s*q) then
          // interpolation successful
          d := p/q;
        else
          // use bi-section
          e := m;
          d := e;
        end if;
      end if;

      // Best guess value is defined as &quot;a&quot;
      a := b;
      fa := fb;
      b := b + (if abs(d) &gt; tol then d else if m &gt; 0 then tol else -tol);
      fb := f(b);

      if fb &gt; 0 and fc &gt; 0 or fb &lt; 0 and fc &lt; 0 then
        // initialize variables
        c := a;
        fc := fa;
        e := b - a;
        d := e;
      end if;
    end if;
  end while;

end solveOneNonlinearEquation;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:31:48 2010.</p>
</body>
</html>
