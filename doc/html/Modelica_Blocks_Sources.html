<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Blocks.Sources</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Blocks.Sources</h1>
</div>
<h1 id="modelica.blocks.sources"><a href="Modelica_Blocks.html#Modelica.Blocks">Modelica.Blocks</a>.Sources</h1>
<p><strong>Library of signal source blocks generating Real and Boolean signals</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>This package contains <strong>source</strong> components, i.e., blocks which have only output signals. These blocks are used as signal generators for Real, Integer and Boolean signals.</p>
<p>All Real source signals (with the exception of the Constant source) have at least the following two parameters:</p>
<table>
<col width="18%" />
<col width="81%" />
<tbody>
<tr class="odd">
<td align="left"><strong>offset</strong></td>
<td align="left">Value which is added to the signal</td>
</tr>
<tr class="even">
<td align="left"><strong>startTime</strong></td>
<td align="left">Start time of signal. For time &lt; startTime, the output y is set to offset.</td>
</tr>
</tbody>
</table>
<p>The <strong>offset</strong> parameter is especially useful in order to shift the corresponding source, such that at initial time the system is stationary. To determine the corresponding value of offset, usually requires a trimming calculation.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_SourcesPackage.html#Modelica.Icons.SourcesPackage">Modelica.Icons.SourcesPackage</a> (Icon for packages containing sources).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="50%" />
<col width="49%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.RealExpressionS.png" alt="image26" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.RealExpression">RealExpression</a></td>
<td align="left">Set output signal to a time varying Real expression</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.IntegerExpressionS.png" alt="image27" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.IntegerExpression">IntegerExpression</a></td>
<td align="left">Set output signal to a time varying Integer expression</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.BooleanExpressionS.png" alt="image28" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanExpression">BooleanExpression</a></td>
<td align="left">Set output signal to a time varying Boolean expression</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.ClockS.png" alt="image29" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Clock">Clock</a></td>
<td align="left">Generate actual time signal</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.ConstantS.png" alt="image30" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Constant">Constant</a></td>
<td align="left">Generate constant signal of type Real</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.StepS.png" alt="image31" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Step">Step</a></td>
<td align="left">Generate step signal of type Real</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.RampS.png" alt="image32" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Ramp">Ramp</a></td>
<td align="left">Generate ramp signal</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.SineS.png" alt="image33" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Sine">Sine</a></td>
<td align="left">Generate sine signal</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.ExpSineS.png" alt="image34" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.ExpSine">ExpSine</a></td>
<td align="left">Generate exponentially damped sine signal</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.ExponentialsS.png" alt="image35" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Exponentials">Exponentials</a></td>
<td align="left">Generate a rising and falling exponential signal</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.PulseS.png" alt="image36" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Pulse">Pulse</a></td>
<td align="left">Generate pulse signal of type Real</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.SawToothS.png" alt="image37" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.SawTooth">SawTooth</a></td>
<td align="left">Generate saw tooth signal</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.TrapezoidS.png" alt="image38" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.Trapezoid">Trapezoid</a></td>
<td align="left">Generate trapezoidal signal of type Real</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.KinematicPTPS.png" alt="image39" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.KinematicPTP">KinematicPTP</a></td>
<td align="left">Move as fast as possible along a distance within given kinematic constraints</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.KinematicPTP2S.png" alt="image40" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.KinematicPTP2">KinematicPTP2</a></td>
<td align="left">Move as fast as possible from start to end position within given kinematic constraints with output signals q, qd=der(q), qdd=der(qd)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.TimeTableS.png" alt="image41" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.TimeTable">TimeTable</a></td>
<td align="left">Generate a (possibly discontinuous) signal by linear interpolation in a table</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.CombiTimeTableS.png" alt="image42" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.CombiTimeTable">CombiTimeTable</a></td>
<td align="left">Table look-up with respect to time and linear/perodic extrapolation methods (data from matrix/file)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.BooleanConstantS.png" alt="image43" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanConstant">BooleanConstant</a></td>
<td align="left">Generate constant signal of type Boolean</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.BooleanStepS.png" alt="image44" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanStep">BooleanStep</a></td>
<td align="left">Generate step signal of type Boolean</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.BooleanPulseS.png" alt="image45" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanPulse">BooleanPulse</a></td>
<td align="left">Generate pulse signal of type Boolean</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.SampleTriggerS.png" alt="image46" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.SampleTrigger">SampleTrigger</a></td>
<td align="left">Generate sample trigger signal</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.BooleanTableS.png" alt="image47" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.BooleanTable">BooleanTable</a></td>
<td align="left">Generate a Boolean output signal based on a vector of time instants</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.RadioButtonSourceS.png" alt="image48" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.RadioButtonSource">RadioButtonSource</a></td>
<td align="left">Boolean signal source that mimis a radio button</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.IntegerConstantS.png" alt="image49" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.IntegerConstant">IntegerConstant</a></td>
<td align="left">Generate constant signal of type Integer</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Sources.IntegerStepS.png" alt="image50" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.IntegerStep">IntegerStep</a></td>
<td align="left">Generate step signal of type Integer</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Sources.IntegerTableS.png" alt="image51" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.IntegerTable">IntegerTable</a></td>
<td align="left">Generate an Integer output signal based on a table matrix with [time, yi] values</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image52-modelica.blocks.sources.realexpression"><img src="Modelica.Blocks.Sources.RealExpressionI.png" alt="image52" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.RealExpression</h1>
<p><strong>Set output signal to a time varying Real expression</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>The (time varying) Real output signal of this block can be defined in its parameter menu via variable <strong>y</strong>. The purpose is to support the easy definition of Real expressions in a block diagram. For example, in the y-menu the definition &quot;if time &lt; 1 then 0 else 1&quot; can be given in order to define that the output signal is one, if time ≥ 1 and otherwise it is zero. Note, that &quot;time&quot; is a built-in variable that is always accessible and represents the &quot;model time&quot; and that Variable <strong>y</strong> is both a variable and a connector.</p>
<p>::</p>
<h2 id="parameters">Parameters</h2>
<table>
<col width="66%" />
<col width="6%" />
<col width="8%" />
<col width="18%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Time varying output signal</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">0.0</td>
<td align="left">Value of Real output</td>
</tr>
</tbody>
</table>
<h2 id="connectors">Connectors</h2>
<table>
<col width="74%" />
<col width="6%" />
<col width="19%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Time varying output signal</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Value of Real output</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>block RealExpression 
  &quot;Set output signal to a time varying Real expression&quot;

  Modelica.Blocks.Interfaces.RealOutput y=0.0 &quot;Value of Real output&quot;;


end RealExpression;</code></pre>
<hr />
<h1 id="image53-modelica.blocks.sources.integerexpression"><img src="Modelica.Blocks.Sources.IntegerExpressionI.png" alt="image53" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.IntegerExpression</h1>
<p><strong>Set output signal to a time varying Integer expression</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>The (time varying) Integer output signal of this block can be defined in its parameter menu via variable <strong>y</strong>. The purpose is to support the easy definition of Integer expressions in a block diagram. For example, in the y-menu the definition &quot;if time &lt; 1 then 0 else 1&quot; can be given in order to define that the output signal is one, if time ≥ 1 and otherwise it is zero. Note, that &quot;time&quot; is a built-in variable that is always accessible and represents the &quot;model time&quot; and that Variable <strong>y</strong> is both a variable and a connector.</p>
<p>::</p>
<h2 id="parameters-1">Parameters</h2>
<table>
<col width="66%" />
<col width="6%" />
<col width="8%" />
<col width="19%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Time varying output signal</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerOutput">IntegerOutput</a></td>
<td align="left">y</td>
<td align="left">0</td>
<td align="left">Value of Integer output</td>
</tr>
</tbody>
</table>
<h2 id="connectors-1">Connectors</h2>
<table>
<col width="73%" />
<col width="6%" />
<col width="20%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Time varying output signal</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerOutput">IntegerOutput</a></td>
<td align="left">y</td>
<td align="left">Value of Integer output</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>block IntegerExpression 
  &quot;Set output signal to a time varying Integer expression&quot;

  Modelica.Blocks.Interfaces.IntegerOutput y=0 &quot;Value of Integer output&quot;;


end IntegerExpression;</code></pre>
<hr />
<h1 id="image54-modelica.blocks.sources.booleanexpression"><img src="Modelica.Blocks.Sources.BooleanExpressionI.png" alt="image54" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.BooleanExpression</h1>
<p><strong>Set output signal to a time varying Boolean expression</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>The (time varying) Boolean output signal of this block can be defined in its parameter menu via variable <strong>y</strong>. The purpose is to support the easy definition of Boolean expressions in a block diagram. For example, in the y-menu the definition &quot;time &gt;= 1 and time &lt;= 2&quot; can be given in order to define that the output signal is <strong>true</strong> in the time interval 1 ≤ time ≤ 2 and otherwise it is <strong>false</strong>. Note, that &quot;time&quot; is a built-in variable that is always accessible and represents the &quot;model time&quot; and that Variable <strong>y</strong> is both a variable and a connector.</p>
<p>::</p>
<h2 id="parameters-2">Parameters</h2>
<table>
<col width="66%" />
<col width="6%" />
<col width="8%" />
<col width="19%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Time varying output signal</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">y</td>
<td align="left">false</td>
<td align="left">Value of Boolean output</td>
</tr>
</tbody>
</table>
<h2 id="connectors-2">Connectors</h2>
<table>
<col width="73%" />
<col width="6%" />
<col width="20%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Time varying output signal</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">y</td>
<td align="left">Value of Boolean output</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>block BooleanExpression 
  &quot;Set output signal to a time varying Boolean expression&quot;

  Modelica.Blocks.Interfaces.BooleanOutput y=false &quot;Value of Boolean output&quot;;


end BooleanExpression;</code></pre>
<hr />
<h1 id="image55-modelica.blocks.sources.clock"><img src="Modelica.Blocks.Sources.ClockI.png" alt="image55" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Clock</h1>
<p><strong>Generate actual time signal</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>The Real output y is a clock signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-3">Parameters</h2>
<table>
<col width="44%" />
<col width="10%" />
<col width="9%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal [s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-3">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>block Clock &quot;Generate actual time signal &quot;
  parameter Modelica.SIunits.Time offset=0 &quot;Offset of output signal&quot;;
  parameter Modelica.SIunits.Time startTime=0 
    &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;

equation 
  y = offset + (if time &lt; startTime then 0 else time - startTime);
end Clock;</code></pre>
<hr />
<h1 id="image56-modelica.blocks.sources.constant"><img src="Modelica.Blocks.Sources.ConstantI.png" alt="image56" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Constant</h1>
<p><strong>Generate constant signal of type Real</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p>The Real output y is a constant signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-4">Parameters</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="16%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">k</td>
<td align="left">
</td>
<td align="left">Constant output value</td>
</tr>
</tbody>
</table>
<h2 id="connectors-4">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>block Constant &quot;Generate constant signal of type Real&quot;
  parameter Real k(start=1) &quot;Constant output value&quot;;
  extends Interfaces.SO;

equation 
  y = k;
end Constant;</code></pre>
<hr />
<h1 id="image57-modelica.blocks.sources.step"><img src="Modelica.Blocks.Sources.StepI.png" alt="image57" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Step</h1>
<p><strong>Generate step signal of type Real</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p>The Real output y is a step signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SignalSource">Interfaces.SignalSource</a> (Base class for continuous signal source).</p>
<h2 id="parameters-5">Parameters</h2>
<table>
<col width="44%" />
<col width="10%" />
<col width="9%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">height</td>
<td align="left">1</td>
<td align="left">Height of step</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal y</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output y = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-5">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>block Step &quot;Generate step signal of type Real&quot;
  parameter Real height=1 &quot;Height of step&quot;;
  extends Interfaces.SignalSource;

equation 
  y = offset + (if time &lt; startTime then 0 else height);
end Step;</code></pre>
<hr />
<h1 id="image58-modelica.blocks.sources.ramp"><img src="Modelica.Blocks.Sources.RampI.png" alt="image58" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Ramp</h1>
<p><strong>Generate ramp signal</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p>The Real output y is a ramp signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-6">Parameters</h2>
<table>
<col width="44%" />
<col width="10%" />
<col width="9%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">height</td>
<td align="left">1</td>
<td align="left">Height of ramps</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">duration</td>
<td align="left">
</td>
<td align="left">Durations of ramp [s]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-6">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>block Ramp &quot;Generate ramp signal&quot;
  parameter Real height=1 &quot;Height of ramps&quot;;
  parameter Modelica.SIunits.Time duration(min=Modelica.Constants.small, start = 2) 
    &quot;Durations of ramp&quot;;
  parameter Real offset=0 &quot;Offset of output signal&quot;;
  parameter Modelica.SIunits.Time startTime=0 
    &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;

equation 
  y = offset + (if time &lt; startTime then 0 else if time &lt; (startTime +
    duration) then (time - startTime)*height/duration else height);
end Ramp;</code></pre>
<hr />
<h1 id="image59-modelica.blocks.sources.sine"><img src="Modelica.Blocks.Sources.SineI.png" alt="image59" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Sine</h1>
<p><strong>Generate sine signal</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<p>The Real output y is a sine signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-7">Parameters</h2>
<table>
<col width="48%" />
<col width="10%" />
<col width="8%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">amplitude</td>
<td align="left">1</td>
<td align="left">Amplitude of sine wave</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">freqHz</td>
<td align="left">
</td>
<td align="left">Frequency of sine wave [Hz]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phase</td>
<td align="left">0</td>
<td align="left">Phase of sine wave [rad]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-7">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>block Sine &quot;Generate sine signal&quot;
  parameter Real amplitude=1 &quot;Amplitude of sine wave&quot;;
  parameter SIunits.Frequency freqHz(start=1) &quot;Frequency of sine wave&quot;;
  parameter SIunits.Angle phase=0 &quot;Phase of sine wave&quot;;
  parameter Real offset=0 &quot;Offset of output signal&quot;;
  parameter SIunits.Time startTime=0 &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;
protected 
  constant Real pi=Modelica.Constants.pi;

equation 
  y = offset + (if time &lt; startTime then 0 else amplitude*
    Modelica.Math.sin(2*pi*freqHz*(time - startTime) + phase));
end Sine;</code></pre>
<hr />
<h1 id="image60-modelica.blocks.sources.expsine"><img src="Modelica.Blocks.Sources.ExpSineI.png" alt="image60" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.ExpSine</h1>
<p><strong>Generate exponentially damped sine signal</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<p>The Real output y is a sine signal with exponentially changing amplitude:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-8">Parameters</h2>
<table>
<col width="48%" />
<col width="10%" />
<col width="8%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">amplitude</td>
<td align="left">1</td>
<td align="left">Amplitude of sine wave</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">freqHz</td>
<td align="left">
</td>
<td align="left">Frequency of sine wave [Hz]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phase</td>
<td align="left">0</td>
<td align="left">Phase of sine wave [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Damping">Damping</a></td>
<td align="left">damping</td>
<td align="left">
</td>
<td align="left">Damping coefficient of sine wave [s-1]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-8">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>block ExpSine &quot;Generate exponentially damped sine signal&quot;
  parameter Real amplitude=1 &quot;Amplitude of sine wave&quot;;
  parameter SIunits.Frequency freqHz(start=2) &quot;Frequency of sine wave&quot;;
  parameter SIunits.Angle phase=0 &quot;Phase of sine wave&quot;;
  parameter SIunits.Damping damping(start=1) &quot;Damping coefficient of sine wave&quot;;
  parameter Real offset=0 &quot;Offset of output signal&quot;;
  parameter SIunits.Time startTime=0 &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;
protected 
  constant Real pi=Modelica.Constants.pi;

equation 
  y = offset + (if time &lt; startTime then 0 else amplitude*
    Modelica.Math.exp(-(time - startTime)*damping)*Modelica.Math.sin(2*pi*freqHz*(time - startTime) + phase));
end ExpSine;</code></pre>
<hr />
<h1 id="image61-modelica.blocks.sources.exponentials"><img src="Modelica.Blocks.Sources.ExponentialsI.png" alt="image61" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Exponentials</h1>
<p><strong>Generate a rising and falling exponential signal</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<p>The Real output y is a rising exponential followed by a falling exponential signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-9">Parameters</h2>
<table>
<col width="31%" />
<col width="9%" />
<col width="9%" />
<col width="48%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">outMax</td>
<td align="left">1</td>
<td align="left">Height of output for infinite riseTime</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">riseTime</td>
<td align="left">
</td>
<td align="left">Rise time [s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">riseTimeConst</td>
<td align="left">0.1</td>
<td align="left">Rise time constant; rising is defined as outMax*(1-exp(-riseTime/riseTimeConst)) [s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">fallTimeConst</td>
<td align="left">riseTimeConst</td>
<td align="left">Fall time constant [s]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-9">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>model Exponentials &quot;Generate a rising and falling exponential signal&quot;

  parameter Real outMax=1 &quot;Height of output for infinite riseTime&quot;;
  parameter SIunits.Time riseTime(min=0,start = 0.5) &quot;Rise time&quot;;
  parameter SIunits.Time riseTimeConst(min=Modelica.Constants.small)=0.1 
    &quot;Rise time constant; rising is defined as outMax*(1-exp(-riseTime/riseTimeConst))&quot;;
  parameter SIunits.Time fallTimeConst(min=Modelica.Constants.small)=
    riseTimeConst &quot;Fall time constant&quot;;
  parameter Real offset=0 &quot;Offset of output signal&quot;;
  parameter SIunits.Time startTime=0 &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;
protected 
  Real y_riseTime;

equation 
  y_riseTime = outMax*(1 - Modelica.Math.exp(-riseTime/riseTimeConst));
  y = offset + (if (time &lt; startTime) then 0
          else if (time &lt; (startTime + riseTime)) then outMax*(1 - Modelica.Math.exp(-(time - startTime)/riseTimeConst))
          else                                          y_riseTime*Modelica.Math.exp(-(time - startTime - riseTime)/fallTimeConst));

end Exponentials;</code></pre>
<hr />
<h1 id="image62-modelica.blocks.sources.pulse"><img src="Modelica.Blocks.Sources.PulseI.png" alt="image62" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Pulse</h1>
<p><strong>Generate pulse signal of type Real</strong></p>
<h2 id="information-11">Information</h2>
<p>::</p>
<p>The Real output y is a pulse signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Modelica.Blocks.Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-10">Parameters</h2>
<table>
<col width="40%" />
<col width="9%" />
<col width="8%" />
<col width="42%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">amplitude</td>
<td align="left">1</td>
<td align="left">Amplitude of pulse</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">width</td>
<td align="left">50</td>
<td align="left">Width of pulse in % of period</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">period</td>
<td align="left">
</td>
<td align="left">Time for one period [s]</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">nperiod</td>
<td align="left">-1</td>
<td align="left">Number of periods (&lt; 0 means infinite number of periods)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signals</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-10">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>block Pulse &quot;Generate pulse signal of type Real&quot;
  parameter Real amplitude=1 &quot;Amplitude of pulse&quot;;
  parameter Real width(
    final min=Modelica.Constants.small,
    final max=100) = 50 &quot;Width of pulse in % of period&quot;;
  parameter Modelica.SIunits.Time period(final min=Modelica.Constants.small,start=1) 
    &quot;Time for one period&quot;;
  parameter Integer nperiod=-1 
    &quot;Number of periods (&lt; 0 means infinite number of periods)&quot;;
  parameter Real offset=0 &quot;Offset of output signals&quot;;
  parameter Modelica.SIunits.Time startTime=0 
    &quot;Output = offset for time &lt; startTime&quot;;
  extends Modelica.Blocks.Interfaces.SO;
protected 
  Modelica.SIunits.Time T_width = period*width/100;
  Modelica.SIunits.Time T_start &quot;Start time of current period&quot;;
  Integer count &quot;Period count&quot;;
initial algorithm 
  count := integer((time - startTime)/period);
  T_start := startTime + count*period;
equation 
  when integer((time - startTime)/period)&gt;pre(count) then
    count = pre(count)+1;
    T_start = time;
  end when;
  y = offset + (if (time&lt;startTime or nperiod==0 or (nperiod&gt;0 and count&gt;=nperiod)) then 0
           else if  time&lt;T_start + T_width then amplitude else 0);
end Pulse;</code></pre>
<hr />
<h1 id="image63-modelica.blocks.sources.sawtooth"><img src="Modelica.Blocks.Sources.SawToothI.png" alt="image63" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.SawTooth</h1>
<p><strong>Generate saw tooth signal</strong></p>
<h2 id="information-12">Information</h2>
<p>::</p>
<p>The Real output y is a saw tooth signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-11">Parameters</h2>
<table>
<col width="40%" />
<col width="9%" />
<col width="8%" />
<col width="42%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">amplitude</td>
<td align="left">1</td>
<td align="left">Amplitude of saw tooth</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">period</td>
<td align="left">
</td>
<td align="left">Time for one period [s]</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">nperiod</td>
<td align="left">-1</td>
<td align="left">Number of periods (&lt; 0 means infinite number of periods)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signals</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-11">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>block SawTooth &quot;Generate saw tooth signal&quot;
  parameter Real amplitude=1 &quot;Amplitude of saw tooth&quot;;
  parameter SIunits.Time period(final min=Modelica.Constants.small,start = 1) 
    &quot;Time for one period&quot;;
  parameter Integer nperiod=-1 
    &quot;Number of periods (&lt; 0 means infinite number of periods)&quot;;
  parameter Real offset=0 &quot;Offset of output signals&quot;;
  parameter SIunits.Time startTime=0 &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;
protected 
  SIunits.Time T_start(final start=startTime) &quot;Start time of current period&quot;;
  Integer count &quot;Period count&quot;;
initial algorithm 
  count := integer((time - startTime)/period);
  T_start := startTime + count*period;
equation 
  when integer((time - startTime)/period)&gt;pre(count) then
    count = pre(count)+1;
    T_start = time;
  end when;
  y = offset + (if (time&lt;startTime or nperiod==0 or (nperiod&gt;0 and count&gt;=nperiod)) then 0
               else amplitude*(time - T_start)/period);
end SawTooth;</code></pre>
<hr />
<h1 id="image64-modelica.blocks.sources.trapezoid"><img src="Modelica.Blocks.Sources.TrapezoidI.png" alt="image64" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.Trapezoid</h1>
<p><strong>Generate trapezoidal signal of type Real</strong></p>
<h2 id="information-13">Information</h2>
<p>::</p>
<p>The Real output y is a trapezoid signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-12">Parameters</h2>
<table>
<col width="40%" />
<col width="9%" />
<col width="8%" />
<col width="42%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">amplitude</td>
<td align="left">1</td>
<td align="left">Amplitude of trapezoid</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">rising</td>
<td align="left">0</td>
<td align="left">Rising duration of trapezoid [s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">width</td>
<td align="left">0.5</td>
<td align="left">Width duration of trapezoid [s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">falling</td>
<td align="left">0</td>
<td align="left">Falling duration of trapezoid [s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">period</td>
<td align="left">
</td>
<td align="left">Time for one period [s]</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">nperiod</td>
<td align="left">-1</td>
<td align="left">Number of periods (&lt; 0 means infinite number of periods)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-12">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-12">Modelica definition</h2>
<pre><code>block Trapezoid &quot;Generate trapezoidal signal of type Real&quot;
  parameter Real amplitude=1 &quot;Amplitude of trapezoid&quot;;
  parameter SIunits.Time rising(final min=0) = 0 &quot;Rising duration of trapezoid&quot;;
  parameter SIunits.Time width(final min=0) = 0.5 &quot;Width duration of trapezoid&quot;;
  parameter SIunits.Time falling(final min=0) = 0 
    &quot;Falling duration of trapezoid&quot;;
  parameter SIunits.Time period(final min=Modelica.Constants.small, start= 1) 
    &quot;Time for one period&quot;;
  parameter Integer nperiod=-1 
    &quot;Number of periods (&lt; 0 means infinite number of periods)&quot;;
  parameter Real offset=0 &quot;Offset of output signal&quot;;
  parameter SIunits.Time startTime=0 &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;
protected 
  parameter SIunits.Time T_rising=rising 
    &quot;End time of rising phase within one period&quot;;
  parameter SIunits.Time T_width=T_rising + width 
    &quot;End time of width phase within one period&quot;;
  parameter SIunits.Time T_falling=T_width + falling 
    &quot;End time of falling phase within one period&quot;;
  SIunits.Time T_start &quot;Start time of current period&quot;;
  Integer count &quot;Period count&quot;;
initial algorithm 
  count := integer((time - startTime)/period);
  T_start := startTime + count*period;
equation 
  when integer((time - startTime)/period)&gt;pre(count) then
    count = pre(count)+1;
    T_start = time;
  end when;
  y = offset + (if (time&lt;startTime or nperiod==0 or (nperiod&gt;0 and count&gt;=nperiod)) then 0
           else if (time &lt; T_start + T_rising)  then amplitude*(time - T_start)/rising
           else if (time &lt; T_start + T_width)   then amplitude
           else if (time &lt; T_start + T_falling) then amplitude*(T_start + T_falling - time)/falling
           else                                 0);
end Trapezoid;</code></pre>
<hr />
<h1 id="image65-modelica.blocks.sources.kinematicptp"><img src="Modelica.Blocks.Sources.KinematicPTPI.png" alt="image65" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.KinematicPTP</h1>
<p><strong>Move as fast as possible along a distance within given kinematic constraints</strong></p>
<h2 id="information-14">Information</h2>
<p>::</p>
<p>The goal is to move as <strong>fast</strong> as possible along a distance <strong>deltaq</strong> under given <strong>kinematical constraints</strong>. The distance can be a positional or angular range. In robotics such a movement is called <strong>PTP</strong> (Point-To-Point). This source block generates the <strong>acceleration</strong> qdd of this signal as output:</p>
<p>After integrating the output two times, the position q is obtained. The signal is constructed in such a way that it is not possible to move faster, given the <strong>maximally</strong> allowed <strong>velocity</strong> qd_max and the <strong>maximally</strong> allowed <strong>acceleration</strong> qdd_max.</p>
<p>If several distances are given (vector deltaq has more than 1 element), an acceleration output vector is constructed such that all signals are in the same periods in the acceleration, constant velocity and deceleration phase. This means that only one of the signals is at its limits whereas the others are sychnronized in such a way that the end point is reached at the same time instant.</p>
<p>This element is useful to generate a reference signal for a controller which controls a drive train or in combination with model Modelica.Mechanics.Rotational.<strong>Accelerate</strong> to drive a flange according to a given acceleration.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO">Interfaces.MO</a> (Multiple Output continuous control block).</p>
<h2 id="parameters-13">Parameters</h2>
<table>
<col width="37%" />
<col width="10%" />
<col width="23%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">deltaq[:]</td>
<td align="left">
</td>
<td align="left">Distance to move</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">qd_max[:]</td>
<td align="left">
</td>
<td align="left">Maximum velocities der(q)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">qdd_max[:]</td>
<td align="left">
</td>
<td align="left">Maximum accelerations der(qd)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Time instant at which movement starts [s]</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">nout</td>
<td align="left">max([size(deltaq, 1); size(q...</td>
<td align="left">Number of outputs</td>
</tr>
</tbody>
</table>
<h2 id="connectors-13">Connectors</h2>
<table>
<col width="66%" />
<col width="8%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y[nout]</td>
<td align="left">Connector of Real output signals</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-13">Modelica definition</h2>
<pre><code>block KinematicPTP 
  &quot;Move as fast as possible along a distance within given kinematic constraints&quot;

  parameter Real deltaq[:] &quot;Distance to move&quot;;
  parameter Real qd_max[:](each final min=Modelica.Constants.small) 
    &quot;Maximum velocities der(q)&quot;;
  parameter Real qdd_max[:](each final min=Modelica.Constants.small) 
    &quot;Maximum accelerations der(qd)&quot;;
  parameter SIunits.Time startTime=0 &quot;Time instant at which movement starts&quot;;

  extends Interfaces.MO(final nout=max([size(deltaq, 1); size(qd_max, 1);
         size(qdd_max, 1)]));

protected 
  parameter Real p_deltaq[nout]=(if size(deltaq, 1) == 1 then ones(nout)*
      deltaq[1] else deltaq);
  parameter Real p_qd_max[nout]=(if size(qd_max, 1) == 1 then ones(nout)*
      qd_max[1] else qd_max);
  parameter Real p_qdd_max[nout]=(if size(qdd_max, 1) == 1 then ones(nout)
      *qdd_max[1] else qdd_max);
  Real sd_max;
  Real sdd_max;
  Real sdd;
  Real aux1[nout];
  Real aux2[nout];
  SIunits.Time Ta1;
  SIunits.Time Ta2;
  SIunits.Time Tv;
  SIunits.Time Te;
  Boolean noWphase;

equation 
  for i in 1:nout loop
    aux1[i] = p_deltaq[i]/p_qd_max[i];
    aux2[i] = p_deltaq[i]/p_qdd_max[i];
  end for;
  sd_max = 1/max(abs(aux1));
  sdd_max = 1/max(abs(aux2));

  Ta1 = sqrt(1/sdd_max);
  Ta2 = sd_max/sdd_max;
  noWphase = Ta2 &gt;= Ta1;
  Tv = if noWphase then Ta1 else 1/sd_max;
  Te = if noWphase then Ta1 + Ta1 else Tv + Ta2;

  // path-acceleration
  sdd = if time &lt; startTime then 0 else ((if noWphase then (if time &lt; Ta1
     + startTime then sdd_max else (if time &lt; Te + startTime then -
    sdd_max else 0)) else (if time &lt; Ta2 + startTime then sdd_max else (
    if time &lt; Tv + startTime then 0 else (if time &lt; Te + startTime then -
    sdd_max else 0)))));

  // acceleration
  y = p_deltaq*sdd;
end KinematicPTP;</code></pre>
<hr />
<h1 id="image66-modelica.blocks.sources.kinematicptp2"><img src="Modelica.Blocks.Sources.KinematicPTP2I.png" alt="image66" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.KinematicPTP2</h1>
<p><strong>Move as fast as possible from start to end position within given kinematic constraints with output signals q, qd=der(q), qdd=der(qd)</strong></p>
<h2 id="information-15">Information</h2>
<p>::</p>
<p>The goal is to move as <strong>fast</strong> as possible from start position <strong>q_begin</strong> to end position <strong>q_end</strong> under given <strong>kinematical constraints</strong>. The positions can be translational or rotational definitions (i.e., q_begin/q_end is given). In robotics such a movement is called <strong>PTP</strong> (Point-To-Point). This source block generates the <strong>position</strong> q(t), the <strong>speed</strong> qd(t) = der(q), and the <strong>acceleration</strong> qdd = der(qd) as output. The signals are constructed in such a way that it is not possible to move faster, given the <strong>maximally</strong> allowed <strong>velocity</strong> qd_max and the <strong>maximally</strong> allowed <strong>acceleration</strong> qdd_max:</p>
<p>If vectors q_begin/q_end have more than 1 element, the output vectors are constructed such that all signals are in the same periods in the acceleration, constant velocity and deceleration phase. This means that only one of the signals is at its limits whereas the others are sychnronized in such a way that the end point is reached at the same time instant.</p>
<p>This element is useful to generate a reference signal for a controller which controls, e.g., a drive train, or to drive a flange according to a given acceleration.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon">Modelica.Blocks.Interfaces.BlockIcon</a> (Basic graphical layout of input/output block).</p>
<h2 id="parameters-14">Parameters</h2>
<table>
<col width="43%" />
<col width="12%" />
<col width="9%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">q_begin[:]</td>
<td align="left">{0}</td>
<td align="left">Start position</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">q_end[:]</td>
<td align="left">
</td>
<td align="left">End position</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">qd_max[:]</td>
<td align="left">
</td>
<td align="left">Maximum velocities der(q)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">qdd_max[:]</td>
<td align="left">
</td>
<td align="left">Maximum accelerations der(qd)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Time instant at which movement starts [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-14">Connectors</h2>
<table>
<col width="45%" />
<col width="7%" />
<col width="47%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">q[nout]</td>
<td align="left">Reference position of path planning</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">qd[nout]</td>
<td align="left">Reference speed of path planning</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">qdd[nout]</td>
<td align="left">Reference acceleration of path planning</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">moving[nout]</td>
<td align="left">= true, if end position not yet reached; = false, if end position reached or axis is completely at rest</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-14">Modelica definition</h2>
<pre><code>block KinematicPTP2 
  &quot;Move as fast as possible from start to end position within given kinematic constraints with output signals q, qd=der(q), qdd=der(qd)&quot;
  import SI = Modelica.SIunits;
  parameter Real q_begin[:] = {0} &quot;Start position&quot;;
  parameter Real q_end[:] &quot;End position&quot;;
  parameter Real qd_max[:](each final min=Modelica.Constants.small) 
    &quot;Maximum velocities der(q)&quot;;
  parameter Real qdd_max[:](each final min=Modelica.Constants.small) 
    &quot;Maximum accelerations der(qd)&quot;;
  parameter Modelica.SIunits.Time startTime=0 
    &quot;Time instant at which movement starts&quot;;

  extends Modelica.Blocks.Interfaces.BlockIcon;
  final parameter Integer nout=max([size(q_begin, 1); size(q_end, 1); size(
      qd_max, 1); size(qdd_max, 1)]) 
    &quot;Number of output signals (= dimension of q, qd, qdd, moving)&quot;;
  output Modelica.SIunits.Time endTime &quot;Time instant at which movement stops&quot;;

  Modelica.Blocks.Interfaces.RealOutput q[nout] 
    &quot;Reference position of path planning&quot;;
  Modelica.Blocks.Interfaces.RealOutput qd[nout] 
    &quot;Reference speed of path planning&quot;;
  Modelica.Blocks.Interfaces.RealOutput qdd[nout] 
    &quot;Reference acceleration of path planning&quot;;
  Modelica.Blocks.Interfaces.BooleanOutput moving[nout] 
    &quot;= true, if end position not yet reached; = false, if end position reached or axis is completely at rest&quot;;


protected 
  parameter Real p_q_begin[nout]=(if size(q_begin, 1) == 1 then ones(nout)*
      q_begin[1] else q_begin);
  parameter Real p_q_end[nout]=(if size(q_end, 1) == 1 then ones(nout)*
      q_end[1] else q_end);
  parameter Real p_qd_max[nout]=(if size(qd_max, 1) == 1 then ones(nout)*
      qd_max[1] else qd_max);
  parameter Real p_qdd_max[nout]=(if size(qdd_max, 1) == 1 then ones(nout)*
      qdd_max[1] else qdd_max);
  parameter Real p_deltaq[nout]=p_q_end - p_q_begin;
  constant Real eps=10*Modelica.Constants.eps;
  Boolean motion_ref;
  Real sd_max_inv;
  Real sdd_max_inv;
  Real sd_max;
  Real sdd_max;
  Real sdd;
  Real aux1[nout];
  Real aux2[nout];
  SI.Time Ta1;
  SI.Time Ta2;
  SI.Time Tv;
  SI.Time Te;
  Boolean noWphase;
  SI.Time Ta1s;
  SI.Time Ta2s;
  SI.Time Tvs;
  SI.Time Tes;
  Real sd_max2;
  Real s1;
  Real s2;
  Real s3;
  Real s;
  Real sd;
  Real r_s;
  Real r_sd;
  Real r_sdd;

  function position
  annotation(derivative=position_der);
     input Real q_qd_qdd[3] &quot;Required values for position, speed, acceleration&quot;;
     input Real dummy 
      &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;;
     output Real q;
  algorithm 
    q :=q_qd_qdd[1];
  end position;

  function position_der
  annotation(derivative=position_der2);
     input Real q_qd_qdd[3] &quot;Required values for position, speed, acceleration&quot;;
     input Real dummy 
      &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;;
     input Real dummy_der;
     output Real qd;
  algorithm 
    qd :=q_qd_qdd[2];
  end position_der;

  function position_der2
     input Real q_qd_qdd[3] &quot;Required values for position, speed, acceleration&quot;;
     input Real dummy 
      &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;;
     input Real dummy_der;
     input Real dummy_der2;
     output Real qdd;
  algorithm 
    qdd :=q_qd_qdd[3];
  end position_der2;
equation 
  for i in 1:nout loop
    aux1[i] = p_deltaq[i]/p_qd_max[i];
    aux2[i] = p_deltaq[i]/p_qdd_max[i];
  end for;

  sd_max_inv = max(abs(aux1));
  sdd_max_inv = max(abs(aux2));

  if sd_max_inv &lt;= eps or sdd_max_inv &lt;= eps then
    sd_max = 0;
    sdd_max = 0;
    Ta1 = 0;
    Ta2 = 0;
    noWphase = false;
    Tv = 0;
    Te = 0;
    Ta1s = 0;
    Ta2s = 0;
    Tvs = 0;
    Tes = 0;
    sd_max2 = 0;
    s1 = 0;
    s2 = 0;
    s3 = 0;
    r_sdd = 0;
    r_sd = 0;
    r_s = 0;
  else
    sd_max = 1/max(abs(aux1));
    sdd_max = 1/max(abs(aux2));
    Ta1 = sqrt(1/sdd_max);
    Ta2 = sd_max/sdd_max;
    noWphase = Ta2 &gt;= Ta1;
    Tv = if noWphase then Ta1 else 1/sd_max;
    Te = if noWphase then Ta1 + Ta1 else Tv + Ta2;
    Ta1s = Ta1 + startTime;
    Ta2s = Ta2 + startTime;
    Tvs = Tv + startTime;
    Tes = Te + startTime;
    sd_max2 = sdd_max*Ta1;
    s1 = sdd_max*(if noWphase then Ta1*Ta1 else Ta2*Ta2)/2;
    s2 = s1 + (if noWphase then sd_max2*(Te - Ta1) - (sdd_max/2)*(Te - Ta1)
      ^2 else sd_max*(Tv - Ta2));
    s3 = s2 + sd_max*(Te - Tv) - (sdd_max/2)*(Te - Tv)*(Te - Tv);

    if time &lt; startTime then
      r_sdd = 0;
      r_sd = 0;
      r_s = 0;
    elseif noWphase then
      if time &lt; Ta1s then
        r_sdd = sdd_max;
        r_sd = sdd_max*(time - startTime);
        r_s = (sdd_max/2)*(time - startTime)*(time - startTime);
      elseif time &lt; Tes then
        r_sdd = -sdd_max;
        r_sd = sd_max2 - sdd_max*(time - Ta1s);
        r_s = s1 + sd_max2*(time - Ta1s) - (sdd_max/2)*(time - Ta1s)*(time
           - Ta1s);
      else
        r_sdd = 0;
        r_sd = 0;
        r_s = s2;
      end if;
    elseif time &lt; Ta2s then
      r_sdd = sdd_max;
      r_sd = sdd_max*(time - startTime);
      r_s = (sdd_max/2)*(time - startTime)*(time - startTime);
    elseif time &lt; Tvs then
      r_sdd = 0;
      r_sd = sd_max;
      r_s = s1 + sd_max*(time - Ta2s);
    elseif time &lt; Tes then
      r_sdd = -sdd_max;
      r_sd = sd_max - sdd_max*(time - Tvs);
      r_s = s2 + sd_max*(time - Tvs) - (sdd_max/2)*(time - Tvs)*(time - Tvs);
    else
      r_sdd = 0;
      r_sd = 0;
      r_s = s3;
    end if;

  end if;

  // acceleration
  qdd = p_deltaq*sdd;
  qd = p_deltaq*sd;
  q = p_q_begin + p_deltaq*s;
  endTime = Tes;

  s = position({r_s, r_sd, r_sdd}, time);
  sd = der(s);
  sdd = der(sd);

  // report when axis is moving
  motion_ref = time &lt;= endTime;
  for i in 1:nout loop
    moving[i] = if abs(q_begin[i] - q_end[i]) &gt; eps then motion_ref else false;
  end for;

end KinematicPTP2;</code></pre>
<hr />
<h1 id="image67-modelica.blocks.sources.timetable"><img src="Modelica.Blocks.Sources.TimeTableI.png" alt="image67" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.TimeTable</h1>
<p><strong>Generate a (possibly discontinuous) signal by linear interpolation in a table</strong></p>
<h2 id="information-16">Information</h2>
<p>::</p>
<p>This block generates an output signal by <strong>linear interpolation</strong> in a table. The time points and function values are stored in a matrix <strong>table[i,j]</strong>, where the first column table[:,1] contains the time points and the second column contains the data to be interpolated. The table interpolation has the following proporties:</p>
<ul>
<li>The time points need to be <strong>monotonically increasing</strong>.</li>
<li><strong>Discontinuities</strong> are allowed, by providing the same time point twice in the table.</li>
<li>Values <strong>outside</strong> of the table range, are computed by <strong>extrapolation</strong> through the last or first two points of the table.</li>
<li>If the table has only <strong>one row</strong>, no interpolation is performed and the function value is just returned independantly of the actual time instant.</li>
<li>Via parameters <strong>startTime</strong> and <strong>offset</strong> the curve defined by the table can be shifted both in time and in the ordinate value.</li>
<li>The table is implemented in a numerically sound way by generating <strong>time events</strong> at interval boundaries, in order to not integrate over a discontinuous or not differentiable points.</li>
</ul>
<p>Example:</p>
<pre><code>table = [0  0
         1  0
         1  1
         2  4
         3  9
         4 16]</code></pre>
<blockquote>
<dl>
<dt>If, e.g., time = 1.0, the output y = 0.0 (before event), 1.0 (after event)</dt>
<dd><p>e.g., time = 1.5, the output y = 2.5, e.g., time = 2.0, the output y = 4.0, e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation).</p>
</dd>
</dl>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.SO">Interfaces.SO</a> (Single Output continuous control block).</p>
<h2 id="parameters-15">Parameters</h2>
<table>
<col width="36%" />
<col width="10%" />
<col width="7%" />
<col width="45%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">table[:, 2]</td>
<td align="left">
</td>
<td align="left">Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-15">Connectors</h2>
<table>
<col width="68%" />
<col width="6%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Real output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-15">Modelica definition</h2>
<pre><code>block TimeTable 
  &quot;Generate a (possibly discontinuous) signal by linear interpolation in a table&quot;

  parameter Real table[:, 2] 
    &quot;Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])&quot;;
  parameter Real offset=0 &quot;Offset of output signal&quot;;
  parameter SIunits.Time startTime=0 &quot;Output = offset for time &lt; startTime&quot;;
  extends Interfaces.SO;
protected 
  Real a &quot;Interpolation coefficients a of actual interval (y=a*x+b)&quot;;
  Real b &quot;Interpolation coefficients b of actual interval (y=a*x+b)&quot;;
  Integer last(start=1) &quot;Last used lower grid index&quot;;
  SIunits.Time nextEvent(start=0, fixed=true) &quot;Next event instant&quot;;

  function getInterpolationCoefficients 
    &quot;Determine interpolation coefficients and next time event&quot;
    input Real table[:, 2] &quot;Table for interpolation&quot;;
    input Real offset &quot;y-offset&quot;;
    input Real startTime &quot;time-offset&quot;;
    input Real t &quot;Actual time instant&quot;;
    input Integer last &quot;Last used lower grid index&quot;;
    input Real TimeEps &quot;Relative epsilon to check for identical time instants&quot;;
    output Real a &quot;Interpolation coefficients a (y=a*x + b)&quot;;
    output Real b &quot;Interpolation coefficients b (y=a*x + b)&quot;;
    output Real nextEvent &quot;Next event instant&quot;;
    output Integer next &quot;New lower grid index&quot;;
  protected 
    Integer columns=2 &quot;Column to be interpolated&quot;;
    Integer ncol=2 &quot;Number of columns to be interpolated&quot;;
    Integer nrow=size(table, 1) &quot;Number of table rows&quot;;
    Integer next0;
    Real tp;
    Real dt;
  algorithm 
    next := last;
    nextEvent := t - TimeEps*abs(t);
    // in case there are no more time events
    tp := t + TimeEps*abs(t) - startTime;

    if tp &lt; 0.0 then
      // First event not yet reached
      nextEvent := startTime;
      a := 0;
      b := offset;
    elseif nrow &lt; 2 then
      // Special action if table has only one row
      a := 0;
      b := offset + table[1, columns];
    else

        // Find next time event instant. Note, that two consecutive time instants
      // in the table may be identical due to a discontinuous point.
      while next &lt; nrow and tp &gt;= table[next, 1] loop
        next := next + 1;
      end while;

      // Define next time event, if last table entry not reached
      if next &lt; nrow then
        nextEvent := startTime + table[next, 1];
      end if;

      // Determine interpolation coefficients
      next0 := next - 1;
      dt := table[next, 1] - table[next0, 1];
      if dt &lt;= TimeEps*abs(table[next, 1]) then
        // Interpolation interval is not big enough, use &quot;next&quot; value
        a := 0;
        b := offset + table[next, columns];
      else
        a := (table[next, columns] - table[next0, columns])/dt;
        b := offset + table[next0, columns] - a*table[next0, 1];
      end if;
    end if;
    // Take into account startTime &quot;a*(time - startTime) + b&quot;
    b := b - a*startTime;
  end getInterpolationCoefficients;
algorithm 
  when {time &gt;= pre(nextEvent),initial()} then
    (a,b,nextEvent,last) := getInterpolationCoefficients(table, offset,
      startTime, time, last, 100*Modelica.Constants.eps);
  end when;
equation 
  y = a*time + b;
end TimeTable;</code></pre>
<hr />
<h1 id="image68-modelica.blocks.sources.combitimetable"><img src="Modelica.Blocks.Sources.CombiTimeTableI.png" alt="image68" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.CombiTimeTable</h1>
<p><strong>Table look-up with respect to time and linear/perodic extrapolation methods (data from matrix/file)</strong></p>
<h2 id="information-17">Information</h2>
<p>::</p>
<p>This block generates an output signal y[:] by <strong>linear interpolation</strong> in a table. The time points and function values are stored in a matrix <strong>table[i,j]</strong>, where the first column table[:,1] contains the time points and the other columns contain the data to be interpolated.</p>
<p>Via parameter <strong>columns</strong> it can be defined which columns of the table are interpolated. If, e.g., columns={2,4}, it is assumed that 2 output signals are present and that the first output is computed by interpolation of column 2 and the second output is computed by interpolation of column 4 of the table matrix. The table interpolation has the following properties:</p>
<ul>
<li>The time points need to be <strong>monotonically increasing</strong>.</li>
<li><strong>Discontinuities</strong> are allowed, by providing the same time point twice in the table.</li>
<li><p>Values <strong>outside</strong> of the table range, are computed by extrapolation according to the setting of parameter <strong>extrapolation</strong>:</p>
<pre><code>extrapolation = 0: hold the first or last value of the table,
                   if outside of the range.
              = 1: extrapolate through the last or first two
                   points of the table.
              = 2: periodically repeat the table data
                   (periodical function).</code></pre></li>
<li><p>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:</p>
<pre><code>smoothness = 0: linear interpolation
           = 1: smooth interpolation with Akima Splines such
                that der(y) is continuous.</code></pre></li>
<li>If the table has only <strong>one row</strong>, no interpolation is performed and the table values of this row are just returned.</li>
<li>Via parameters <strong>startTime</strong> and <strong>offset</strong> the curve defined by the table can be shifted both in time and in the ordinate value. The time instants stored in the table are therefore <strong>relative</strong> to <strong>startTime</strong>. If time &lt; startTime, no interpolation is performed and the offset is used as ordinate value for all outputs.</li>
<li>The table is implemented in a numerically sound way by generating <strong>time events</strong> at interval boundaries, in order to not integrate over a discontinuous or not differentiable points.</li>
<li><p>For special applications it is sometimes needed to know the minimum and maximum time instant defined in the table as a parameter. For this reason parameters <strong>t_min</strong> and <strong>t_max</strong> are provided and can be access from the outside of the table object.</p></li>
</ul>
<p>Example:</p>
<pre><code>table = [0  0
         1  0
         1  1
         2  4
         3  9
         4 16]; extrapolation = 1 (default)</code></pre>
<blockquote>
<dl>
<dt>If, e.g., time = 1.0, the output y = 0.0 (before event), 1.0 (after event)</dt>
<dd><p>e.g., time = 1.5, the output y = 2.5, e.g., time = 2.0, the output y = 4.0, e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation via last 2 points).</p>
</dd>
</dl>
</blockquote>
<p>The table matrix can be defined in the following ways:</p>
<ol>
<li><p>Explicitly supplied as <strong>parameter matrix</strong> &quot;table&quot;, and the other parameters have the following values:</p>
<pre><code>tableName is &quot;NoName&quot; or has only blanks,
fileName  is &quot;NoName&quot; or has only blanks.</code></pre></li>
<li><p><strong>Read</strong> from a <strong>file</strong> &quot;fileName&quot; where the matrix is stored as &quot;tableName&quot;. Both ASCII and binary file format is possible. (the ASCII format is described below). It is most convenient to generate the binary file from Matlab (Matlab 4 storage format), e.g., by command</p>
<pre><code>save tables.mat tab1 tab2 tab3 -V4</code></pre>
<p>when the three tables tab1, tab2, tab3 should be used from the model.</p></li>
<li><p>Statically stored in function &quot;usertab&quot; in file &quot;usertab.c&quot;. The matrix is identified by &quot;tableName&quot;. Parameter fileName = &quot;NoName&quot; or has only blanks.</p></li>
</ol>
<p>Table definition methods (1) and (3) do <strong>not</strong> allocate dynamic memory, and do not access files, whereas method (2) does. Therefore (1) and (3) are suited for hardware-in-the-loop simulation (e.g., with dSpace hardware). When the constant &quot;NO_FILE&quot; is defined in &quot;usertab.c&quot;, all parts of the source code of method (2) are removed by the C-preprocessor, such that no dynamic memory allocation and no access to files takes place.</p>
<p>If tables are read from an ASCII-file, the file need to have the following structure (&quot;-----&quot; is not part of the file content):</p>
<pre><code>-----------------------------------------------------
#1
double tab1(6,2)   # comment line
  0   0
  1   0
  1   1
  2   4
  3   9
  4  16
double tab2(6,2)   # another comment line
  0   0
  2   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------</code></pre>
<p>Note, that the first two characters in the file need to be &quot;#1&quot;. Afterwards, the corresponding matrix has to be declared with type, name and actual dimensions. Finally, in successive rows of the file, the elements of the matrix have to be given. Several matrices may be defined one after another.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.MO">Modelica.Blocks.Interfaces.MO</a> (Multiple Output continuous control block).</p>
<h2 id="parameters-16">Parameters</h2>
<table>
<col width="42%" />
<col width="8%" />
<col width="17%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">nout</td>
<td align="left">max([size(columns, 1); size(...</td>
<td align="left">Number of outputs</td>
</tr>
<tr class="even">
<td align="left">table data definition</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">tableOnFile</td>
<td align="left">false</td>
<td align="left">= true, if table is defined on file or in function usertab</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">table[:, :]</td>
<td align="left">fill(0.0, 0, 2)</td>
<td align="left">Table matrix (time = first column; e.g., table=[0,2])</td>
</tr>
<tr class="odd">
<td align="left">String</td>
<td align="left">tableName</td>
<td align="left">&quot;NoName&quot;</td>
<td align="left">Table name on file or in function usertab (see docu)</td>
</tr>
<tr class="even">
<td align="left">String</td>
<td align="left">fileName</td>
<td align="left">&quot;NoName&quot;</td>
<td align="left">File where matrix is stored</td>
</tr>
<tr class="odd">
<td align="left">table data interpretation</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">columns[:]</td>
<td align="left">2:size(table, 2)</td>
<td align="left">Columns of table to be interpolated</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Blocks_Types.html#Modelica.Blocks.Types.Smoothness">Smoothness</a></td>
<td align="left">smoothness</td>
<td align="left">Modelica.Blocks.Types.Smooth...</td>
<td align="left">Smoothness of table interpolation</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Blocks_Types.html#Modelica.Blocks.Types.Extrapolation">Extrapolation</a></td>
<td align="left">extrapolation</td>
<td align="left">Modelica.Blocks.Types.Extrap...</td>
<td align="left">Extrapolation of data outside the definition range</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">offset[:]</td>
<td align="left">{0}</td>
<td align="left">Offsets of output signals</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-16">Connectors</h2>
<table>
<col width="66%" />
<col width="8%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">y[nout]</td>
<td align="left">Connector of Real output signals</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-16">Modelica definition</h2>
<pre><code>model CombiTimeTable 
  &quot;Table look-up with respect to time and linear/perodic extrapolation methods (data from matrix/file)&quot;

  parameter Boolean tableOnFile=false 
    &quot;= true, if table is defined on file or in function usertab&quot;;
  parameter Real table[:, :] = fill(0.0,0,2) 
    &quot;Table matrix (time = first column; e.g., table=[0,2])&quot;;
  parameter String tableName=&quot;NoName&quot; 
    &quot;Table name on file or in function usertab (see docu)&quot;;
  parameter String fileName=&quot;NoName&quot; &quot;File where matrix is stored&quot;;
  parameter Integer columns[:]=2:size(table, 2) 
    &quot;Columns of table to be interpolated&quot;;
  parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments 
    &quot;Smoothness of table interpolation&quot;;
  parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints 
    &quot;Extrapolation of data outside the definition range&quot;;
  parameter Real offset[:]={0} &quot;Offsets of output signals&quot;;
  parameter Modelica.SIunits.Time startTime=0 
    &quot;Output = offset for time &lt; startTime&quot;;
  extends Modelica.Blocks.Interfaces.MO(final nout=max([size(columns, 1); size(offset, 1)]));
  final parameter Real t_min(fixed=false) 
    &quot;Minimum abscissa value defined in table&quot;;
  final parameter Real t_max(fixed=false) 
    &quot;Maximum abscissa value defined in table&quot;;

protected 
  final parameter Real p_offset[nout]=(if size(offset, 1) == 1 then ones(nout)
       *offset[1] else offset);

  Integer tableID;

  function tableTimeInit 
    &quot;Initialize 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)&quot;
    input String tableName;
    input String fileName;
    input Real table[ :, :];
    input Real startTime;
    input Modelica.Blocks.Types.Smoothness smoothness;
    input Modelica.Blocks.Types.Extrapolation extrapolation;
    output Integer tableID;
  external &quot;C&quot; tableID=  ModelicaTables_CombiTimeTable_init(
                 tableName, fileName, table, size(table, 1), size(table, 2),
                 startTime, smoothness, extrapolation);
  end tableTimeInit;

  function tableTimeIpo 
    &quot;Interpolate 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)&quot;
    input Integer tableID;
    input Integer icol;
    input Real timeIn;
    output Real value;
  external &quot;C&quot; value =
                     ModelicaTables_CombiTimeTable_interpolate(tableID, icol, timeIn);
  end tableTimeIpo;

  function tableTimeTmin 
    &quot;Return minimum time value of 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)&quot;
    input Integer tableID;
    output Real Tmin &quot;minimum time value in table&quot;;
  external &quot;C&quot; Tmin =
                    ModelicaTables_CombiTimeTable_minimumTime(tableID);
  end tableTimeTmin;

  function tableTimeTmax 
    &quot;Return maximum time value of 1-dim. table where first column is time (for details see: Modelica/Resources/C-Sources/ModelicaTables.h)&quot;
    input Integer tableID;
    output Real Tmax &quot;maximum time value in table&quot;;
  external &quot;C&quot; Tmax =
                    ModelicaTables_CombiTimeTable_maximumTime(tableID);
  end tableTimeTmax;

equation 
  if tableOnFile then
    assert(tableName&lt;&gt;&quot;NoName&quot;, &quot;tableOnFile = true and no table name given&quot;);
  end if;
  if not tableOnFile then
    assert(size(table,1) &gt; 0 and size(table,2) &gt; 0, &quot;tableOnFile = false and parameter table is an empty matrix&quot;);
  end if;
  for i in 1:nout loop
    y[i] = p_offset[i] + tableTimeIpo(tableID, columns[i], time);
  end for;
  when initial() then
    tableID=tableTimeInit((if not tableOnFile then &quot;NoName&quot; else tableName),
                          (if not tableOnFile then &quot;NoName&quot; else fileName), table,
                          startTime, smoothness, extrapolation);
  end when;
initial equation 
    t_min=tableTimeTmin(tableID);
    t_max=tableTimeTmax(tableID);
end CombiTimeTable;</code></pre>
<hr />
<h1 id="image69-modelica.blocks.sources.booleanconstant"><img src="Modelica.Blocks.Sources.BooleanConstantI.png" alt="image69" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.BooleanConstant</h1>
<p><strong>Generate constant signal of type Boolean</strong></p>
<h2 id="information-18">Information</h2>
<p>::</p>
<p>The Boolean output y is a constant signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.partialBooleanSource">Interfaces.partialBooleanSource</a> (Partial source block (has 1 output Boolean signal and an appropriate default icon)).</p>
<h2 id="parameters-17">Parameters</h2>
<table>
<col width="16%" />
<col width="12%" />
<col width="16%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">k</td>
<td align="left">true</td>
<td align="left">Constant output value</td>
</tr>
</tbody>
</table>
<h2 id="connectors-17">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Boolean output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-17">Modelica definition</h2>
<pre><code>block BooleanConstant &quot;Generate constant signal of type Boolean&quot;
  parameter Boolean k=true &quot;Constant output value&quot;;
  extends Interfaces.partialBooleanSource;

equation 
  y = k;
end BooleanConstant;</code></pre>
<hr />
<h1 id="image70-modelica.blocks.sources.booleanstep"><img src="Modelica.Blocks.Sources.BooleanStepI.png" alt="image70" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.BooleanStep</h1>
<p><strong>Generate step signal of type Boolean</strong></p>
<h2 id="information-19">Information</h2>
<p>::</p>
<p>The Boolean output y is a step signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.partialBooleanSource">Interfaces.partialBooleanSource</a> (Partial source block (has 1 output Boolean signal and an appropriate default icon)).</p>
<h2 id="parameters-18">Parameters</h2>
<table>
<col width="48%" />
<col width="12%" />
<col width="10%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Time instant of step start [s]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">startValue</td>
<td align="left">false</td>
<td align="left">Output before startTime</td>
</tr>
</tbody>
</table>
<h2 id="connectors-18">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Boolean output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-18">Modelica definition</h2>
<pre><code>block BooleanStep &quot;Generate step signal of type Boolean&quot;
  parameter Modelica.SIunits.Time startTime=0 &quot;Time instant of step start&quot;;
  parameter Boolean startValue = false &quot;Output before startTime&quot;;

  extends Interfaces.partialBooleanSource;
equation 
 y = if time &gt;= startTime then not startValue else startValue;
end BooleanStep;</code></pre>
<hr />
<h1 id="image71-modelica.blocks.sources.booleanpulse"><img src="Modelica.Blocks.Sources.BooleanPulseI.png" alt="image71" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.BooleanPulse</h1>
<p><strong>Generate pulse signal of type Boolean</strong></p>
<h2 id="information-20">Information</h2>
<p>::</p>
<p>The Boolean output y is a pulse signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.partialBooleanSource">Modelica.Blocks.Interfaces.partialBooleanSource</a> (Partial source block (has 1 output Boolean signal and an appropriate default icon)).</p>
<h2 id="parameters-19">Parameters</h2>
<table>
<col width="48%" />
<col width="11%" />
<col width="10%" />
<col width="30%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">width</td>
<td align="left">50</td>
<td align="left">Width of pulse in % of period</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">period</td>
<td align="left">
</td>
<td align="left">Time for one period [s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Time instant of first pulse [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-19">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Boolean output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-19">Modelica definition</h2>
<pre><code>block BooleanPulse &quot;Generate pulse signal of type Boolean&quot;

  parameter Real width(
    final min=Modelica.Constants.small,
    final max=100) = 50 &quot;Width of pulse in % of period&quot;;
  parameter Modelica.SIunits.Time period(final min=Modelica.Constants.small,start=1) 
    &quot;Time for one period&quot;;
  parameter Modelica.SIunits.Time startTime=0 &quot;Time instant of first pulse&quot;;
  extends Modelica.Blocks.Interfaces.partialBooleanSource;

protected 
  parameter Modelica.SIunits.Time Twidth=period*width/100 &quot;width of one pulse&quot;;
  discrete Modelica.SIunits.Time pulsStart &quot;Start time of pulse&quot;;
initial equation 
  pulsStart = startTime;
equation 
    when sample(startTime, period) then
      pulsStart = time;
    end when;
    y = time &gt;= pulsStart and time &lt; pulsStart + Twidth;
end BooleanPulse;</code></pre>
<hr />
<h1 id="image72-modelica.blocks.sources.sampletrigger"><img src="Modelica.Blocks.Sources.SampleTriggerI.png" alt="image72" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.SampleTrigger</h1>
<p><strong>Generate sample trigger signal</strong></p>
<h2 id="information-21">Information</h2>
<p>::</p>
<p>The Boolean output y is a trigger signal where the output y is only <strong>true</strong> at sample times (defined by parameter <strong>period</strong>) and is otherwise <strong>false</strong>.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.partialBooleanSource">Interfaces.partialBooleanSource</a> (Partial source block (has 1 output Boolean signal and an appropriate default icon)).</p>
<h2 id="parameters-20">Parameters</h2>
<table>
<col width="44%" />
<col width="10%" />
<col width="9%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">period</td>
<td align="left">
</td>
<td align="left">Sample period [s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Time instant of first sample trigger [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-20">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Boolean output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-20">Modelica definition</h2>
<pre><code>block SampleTrigger &quot;Generate sample trigger signal&quot;
  parameter Modelica.SIunits.Time period(final min=Modelica.Constants.small,start=0.01) 
    &quot;Sample period&quot;;
  parameter Modelica.SIunits.Time startTime=0 
    &quot;Time instant of first sample trigger&quot;;
  extends Interfaces.partialBooleanSource;

equation 
  y = sample(startTime, period);
end SampleTrigger;</code></pre>
<hr />
<h1 id="image73-modelica.blocks.sources.booleantable"><img src="Modelica.Blocks.Sources.BooleanTableI.png" alt="image73" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.BooleanTable</h1>
<p><strong>Generate a Boolean output signal based on a vector of time instants</strong></p>
<h2 id="information-22">Information</h2>
<p>::</p>
<p>The Boolean output y is a signal defined by parameter vector <strong>table</strong>. In the vector time points are stored. At every time point, the output y changes its value to the negated value of the previous one.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.partialBooleanSource">Interfaces.partialBooleanSource</a> (Partial source block (has 1 output Boolean signal and an appropriate default icon)).</p>
<h2 id="parameters-21">Parameters</h2>
<table>
<col width="29%" />
<col width="7%" />
<col width="6%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">startValue</td>
<td align="left">false</td>
<td align="left">Start value of y. At time = table[1], y changes to 'not startValue'</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">table[:]</td>
<td align="left">
</td>
<td align="left">Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1}) [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-21">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Boolean output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-21">Modelica definition</h2>
<pre><code>block BooleanTable 
  &quot;Generate a Boolean output signal based on a vector of time instants&quot;

  parameter Boolean startValue = false 
    &quot;Start value of y. At time = table[1], y changes to &#39;not startValue&#39;&quot;;
  parameter Modelica.SIunits.Time table[:] 
    &quot;Vector of time points. At every time point, the output y gets its opposite value (e.g., table={0,1})&quot;;
  extends Interfaces.partialBooleanSource;

protected 
  function getFirstIndex &quot;Get first index of table and check table&quot;
    input Real table[:] &quot;Vector of time instants&quot;;
    input Modelica.SIunits.Time simulationStartTime &quot;Simulation start time&quot;;
    input Boolean startValue &quot;Value of y for y &lt; table[1]&quot;;
    output Integer index &quot;First index to be used&quot;;
    output Modelica.SIunits.Time nextTime &quot;Time instant of first event&quot;;
    output Boolean y &quot;Value of y at simulationStartTime&quot;;
  protected 
    Modelica.SIunits.Time t_last;
    Integer j;
    Integer n=size(table,1) &quot;Number of table points&quot;;
  algorithm 
    if size(table,1) == 0 then
       index :=0;
       nextTime :=-Modelica.Constants.inf;
       y :=startValue;
    elseif size(table,1) == 1 then
       index :=1;
       if table[1] &gt; simulationStartTime then
          nextTime :=table[1];
          y        :=startValue;
       else
          nextTime :=simulationStartTime;
          y        :=startValue;
       end if;
    else

    // Check whether time values are strict monotonically increasing
      t_last :=table[1];
      for i in 2:n loop
         assert(table[i] &gt; t_last,
           &quot;Time values of table not strict monotonically increasing: table[&quot; +
           String(i-1) + &quot;] = &quot; + String(table[i-1]) + &quot;table[&quot; + String(i)   +
           &quot;] = &quot; + String(table[i]));
      end for;

      // Determine first index in table
      j := 1;
      y := startValue;
      while j &lt; n and table[j] &lt;= simulationStartTime loop
        y :=not  y;
        j := j + 1;
      end while;

      if j == 1 then
         nextTime := table[1];
         y        := startValue;
      elseif j == n and table[n] &lt;= simulationStartTime then
         nextTime := simulationStartTime - 1;
         y        :=not  y;
      else
         nextTime := table[j];
      end if;

      index := j;
    end if;
  end getFirstIndex;

  parameter Integer n = size(table,1) &quot;Number of table points&quot;;
  Modelica.SIunits.Time nextTime;
  Integer index &quot;Index of actual table entry&quot;;
initial algorithm 
  (index, nextTime, y) :=getFirstIndex(table, time, startValue);
algorithm 
  when time &gt;= pre(nextTime) and n &gt; 0 then
     if index &lt; n then
        index    := index + 1;
        nextTime := table[index];
        y        :=not  y;
     elseif index == n then
        index := index + 1;
        y     :=not  y;
     end if;
  end when;
end BooleanTable;</code></pre>
<hr />
<h1 id="image74-modelica.blocks.sources.radiobuttonsource"><img src="Modelica.Blocks.Sources.RadioButtonSourceI.png" alt="image74" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.RadioButtonSource</h1>
<p><strong>Boolean signal source that mimis a radio button</strong></p>
<h2 id="information-23">Information</h2>
<p>::</p>
<p>Boolean signal source that mimics a radio button: Via a table, a radio button is pressed (i.e., the output 'on' is set to true) and is reset when an element of the Boolean vector 'reset' becomes true. If both appear at the same time instant, setting the button according to the table has a higher priority as reseting the button. Example:</p>
<pre><code>RadioButtonSource start(buttonTimeTable={1,3}, reset={stop.on});
RadioButtonSource stop (buttonTimeTable={2,4}, reset={start.on});</code></pre>
<p>The &quot;start&quot; button is pressed at time=1 s and time=3 s, whereas the &quot;stop&quot; button is pressed at time=2 s and time=4 s. This gives the following result:</p>
<blockquote>
<div class="figure">
<img src="../Resources/Images/Blocks/Sources/RadioButtonSource.png" alt="image75" /><p class="caption">image75</p>
</div>
</blockquote>
<p>This example is also available in <a href="Modelica_Blocks_Examples.html#Modelica.Blocks.Examples.Interaction1">Modelica.Blocks.Examples.Interaction1</a></p>
<p>::</p>
<h2 id="parameters-22">Parameters</h2>
<table>
<col width="37%" />
<col width="14%" />
<col width="7%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">buttonTimeTable[:]</td>
<td align="left">
</td>
<td align="left">Time instants where button is pressed [s]</td>
</tr>
<tr class="even">
<td align="left">Time varying expressions</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">reset[:]</td>
<td align="left">{false}</td>
<td align="left">Reset button to false, if an element of reset becomes true</td>
</tr>
</tbody>
</table>
<h2 id="connectors-22">Connectors</h2>
<table>
<col width="80%" />
<col width="7%" />
<col width="12%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BooleanOutput">BooleanOutput</a></td>
<td align="left">on</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-22">Modelica definition</h2>
<pre><code>block RadioButtonSource 
  &quot;Boolean signal source that mimis a radio button&quot;

  parameter Modelica.SIunits.Time buttonTimeTable[:] 
    &quot;Time instants where button is pressed&quot;;
  input Boolean reset[:]={false} 
    &quot;Reset button to false, if an element of reset becomes true&quot;;

  Modelica.Blocks.Interfaces.BooleanOutput on(start=false,fixed=true);
protected 
  Modelica.Blocks.Sources.BooleanTable table(table=buttonTimeTable);
  parameter Integer nReset = size(reset,1);
  Boolean pre_reset[nReset];
initial equation 
  pre(pre_reset)=fill(false,nReset);
  pre(reset) = fill(false,nReset);
algorithm 
  pre_reset :=pre(reset);
  when pre_reset then
     on := false;
  end when;

  when change(table.y) then
     on := true;
  end when;

end RadioButtonSource;</code></pre>
<hr />
<h1 id="image76-modelica.blocks.sources.integerconstant"><img src="Modelica.Blocks.Sources.IntegerConstantI.png" alt="image76" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.IntegerConstant</h1>
<p><strong>Generate constant signal of type Integer</strong></p>
<h2 id="information-24">Information</h2>
<p>::</p>
<p>The Integer output y is a constant signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerSO">Interfaces.IntegerSO</a> (Single Integer Output continuous control block).</p>
<h2 id="parameters-23">Parameters</h2>
<table>
<col width="16%" />
<col width="12%" />
<col width="16%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">k</td>
<td align="left">
</td>
<td align="left">Constant output value</td>
</tr>
</tbody>
</table>
<h2 id="connectors-23">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerOutput">IntegerOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Integer output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-23">Modelica definition</h2>
<pre><code>block IntegerConstant &quot;Generate constant signal of type Integer&quot;
  parameter Integer k(start=1) &quot;Constant output value&quot;;
  extends Interfaces.IntegerSO;

equation 
  y = k;
end IntegerConstant;</code></pre>
<hr />
<h1 id="image77-modelica.blocks.sources.integerstep"><img src="Modelica.Blocks.Sources.IntegerStepI.png" alt="image77" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.IntegerStep</h1>
<p><strong>Generate step signal of type Integer</strong></p>
<h2 id="information-25">Information</h2>
<p>::</p>
<p>The Integer output y is a step signal:</p>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerSignalSource">Interfaces.IntegerSignalSource</a> (Base class for continuous Integer signal source).</p>
<h2 id="parameters-24">Parameters</h2>
<table>
<col width="44%" />
<col width="10%" />
<col width="9%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">height</td>
<td align="left">1</td>
<td align="left">Height of step</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">offset</td>
<td align="left">0</td>
<td align="left">Offset of output signal y</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Time">Time</a></td>
<td align="left">startTime</td>
<td align="left">0</td>
<td align="left">Output y = offset for time &lt; startTime [s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-24">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerOutput">IntegerOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Integer output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-24">Modelica definition</h2>
<pre><code>block IntegerStep &quot;Generate step signal of type Integer&quot;
  parameter Integer height=1 &quot;Height of step&quot;;
  extends Interfaces.IntegerSignalSource;
equation 
  y = offset + (if time &lt; startTime then 0 else height);
end IntegerStep;</code></pre>
<hr />
<h1 id="image78-modelica.blocks.sources.integertable"><img src="Modelica.Blocks.Sources.IntegerTableI.png" alt="image78" /> <a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources">Modelica.Blocks.Sources</a>.IntegerTable</h1>
<p><strong>Generate an Integer output signal based on a table matrix with [time, yi] values</strong></p>
<h2 id="information-26">Information</h2>
<p>::</p>
<p>This block generates an Integer output signal by using a table. The time points and y-values are stored in a matrix <strong>table[i,j]</strong>, where the first column table[:,1] contains the Real time points and the second column contains the Integer value of the output y at this time point.</p>
<p>An assert is triggered, if no table values are provided, if the time points are not strict monotonically increasing, or if the second column of the table matrix does not contain Integer values.</p>
<p>If the simulation time is less than the first table time instant, then the output y = table[1,2]. If the simulation time is greater than the last table time instant, then the output y = table[end,2].</p>
<p>Example:</p>
<pre><code>table = [  0, 1;
           1, 4;
         1.5, 5;
           2, 6];</code></pre>
<p>results in the following output:</p>
<blockquote>

</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerSO">Interfaces.IntegerSO</a> (Single Integer Output continuous control block).</p>
<h2 id="parameters-25">Parameters</h2>
<table>
<col width="9%" />
<col width="16%" />
<col width="18%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">table[:, 2]</td>
<td align="left">fill(0, 0, 2)</td>
<td align="left">Table matrix (first column: time; second column: y)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-25">Connectors</h2>
<table>
<col width="68%" />
<col width="5%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.IntegerOutput">IntegerOutput</a></td>
<td align="left">y</td>
<td align="left">Connector of Integer output signal</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-25">Modelica definition</h2>
<pre><code>block IntegerTable 
  &quot;Generate an Integer output signal based on a table matrix with [time, yi] values&quot;

  parameter Real table[:, 2] = fill(0, 0, 2) 
    &quot;Table matrix (first column: time; second column: y)&quot;;

  extends Interfaces.IntegerSO;

protected 
  function getFirstIndex &quot;Get first index of table and check table&quot;
    input Real table[:,2] &quot;Table matrix&quot;;
    input Modelica.SIunits.Time simulationStartTime &quot;Simulation start time&quot;;
    output Integer index &quot;First index to be used&quot;;
    output Modelica.SIunits.Time nextTime &quot;Time instant of first event&quot;;
    output Integer y &quot;Value of y at simulationStartTime&quot;;
  protected 
    Modelica.SIunits.Time t_last;
    Integer j;
    Integer n=size(table,1) &quot;Number of table points&quot;;
  algorithm 
    if size(table,1) == 0 then
       index :=0;
       nextTime := simulationStartTime - 1;
       y :=0;
    else
       // Check whether time values are strict monotonically increasing
       t_last :=table[1,1];
       for i in 2:n loop
          assert(table[i,1] &gt; t_last,
            &quot;Time values of table not strict monotonically increasing: table[&quot; +
            String(i-1) + &quot;,1] = &quot; + String(table[i-1,1]) + &quot;table[&quot; + String(i)   +
            &quot;,1] = &quot; + String(table[i,1]));
       end for;

       // Check that all values in the second column are Integer values
       for i in 1:n loop
          assert(rem(table[i,2],1) == 0.0, &quot;Table value is not an Integer: table[&quot; +
            String(i) + &quot;,2] = &quot; + String(table[i,2]));
       end for;

       // Determine index in table for &quot;nextTime&quot;
       j := 1;
       y := integer(table[1,2]);
       while j &lt; n and table[j,1] &lt;= simulationStartTime loop
         j := j + 1;
       end while;

       if j == 1 then
          nextTime := table[1,1];
          y        := integer(table[1,2]);
       elseif j == n and table[n,1] &lt;= simulationStartTime then
          nextTime := simulationStartTime - 1;
          y        := integer(table[n,2]);
       else
          nextTime := table[j,1];
          y        := integer(table[j-1,2]);
       end if;

       index := j;
    end if;
  end getFirstIndex;

  parameter Integer n = size(table,1) &quot;Number of table points&quot;;
  Modelica.SIunits.Time nextTime;
  Integer index &quot;Index of actual table entry&quot;;
initial algorithm 
  (index, nextTime, y) :=getFirstIndex(table, time);
equation 
  assert(size(table,1) &gt; 0, &quot;No table values defined.&quot;);
  when time &gt;= pre(nextTime) then
     y        = integer(table[pre(index),2]);
     index    = pre(index) + 1;
     nextTime = if index &lt;= n then table[index,1] else pre(nextTime) - 1;
  end when;
end IntegerTable;</code></pre>
<hr />
<h1 id="modelica.blocks.sources.kinematicptp2.position_der"><a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.KinematicPTP2">Modelica.Blocks.Sources.KinematicPTP2</a>.position_der</h1>
<h2 id="inputs">Inputs</h2>
<table>
<col width="5%" />
<col width="10%" />
<col width="7%" />
<col width="76%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">q_qd_qdd[3]</td>
<td align="left">
</td>
<td align="left">Required values for position, speed, acceleration</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">dummy</td>
<td align="left">
</td>
<td align="left">Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">dummy_der</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="outputs">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">qd</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-26">Modelica definition</h2>
<pre><code>function position_der
  annotation(derivative=position_der2);
   input Real q_qd_qdd[3] &quot;Required values for position, speed, acceleration&quot;;
   input Real dummy 
    &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;;
   input Real dummy_der;
   output Real qd;
algorithm 
  qd :=q_qd_qdd[2];
end position_der;</code></pre>
<hr />
<h1 id="modelica.blocks.sources.kinematicptp2.position_der2"><a href="Modelica_Blocks_Sources.html#Modelica.Blocks.Sources.KinematicPTP2">Modelica.Blocks.Sources.KinematicPTP2</a>.position_der2</h1>
<h2 id="inputs-1">Inputs</h2>
<table>
<col width="5%" />
<col width="10%" />
<col width="7%" />
<col width="76%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">q_qd_qdd[3]</td>
<td align="left">
</td>
<td align="left">Required values for position, speed, acceleration</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">dummy</td>
<td align="left">
</td>
<td align="left">Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">dummy_der</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">dummy_der2</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="outputs-1">Outputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">qdd</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-27">Modelica definition</h2>
<pre><code>function position_der2
   input Real q_qd_qdd[3] &quot;Required values for position, speed, acceleration&quot;;
   input Real dummy 
    &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;;
   input Real dummy_der;
   input Real dummy_der2;
   output Real qdd;
algorithm 
  qdd :=q_qd_qdd[3];
end position_der2;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:27:40 2010.</p>
</body>
</html>
