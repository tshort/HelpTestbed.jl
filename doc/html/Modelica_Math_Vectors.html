<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Math.Vectors</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Math.Vectors</h1>
</div>
<h1 id="modelica.math.vectors"><a href="Modelica_Math.html#Modelica.Math">Modelica.Math</a>.Vectors</h1>
<p><strong>Library of functions operating on vectors</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<h3 id="library-content">Library content</h3>
<p>This library provides functions operating on vectors:</p>
<ul>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.toString">toString</a>(v)

- returns the string representation of vector v.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual">isEqual</a>(v1, v2) - returns true if vectors v1 and v2 have the same size and the same elements.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.norm">norm</a>(v,p)

- returns the p-norm of vector v.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length">length</a>(v)

- returns the length of vector v (= norm(v,2), but inlined and therefore usable in symbolic manipulations)</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.normalize">normalize</a>(v)

- returns vector in direction of v with lenght = 1 and prevents zero-division for zero vector.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.reverse">reverse</a>(v)

- reverses the vector elements of v.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.sort">sort</a>(v) -sorts the elements of vector v in ascending or descending order.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.find">find</a>(e, v)

- returns the index of the first occurence of scalar e in vector v.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.interpolate">interpolate</a>(x, y, xi) - returns the interpolated value in (x,y) that corresponds to xi.</li>
<li><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.relNodePositions">relNodePositions</a>(nNodes)

<ul>
<li>returns a vector of relative node positions (0..1).</li>
</ul></li>
</ul>
<h3 id="see-also">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices">Matrices</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="52%" />
<col width="47%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Math.tempInterpol1S.png" alt="image11" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.toString">toString</a></td>
<td align="left">Convert a real vector in to a string representation</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Vectors.isEqualS.png" alt="image12" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual">isEqual</a></td>
<td align="left">Determine if two Real vectors are numerically identical</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Vectors.isEqualS.png" alt="image13" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.norm">norm</a></td>
<td align="left">Return the p-norm of a vector</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Vectors.isEqualS.png" alt="image14" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length">length</a></td>
<td align="left">Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Vectors.isEqualS.png" alt="image15" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.normalize">normalize</a></td>
<td align="left">Return normalized vector such that length = 1 and prevent zero-division for zero vector</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Vectors.isEqualS.png" alt="image16" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.reverse">reverse</a></td>
<td align="left">Reverse vector elements (e.g., v[1] becomes last element)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Vectors.isEqualS.png" alt="image17" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.sort">sort</a></td>
<td align="left">Sort elements of vector in ascending or descending order</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Vectors.isEqualS.png" alt="image18" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.find">find</a></td>
<td align="left">Find element in a vector</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Vectors.interpolateS.png" alt="image19" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.interpolate">interpolate</a></td>
<td align="left">Interpolate in a vector</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Math.Vectors.interpolateS.png" alt="image20" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.relNodePositions">relNodePositions</a></td>
<td align="left">Return vector of relative node positions (0..1)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Math.Vectors.UtilitiesS.png" alt="image21" /> <a href="Modelica_Math_Vectors_Utilities.html#Modelica.Math.Vectors.Utilities">Utilities</a></td>
<td align="left">Utility functions that should not be directly utilized by the user</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="modelica.math.vectors.tostring"><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.toString</h1>
<p><strong>Convert a real vector in to a string representation</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<h3 id="syntax">Syntax</h3>
<blockquote>
<pre><code>Vectors.toString(v);
Vectors.toString(v,name=&quot;&quot;,significantDigits=6);</code></pre>
</blockquote>
<h3 id="description">Description</h3>
<p>The function call &quot;<code>Vectors.toString(v)</code>&quot; returns the string representation of vector <strong>v</strong>. With the optional arguments &quot;name&quot; and &quot;significantDigits&quot; a name and the number of the digits are defined. The default values of &quot;name&quot; and &quot;significantDigits&quot; are &quot;&quot; and 6 respectively. If name==&quot;&quot; (empty string) then the prefix &quot;&lt;name&gt; =&quot; is leaved out at the output-string.</p>
<h3 id="example">Example</h3>
<blockquote>
<pre><code>v = {2.12, -4.34, -2.56, -1.67};
toString(v);
                       // = &quot;
                       //           2.12
                       //          -4.34
                       //          -2.56
                       //          -1.67&quot;
toString(v,&quot;vv&quot;,1);
                       // = &quot;vv =
                       //           2
                       //          -4
                       //          -3
                       //          -2&quot;</code></pre>
</blockquote>
<h3 id="see-also-1">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.toString">Matrices.toString</a>,</p>
<p>::</p>
<h2 id="inputs">Inputs</h2>
<table>
<col width="12%" />
<col width="23%" />
<col width="12%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">v[:]</td>
<td align="left">
</td>
<td align="left">Real vector</td>
</tr>
<tr class="even">
<td align="left">String</td>
<td align="left">name</td>
<td align="left">&quot;&quot;</td>
<td align="left">Independent variable name used for printing</td>
</tr>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">significantDigits</td>
<td align="left">6</td>
<td align="left">Number of significant digits that are shown</td>
</tr>
</tbody>
</table>
<h2 id="outputs">Outputs</h2>
<table>
<col width="15%" />
<col width="12%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">String</td>
<td align="left">s</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>function toString 
  &quot;Convert a real vector in to a string representation&quot;
  import Modelica.Utilities.Strings;

  input Real v[:] &quot;Real vector&quot;;
  input String name=&quot;&quot; &quot;Independent variable name used for printing&quot;;
  input Integer significantDigits=6 
    &quot;Number of significant digits that are shown&quot;;
  output String s=&quot;&quot;;
protected 
  String blanks=Strings.repeat(significantDigits);
  String space=Strings.repeat(8);
  Integer r=size(v, 1);

algorithm 
  if r == 0 then
    s := if name==&quot;&quot; then &quot;[]&quot; else name + &quot; = []&quot;;
  else
    s := if name==&quot;&quot; then &quot;\n&quot; else &quot;\n&quot; + name + &quot; = \n&quot;;
    for i in 1:r loop
      s := s + space;

      if v[i] &gt;= 0 then
        s := s + &quot; &quot;;
      end if;
      s := s + String(v[i], significantDigits=significantDigits) +
        Strings.repeat(significantDigits + 8 - Strings.length(String(abs(v[i]))));

      s := s + &quot;\n&quot;;
    end for;

  end if;

end toString;</code></pre>
<hr />
<h1 id="image22-modelica.math.vectors.isequal"><img src="Modelica.Math.Vectors.isEqualI.png" alt="image22" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.isEqual</h1>
<p><strong>Determine if two Real vectors are numerically identical</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<h3 id="syntax-1">Syntax</h3>
<blockquote>
<pre><code>Vectors.isEqual(v1, v2);
Vectors.isEqual(v1, v2, eps=0);</code></pre>
</blockquote>
<h3 id="description-1">Description</h3>
<p>The function call &quot;<code>Vectors.isEqual(v1, v2)</code>&quot; returns <strong>true</strong>, if the two Real vectors v1 and v2 have the same dimensions and the same elements. Otherwise the function returns <strong>false</strong>. Two elements e1 and e2 of the two vectors are checked on equality by the test &quot;abs(e1-e2) ≤ eps&quot;, where &quot;eps&quot; can be provided as third argument of the function. Default is &quot;eps = 0&quot;.</p>
<h3 id="example-1">Example</h3>
<blockquote>
<pre><code>Real v1[3] = {1, 2, 3};
Real v2[3] = {1, 2, 3, 4};
Real v3[3] = {1, 2, 3.0001};
Boolean result;</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>result := Vectors.isEqual(v1,v2); // = false result := Vectors.isEqual(v1,v3); // = false result := Vectors.isEqual(v1,v1); // = true result := Vectors.isEqual(v1,v3,0.1); // = true</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-2">See also</h3>
<p><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.find">Vectors.find</a>, <a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual">Matrices.isEqual</a>, <a href="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.isEqual">Strings.isEqual</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-1">Inputs</h2>
<table>
<col width="8%" />
<col width="8%" />
<col width="10%" />
<col width="72%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">v1[:]</td>
<td align="left">
</td>
<td align="left">First vector</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">v2[:]</td>
<td align="left">
</td>
<td align="left">Second vector (may have different length as v1</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">0</td>
<td align="left">Two elements e1 and e2 of the two vectors are identical if abs(e1-e2) &lt;= eps</td>
</tr>
</tbody>
</table>
<h2 id="outputs-1">Outputs</h2>
<table>
<col width="13%" />
<col width="12%" />
<col width="74%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">result</td>
<td align="left">= true, if vectors have the same length and the same elements</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>function isEqual 
  &quot;Determine if two Real vectors are numerically identical&quot;
  extends Modelica.Icons.Function;
  input Real v1[:] &quot;First vector&quot;;
  input Real v2[:] &quot;Second vector (may have different length as v1&quot;;
  input Real eps(min=0) = 0 
    &quot;Two elements e1 and e2 of the two vectors are identical if abs(e1-e2) &lt;= eps&quot;;
  output Boolean result 
    &quot;= true, if vectors have the same length and the same elements&quot;;

protected 
  Integer n=size(v1, 1) &quot;Dimension of vector v1&quot;;
  Integer i=1;
algorithm 
  result := false;
  if size(v2, 1) == n then
    result := true;
    while i &lt;= n loop
      if abs(v1[i] - v2[i]) &gt; eps then
        result := false;
        i := n;
      end if;
      i := i + 1;
    end while;
  end if;
end isEqual;</code></pre>
<hr />
<h1 id="image23-modelica.math.vectors.norm"><img src="Modelica.Math.Vectors.isEqualI.png" alt="image23" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.norm</h1>
<p><strong>Return the p-norm of a vector</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<h3 id="syntax-2">Syntax</h3>
<blockquote>
<pre><code>Vectors.norm(v);
Vectors.norm(v,p=2);   // 1 ≤ p ≤ ∞</code></pre>
</blockquote>
<h3 id="description-2">Description</h3>
<p>The function call &quot;<code>Vectors.norm(v)</code>&quot; returns the <strong>Euclidean norm</strong> &quot;<code>sqrt(v*v)</code>&quot; of vector v. With the optional second argument &quot;p&quot;, any other p-norm can be computed:</p>
<p>Besides the Euclidean norm (p=2), also the 1-norm and the infinity-norm are sometimes used:</p>
<table>
<col width="26%" />
<col width="21%" />
<col width="51%" />
<tbody>
<tr class="odd">
<td align="left"><strong>1-norm</strong></td>
<td align="left">= sum(abs(v))</td>
<td align="left"><strong>norm</strong>(v,1)</td>
</tr>
<tr class="even">
<td align="left"><strong>2-norm</strong></td>
<td align="left">= sqrt(v*v)</td>
<td align="left"><strong>norm</strong>(v) or <strong>norm</strong>(v,2)</td>
</tr>
<tr class="odd">
<td align="left"><strong>infinity-norm</strong></td>
<td align="left">= max(abs(v))</td>
<td align="left"><strong>norm</strong>(v,Modelica.Constants.<strong>inf</strong>)</td>
</tr>
</tbody>
</table>
<p>Note, for any vector norm the following inequality holds:</p>
<blockquote>
<pre><code>norm(v1+v2,p) ≤ norm(v1,p) + norm(v2,p)</code></pre>
</blockquote>
<h3 id="example-2">Example</h3>
<blockquote>
<pre><code>v = {2, -4, -2, -1};
norm(v,1);    // = 9
norm(v,2);    // = 5
norm(v);      // = 5
norm(v,10.5); // = 4.00052597412635
norm(v,Modelica.Constants.inf);  // = 4</code></pre>
</blockquote>
<h3 id="see-also-3">See also</h3>
<p><a href="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm">Matrices.norm</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-2">Inputs</h2>
<table>
<col width="9%" />
<col width="9%" />
<col width="12%" />
<col width="68%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">v[:]</td>
<td align="left">
</td>
<td align="left">Vector</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">p</td>
<td align="left">2</td>
<td align="left">Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)</td>
</tr>
</tbody>
</table>
<h2 id="outputs-2">Outputs</h2>
<table>
<col width="12%" />
<col width="15%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result</td>
<td align="left">p-norm of vector v</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>function norm &quot;Return the p-norm of a vector&quot;
  extends Modelica.Icons.Function;
  input Real v[:] &quot;Vector&quot;;
  input Real p(min=1) = 2 
    &quot;Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)&quot;;
  output Real result &quot;p-norm of vector v&quot;;

algorithm 
  if p == 2 then
    result:=sqrt(v*v);
  elseif p == Modelica.Constants.inf then
    result:=max(abs(v));
  elseif p == 1 then
    result:=sum(abs(v));
  else
    result:=(sum(abs(v[i])^p for i in 1:size(v, 1)))^(1/p);
  end if;
end norm;</code></pre>
<hr />
<h1 id="image24-modelica.math.vectors.length"><img src="Modelica.Math.Vectors.isEqualI.png" alt="image24" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.length</h1>
<p><strong>Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<h3 id="syntax-3">Syntax</h3>
<blockquote>
<pre><code>Vectors.length(v);</code></pre>
</blockquote>
<h3 id="description-3">Description</h3>
<p>The function call &quot;<code>Vectors.length(v)</code>&quot; returns the <strong>Euclidean length</strong> &quot;<code>sqrt(v*v)</code>&quot; of vector v. The function call is equivalent to Vectors.norm(v). The advantage of length(v) over norm(v)&quot;is that function length(..) is implemented in one statement and therefore the function is usually automatically inlined. Further symbolic processing is therefore possible, which is not the case with function norm(..).</p>
<h3 id="example-3">Example</h3>
<blockquote>
<pre><code>v = {2, -4, -2, -1};
length(v);  // = 5</code></pre>
</blockquote>
<h3 id="see-also-4">See also</h3>
<p><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.norm">Vectors.norm</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-3">Inputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">v[:]</td>
<td align="left">
</td>
<td align="left">Vector</td>
</tr>
</tbody>
</table>
<h2 id="outputs-3">Outputs</h2>
<table>
<col width="12%" />
<col width="15%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result</td>
<td align="left">Length of vector v</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>function length 
  &quot;Return length of a vectorReturn length of a vector (better as norm(), if further symbolic processing is performed)&quot;
  extends Modelica.Icons.Function;
  input Real v[:] &quot;Vector&quot;;
  output Real result &quot;Length of vector v&quot;;
algorithm 
  result := sqrt(v*v);
end length;</code></pre>
<hr />
<h1 id="image25-modelica.math.vectors.normalize"><img src="Modelica.Math.Vectors.isEqualI.png" alt="image25" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.normalize</h1>
<p><strong>Return normalized vector such that length = 1 and prevent zero-division for zero vector</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<h3 id="syntax-4">Syntax</h3>
<blockquote>
<pre><code>Vectors.normalize(v);
Vectors.normalize(v,eps=100*Modelica.Constants.eps);</code></pre>
</blockquote>
<h3 id="description-4">Description</h3>
<p>The function call &quot;<code>Vectors.normalize(v)</code>&quot; returns the <strong>unit vector</strong> &quot;<code>v/length(v)</code>&quot; of vector v. If length(v) is close to zero (more precisely, if length(v) &lt; eps), v/eps is returned in order to avoid a division by zero. For many applications this is useful, because often the unit vector <strong>e</strong> = <strong>v</strong>/length(<strong>v</strong>) is used to compute a vector x*<strong>e</strong>, where the scalar x is in the order of length(<strong>v</strong>), i.e., x*<strong>e</strong> is small, when length(<strong>v</strong>) is small and then it is fine to replace <strong>e</strong> by <strong>v</strong> to avoid a division by zero.</p>
<p>Since the function is implemented in one statement, it is usually inlined and therefore symbolic processing is possible.</p>
<h3 id="example-4">Example</h3>
<blockquote>
<pre><code>normalize({1,2,3});  // = {0.267, 0.534, 0.802}
normalize({0,0,0});  // = {0,0,0}</code></pre>
</blockquote>
<h3 id="see-also-5">See also</h3>
<p><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length">Vectors.length</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-4">Inputs</h2>
<table>
<col width="10%" />
<col width="10%" />
<col width="35%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">v[:]</td>
<td align="left">
</td>
<td align="left">Vector</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">100*Modelica.Constants.eps</td>
<td align="left">if |v| &lt; eps then result = v/eps</td>
</tr>
</tbody>
</table>
<h2 id="outputs-4">Outputs</h2>
<table>
<col width="12%" />
<col width="31%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result[size(v, 1)]</td>
<td align="left">Input vector v normalized to length=1</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>function normalize 
  &quot;Return normalized vector such that length = 1 and prevent zero-division for zero vector&quot;
  extends Modelica.Icons.Function;
  input Real v[:] &quot;Vector&quot;;
  input Real eps = 100*Modelica.Constants.eps 
    &quot;if |v| &lt; eps then result = v/eps&quot;;
  output Real result[size(v, 1)] &quot;Input vector v normalized to length=1&quot;;

algorithm 
  result := smooth(0,noEvent(if length(v) &gt;= eps then v/length(v) else v/eps));
end normalize;</code></pre>
<hr />
<h1 id="image26-modelica.math.vectors.reverse"><img src="Modelica.Math.Vectors.isEqualI.png" alt="image26" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.reverse</h1>
<p><strong>Reverse vector elements (e.g., v[1] becomes last element)</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<h3 id="syntax-5">Syntax</h3>
<blockquote>
<pre><code>Vectors.reverse(v);</code></pre>
</blockquote>
<h3 id="description-5">Description</h3>
<p>The function call &quot;<code>Vectors.reverse(v)</code>&quot; returns the vector elements in reverse order.</p>
<h3 id="example-5">Example</h3>
<blockquote>
<pre><code>reverse({1,2,3,4});  // = {4,3,2,1}</code></pre>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-5">Inputs</h2>
<table>
<col width="12%" />
<col width="12%" />
<col width="16%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">v[:]</td>
<td align="left">
</td>
<td align="left">Vector</td>
</tr>
</tbody>
</table>
<h2 id="outputs-5">Outputs</h2>
<table>
<col width="12%" />
<col width="30%" />
<col width="57%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">result[size(v, 1)]</td>
<td align="left">Elements of vector v in reversed order</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>function reverse 
  &quot;Reverse vector elements (e.g., v[1] becomes last element)&quot;
  extends Modelica.Icons.Function;
  input Real v[:] &quot;Vector&quot;;
  output Real result[size(v, 1)] &quot;Elements of vector v in reversed order&quot;;

algorithm 
  result := {v[end-i+1] for i in 1:size(v,1)};
end reverse;</code></pre>
<hr />
<h1 id="image27-modelica.math.vectors.sort"><img src="Modelica.Math.Vectors.isEqualI.png" alt="image27" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.sort</h1>
<p><strong>Sort elements of vector in ascending or descending order</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<h3 id="syntax-6">Syntax</h3>
<blockquote>
<pre><code>sorted_v = Vectors.sort(v);</code></pre>
<blockquote>
<p>(sorted_v, indices) = Vectors.sort(v, ascending=true);</p>
</blockquote>
</blockquote>
<h3 id="description-6">Description</h3>
<p>Function <strong>sort</strong>(..) sorts a Real vector v in ascending order and returns the result in sorted_v. If the optional argument &quot;ascending&quot; is <strong>false</strong>, the vector is sorted in descending order. In the optional second output argument the indices of the sorted vector with respect to the original vector are given, such that sorted_v = v[indices].</p>
<h3 id="example-6">Example</h3>
<blockquote>
<pre><code>(v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
     -&gt; v2 = {-1, 2, 3, 6, 8}
        i2 = {1, 5, 3, 4, 2}</code></pre>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-6">Inputs</h2>
<table>
<col width="12%" />
<col width="14%" />
<col width="12%" />
<col width="60%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">v[:]</td>
<td align="left">
</td>
<td align="left">Vector to be sorted</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">ascending</td>
<td align="left">true</td>
<td align="left">= true if ascending order, otherwise descending order</td>
</tr>
</tbody>
</table>
<h2 id="outputs-6">Outputs</h2>
<table>
<col width="16%" />
<col width="36%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">sorted_v[size(v, 1)]</td>
<td align="left">Sorted vector</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">indices[size(v, 1)]</td>
<td align="left">sorted_v = v[indices]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>function sort 
  &quot;Sort elements of vector in ascending or descending order&quot;
  extends Modelica.Icons.Function;
  input Real v[:] &quot;Vector to be sorted&quot;;
  input Boolean ascending = true 
    &quot;= true if ascending order, otherwise descending order&quot;;
  output Real sorted_v[size(v,1)] = v &quot;Sorted vector&quot;;
  output Integer indices[size(v,1)] = 1:size(v,1) &quot;sorted_v = v[indices]&quot;;

  /* shellsort algorithm; should be improved later */
protected 
  Integer gap;
  Integer i;
  Integer j;
  Real wv;
  Integer wi;
  Integer nv = size(v,1);
  Boolean swap;
algorithm 
  gap := div(nv,2);

  while gap &gt; 0 loop
     i := gap;
     while i &lt; nv loop
        j := i-gap;
        if j&gt;=0 then
           if ascending then
              swap := sorted_v[j+1] &gt; sorted_v[j + gap + 1];
           else
              swap := sorted_v[j+1] &lt; sorted_v[j + gap + 1];
           end if;
        else
           swap := false;
        end if;

        while swap loop
           wv := sorted_v[j+1];
           wi := indices[j+1];
           sorted_v[j+1] := sorted_v[j+gap+1];
           sorted_v[j+gap+1] := wv;
           indices[j+1] := indices[j+gap+1];
           indices[j+gap+1] := wi;
           j := j - gap;
           if j &gt;= 0 then
              if ascending then
                 swap := sorted_v[j+1] &gt; sorted_v[j + gap + 1];
              else
                 swap := sorted_v[j+1] &lt; sorted_v[j + gap + 1];
              end if;
           else
              swap := false;
           end if;
        end while;
        i := i + 1;
     end while;
     gap := div(gap,2);
  end while;
end sort;</code></pre>
<hr />
<h1 id="image28-modelica.math.vectors.find"><img src="Modelica.Math.Vectors.isEqualI.png" alt="image28" /> <a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.find</h1>
<p><strong>Find element in a vector</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<h3 id="syntax-7">Syntax</h3>
<blockquote>
<pre><code>Vectors.find(e, v);
Vectors.find(e, v, eps=0);</code></pre>
</blockquote>
<h3 id="description-7">Description</h3>
<p>The function call &quot;<code>Vectors.find(e, v)</code>&quot; returns the index of the first occurence of input e in vector <strong>v</strong>. The test of equality is performed by &quot;abs(e-v[i]) ≤ eps&quot;, where &quot;eps&quot; can be provided as third argument of the function. Default is &quot;eps = 0&quot;.</p>
<h3 id="example-7">Example</h3>
<blockquote>
<pre><code>Real v[3] = {1, 2, 3};
Real e1 = 2;
Real e2 = 3.01;
Boolean result;</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>result := Vectors.find(e1,v); // = 2 result := Vectors.find(e2,v); // = 0 result := Vectors.find(e2,v,eps=0.1); // = 3</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-6">See also</h3>
<p><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual">Vectors.isEqual</a></p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Function">Modelica.Icons.Function</a> (Icon for functions).</p>
<h2 id="inputs-7">Inputs</h2>
<table>
<col width="8%" />
<col width="8%" />
<col width="11%" />
<col width="71%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">e</td>
<td align="left">
</td>
<td align="left">Search for e</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">v[:]</td>
<td align="left">
</td>
<td align="left">Integer vector</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">eps</td>
<td align="left">0</td>
<td align="left">Element e is equal to a element v[i] of vectorv if abs(e-v[i]) &lt;= eps</td>
</tr>
</tbody>
</table>
<h2 id="outputs-7">Outputs</h2>
<table>
<col width="13%" />
<col width="12%" />
<col width="74%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">result</td>
<td align="left">v[result] = e (first occurrence of e); result=0, if not found</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>function find &quot;Find element in a vector&quot;
  extends Modelica.Icons.Function;
  input Real e &quot;Search for e&quot;;
  input Real v[:] &quot;Integer vector&quot;;
  input Real eps(min=0) = 0 
    &quot;Element e is equal to a element v[i] of vectorv if abs(e-v[i]) &lt;= eps&quot;;
  output Integer result 
    &quot;v[result] = e (first occurrence of e); result=0, if not found&quot;;
protected 
  Integer i;
algorithm 
  result := 0;
  i := 1;
  while i &lt;= size(v, 1) loop
    if abs(v[i]-e)&lt;=eps then
      result := i;
      i := size(v, 1) + 1;
    else
      i := i + 1;
    end if;
  end while;

end find;</code></pre>
<hr />
<h1 id="modelica.math.vectors.interpolate"><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.interpolate</h1>
<p><strong>Interpolate in a vector</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<h3 id="syntax-8">Syntax</h3>
<blockquote>
<pre><code>// Real    x[:], y[:], xi, yi;
// Integer iLast, iNew;
        yi = Vectors.interpolate(x,y,xi);
(yi, iNew) = Vectors.interpolate(x,y,xi,iLast=1);</code></pre>
</blockquote>
<h3 id="description-8">Description</h3>
<p>The function call &quot;<code>Vectors.interpolate(x,y,xi)</code>&quot; interpolates in vectors (x,y) and returns the value yi that corresponds to xi. Vector x[:] must consist of strictly monotonocially increasing values. If xi &lt; x[1] or &gt; x[end], then extrapolation takes places through the first or last two x[:] values, respectively. The search for the interval x[iNew] ≤ xi &lt; x[iNew+1] starts at the optional input argument &quot;iLast&quot;. The index &quot;iNew&quot; is returned as output argument. The usage of &quot;iLast&quot; and &quot;iNew&quot; is useful to increase the efficiency of the call, if many interpolations take place.</p>
<h3 id="example-8">Example</h3>
<blockquote>
<pre><code>Real x[:] = { 0,  2,  4,  6,  8, 10};
Real y[:] = {10, 20, 30, 40, 50, 60};</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>(yi, iNew) := Vectors.interpolate(x,y,5); // yi = 35, iNew=3</p>
</dd>
</dl>
</blockquote>
</blockquote>
<p>::</p>
<h2 id="inputs-8">Inputs</h2>
<table>
<col width="10%" />
<col width="15%" />
<col width="10%" />
<col width="64%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">x[:]</td>
<td align="left">
</td>
<td align="left">Abszissa table vector (strict monotonically increasing values required)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">y[size(x, 1)]</td>
<td align="left">
</td>
<td align="left">Ordinate table vector</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">xi</td>
<td align="left">
</td>
<td align="left">Desired abszissa value</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">iLast</td>
<td align="left">1</td>
<td align="left">Index used in last search</td>
</tr>
</tbody>
</table>
<h2 id="outputs-8">Outputs</h2>
<table>
<col width="16%" />
<col width="12%" />
<col width="71%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">yi</td>
<td align="left">Ordinate value corresponding to xi</td>
</tr>
<tr class="even">
<td align="left">Integer</td>
<td align="left">iNew</td>
<td align="left">xi is in the interval x[iNew] &lt;= xi &lt; x[iNew+1]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>function interpolate &quot;Interpolate in a vector&quot;
  input Real x[ :] 
    &quot;Abszissa table vector (strict monotonically increasing values required)&quot;;
  input Real y[ size(x,1)] &quot;Ordinate table vector&quot;;
  input Real xi &quot;Desired abszissa value&quot;;
  input Integer iLast=1 &quot;Index used in last search&quot;;
  output Real yi &quot;Ordinate value corresponding to xi&quot;;
  output Integer iNew=1 &quot;xi is in the interval x[iNew] &lt;= xi &lt; x[iNew+1]&quot;;
protected 
  Integer i;
  Integer nx=size(x,1);
  Real x1;
  Real x2;
  Real y1;
  Real y2;
algorithm 
  assert(nx &gt; 0, &quot;The table vectors must have at least 1 entry.&quot;);
  if nx == 1 then
    yi := y[1];
  else
    // Search interval
    i := min(max(iLast,1),nx-1);
    if xi &gt;= x[i] then
       // search forward
       while i &lt; nx and xi &gt;= x[i] loop
          i := i + 1;
       end while;
       i := i - 1;
    else
       // search backward
       while i &gt; 1 and xi &lt; x[i] loop
          i := i - 1;
       end while;
    end if;

    // Get interpolation data
    x1 := x[i];
    x2 := x[i+1];
    y1 := y[i];
    y2 := y[i+1];

    assert(x2 &gt; x1, &quot;Abszissa table vector values must be increasing&quot;);
    // Interpolate
    yi := y1 + (y2 - y1)*(xi - x1)/(x2 - x1);
    iNew :=i;
  end if;

end interpolate;</code></pre>
<hr />
<h1 id="modelica.math.vectors.relnodepositions"><a href="Modelica_Math_Vectors.html#Modelica.Math.Vectors">Modelica.Math.Vectors</a>.relNodePositions</h1>
<p><strong>Return vector of relative node positions (0..1)</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<h3 id="syntax-9">Syntax</h3>
<blockquote>
<pre><code>Vectors.relNodePositions(nNodes);</code></pre>
</blockquote>
<h3 id="description-9">Description</h3>
<p>The function call &quot;<code>relNodePositions(nNodes)</code>&quot; returns a vector with the relative positions of the nodes of a discretized pipe with nNodes nodes (including the node at the left and at the right side of the pipe), see next figure:</p>
<blockquote>

</blockquote>
<h3 id="example-9">Example</h3>
<blockquote>
<pre><code>Real xsi[7];</code></pre>
<blockquote>
<dl>
<dt>algorithm</dt>
<dd><p>xsi = relNodePositions(7); // xsi = {0, 0.1, 0.3, 0.5, 0.7, 0.9, 1}</p>
</dd>
</dl>
</blockquote>
</blockquote>
<h3 id="see-also-7">See also</h3>
<p><a href="Modelica_Mechanics_MultiBody_Visualizers.html#Modelica.Mechanics.MultiBody.Visualizers.PipeWithScalarField">MultiBody.Visualizers.PipeWithScalarField</a></p>
<p>::</p>
<h2 id="inputs-9">Inputs</h2>
<table>
<col width="12%" />
<col width="11%" />
<col width="12%" />
<col width="64%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Integer</td>
<td align="left">nNodes</td>
<td align="left">
</td>
<td align="left">Number of nodes (including node at left and right position)</td>
</tr>
</tbody>
</table>
<h2 id="outputs-9">Outputs</h2>
<table>
<col width="12%" />
<col width="22%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">xsi[nNodes]</td>
<td align="left">Relative node positions</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>function relNodePositions 
  &quot;Return vector of relative node positions (0..1)&quot;
  input Integer nNodes 
    &quot;Number of nodes (including node at left and right position)&quot;;
  output Real xsi[nNodes] &quot;Relative node positions&quot;;
protected 
  Real delta;
algorithm 
  if nNodes &gt;= 1 then
     xsi[1] :=0;
  end if;

  if nNodes &gt;= 2 then
     xsi[nNodes] :=1;
  end if;

  if nNodes == 3 then
     xsi[2] :=0.5;
  elseif nNodes &gt; 3 then
     delta :=1/(nNodes - 2);
     for i in 2:nNodes-1 loop
        xsi[i] :=(i - 1.5)*delta;
     end for;
  end if;

end relNodePositions;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:31:48 2010.</p>
</body>
</html>
