<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Mechanics.MultiBody.Sensors</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Mechanics.MultiBody.Sensors</h1>
</div>
<h1 id="modelica.mechanics.multibody.sensors"><a href="Modelica_Mechanics_MultiBody.html#Modelica.Mechanics.MultiBody">Modelica.Mechanics.MultiBody</a>.Sensors</h1>
<p><strong>Sensors to measure variables</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>Package <strong>Sensors</strong> contains <strong>ideal measurement</strong> components to determine absolute and relative kinematic quantities, as well as cut-forces, cut-torques and power. All measured quantities can be provided in every desired coordinate system.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_SensorsPackage.html#Modelica.Icons.SensorsPackage">Modelica.Icons.SensorsPackage</a> (Icon for packages containing sensors).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="71%" />
<col width="28%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensorS.png" alt="image18" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor">AbsoluteSensor</a></td>
<td align="left">Measure absolute kinematic quantities of frame connector</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativeSensorS.png" alt="image19" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.RelativeSensor">RelativeSensor</a></td>
<td align="left">Measure relative kinematic quantities between two frame connectors</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsolutePositionS.png" alt="image20" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition">AbsolutePosition</a></td>
<td align="left">Measure absolute position vector of the origin of a frame connector</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocityS.png" alt="image21" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity">AbsoluteVelocity</a></td>
<td align="left">Measure absolute velocity vector of origin of frame connector</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteAnglesS.png" alt="image22" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles">AbsoluteAngles</a></td>
<td align="left">Measure absolute angles between frame connector and the world frame</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocityS.png" alt="image23" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocity">AbsoluteAngularVelocity</a></td>
<td align="left">Measure absolute angular velocity of frame connector</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativePositionS.png" alt="image24" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.RelativePosition">RelativePosition</a></td>
<td align="left">Measure relative position vector between the origins of two frame connectors</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativePositionS.png" alt="image25" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.RelativeVelocity">RelativeVelocity</a></td>
<td align="left">Measure relative velocity vector between the origins of two frame connectors</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativeAnglesS.png" alt="image26" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.RelativeAngles">RelativeAngles</a></td>
<td align="left">Measure relative angles between two frame connectors</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativeAngularVelocityS.png" alt="image27" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.RelativeAngularVelocity">RelativeAngularVelocity</a></td>
<td align="left">Measure relative angular velocity between two frame connectors</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.DistanceS.png" alt="image28" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.Distance">Distance</a></td>
<td align="left">Measure the distance between the origins of two frame connectors</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.CutForceS.png" alt="image29" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.CutForce">CutForce</a></td>
<td align="left">Measure cut force vector</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.CutForceS.png" alt="image30" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.CutTorque">CutTorque</a></td>
<td align="left">Measure cut torque vector</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.CutForceAndTorqueS.png" alt="image31" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.CutForceAndTorque">CutForceAndTorque</a></td>
<td align="left">Measure cut force and cut torque vector</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.PowerS.png" alt="image32" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.Power">Power</a></td>
<td align="left">Measure power flowing from frame_a to frame_b</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.TansformAbsoluteVectorS.png" alt="image33" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.TansformAbsoluteVector">TansformAbsoluteVector</a></td>
<td align="left">Transform absolute vector in to another frame</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVectorS.png" alt="image34" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector">TansformRelativeVector</a></td>
<td align="left">Transform relative vector in to another frame</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Sensors.InternalS.png" alt="image35" /> <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal">Internal</a></td>
<td align="left">Internal package, should not be used by user</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image36-modelica.mechanics.multibody.sensors.absolutesensor"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensorI.png" alt="image36" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.AbsoluteSensor</h1>
<p><strong>Measure absolute kinematic quantities of frame connector</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>Absolute kinematic quantities of frame_a are determined and provided at the conditional output signal connectors. For example, if parameter &quot;get_r = <strong>true</strong>&quot;, the connector &quot;r&quot; is enabled and contains the absolute vector from the world frame to the origin of frame_a. The following quantities can be provided as output signals:</p>
<ol>
<li>Absolute position vector (= r)</li>
<li>Absolute velocity vector (= v)</li>
<li>Absolute acceleration vector (= a)</li>
<li>Three angles to rotate world frame into frame_a (= angles)</li>
<li>Absolute angular velocity vector (= w)</li>
<li>Absolute angular acceleration vector (= z)</li>
</ol>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame a vector is resolved:</p>
<table>
<col width="40%" />
<col width="52%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameA.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vectors in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vectors in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_resolve</td>
<td align="left">Resolve vectors in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and the vectors are resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>In the following figure the animation of an AbsoluteSensor component is shown. The light blue coordinate system is frame_a and the yellow arrow is the animated sensor.</p>
<p>Velocity, acceleration, angular velocity and angular acceleration are determined by differentiating them in the world frame and then transforming them in to the frame defined by <strong>resolveInFrame</strong>.</p>
<p>For example, if resolveInFrame = <strong>Types.ResolveInFrameA.frame_a</strong>, then</p>
<pre><code>v0 = der(frame_a.r0);
v  = resolve2(frame_a.R, v0);</code></pre>
<p>is returned, i.e., the derivative of the absolute distance from the world frame to the origin of frame_a, resolved in frame_a.</p>
<p>The cut-force and the cut-torque in frame_resolve are always zero, whether frame_resolve is connected or not.</p>
<p>If <strong>get_angles</strong> = <strong>true</strong>, the 3 angles to rotate the world frame into frame_a along the axes defined by parameter <strong>sequence</strong> are returned. For example, if sequence = {3,1,2} then the world frame is rotated around angles[1] along the z-axis, afterwards it is rotated around angles[2] along the x-axis, and finally it is rotated around angles[3] along the y-axis and is then identical to frame_a. The 3 angles are returned in the range</p>
<pre><code>-p &lt;= angles[i] &lt;= p</code></pre>
<p>There are <strong>two solutions</strong> for &quot;angles[1]&quot; in this range. Via parameter <strong>guessAngle1</strong> (default = 0) the returned solution is selected such that |angles[1] - guessAngle1| is minimal. The absolute transformation matrix of frame_a may be in a singular configuration with respect to &quot;sequence&quot;, i.e., there is an infinite number of angle values leading to the same absolute transformation matrix. In this case, the returned solution is selected by setting angles[1] = guessAngle1. Then angles[2] and angles[3] can be uniquely determined in the above range.</p>
<p>The parameter <strong>sequence</strong> has the restriction that only values 1,2,3 can be used and that sequence[1] ≠ sequence[2] and sequence[2] ≠ sequence[3]. Often used values are:</p>
<pre><code>sequence = {1,2,3}  // Cardan or Tait-Bryan angle sequence
         = {3,1,3}  // Euler angle sequence
         = {3,2,1}</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor">Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor</a> (Partial absolute sensor model for sensors defined by components).</p>
<h2 id="parameters">Parameters</h2>
<table>
<col width="38%" />
<col width="7%" />
<col width="11%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show arrow)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which vectors are resolved (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_r</td>
<td align="left">false</td>
<td align="left">= true, to measure the absolute position vector of the origin of frame_a</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">get_v</td>
<td align="left">false</td>
<td align="left">= true, to measure the absolute velocity of the origin of frame_a</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_a</td>
<td align="left">false</td>
<td align="left">= true, to measure the absolute acceleration of the origin of frame_a</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">get_w</td>
<td align="left">false</td>
<td align="left">= true, to measure the absolute angular velocity of frame_a</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_z</td>
<td align="left">false</td>
<td align="left">= true, to measure the absolute angular acceleration of frame_a</td>
</tr>
<tr class="even">
<td align="left">3 angles to rotate the world frame into frame_a along the axes defined in &quot;sequence&quot;</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_angles</td>
<td align="left">false</td>
<td align="left">= true, to measure the 3 rotation angles</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence</td>
<td align="left">{1,2,3}</td>
<td align="left">If get_angles=true: Angles are returned to rotate world frame around axes sequence[1], sequence[2] and finally sequence[3] into frame_a</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">guessAngle1</td>
<td align="left">0</td>
<td align="left">If get_angles=true: Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum [rad]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">arrowDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of absolute arrow from world frame to frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">arrowColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of absolute arrow from world frame to frame_b</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors">Connectors</h2>
<table>
<col width="49%" />
<col width="7%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">r[3]</td>
<td align="left">Absolute position vector frame_a.r_0 resolved in frame defined by resolveInFrame [m]</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">v[3]</td>
<td align="left">Absolute velocity vector [m/s]</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">a[3]</td>
<td align="left">Absolute acceleration vector [m/s2]</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">angles[3]</td>
<td align="left">Angles to rotate world frame into frame_a via 'sequence' [rad]</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">w[3]</td>
<td align="left">Absolute angular velocity vector [1/s]</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">z[3]</td>
<td align="left">Absolute angular acceleration vector [1/s2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system at which the kinematic quantities are measured</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the output signals are resolved in this frame</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>model AbsoluteSensor 
  &quot;Measure absolute kinematic quantities of frame connector&quot;

  import SI = Modelica.SIunits;

  Blocks.Interfaces.RealOutput r[3](each final quantity=&quot;Position&quot;, each final 
            unit =                                                                    &quot;m&quot;) if get_r 
    &quot;Absolute position vector frame_a.r_0 resolved in frame defined by resolveInFrame&quot;;
  Blocks.Interfaces.RealOutput v[3](each final quantity=&quot;Velocity&quot;, each final 
            unit =                                                                    &quot;m/s&quot;) if get_v 
    &quot;Absolute velocity vector&quot;;
  Blocks.Interfaces.RealOutput a[3](each final quantity=&quot;Acceleration&quot;, each final 
            unit =                                                                        &quot;m/s2&quot;) if get_a 
    &quot;Absolute acceleration vector&quot;;
  Blocks.Interfaces.RealOutput angles[3](each final quantity=&quot;Angles&quot;, each final 
            unit =                                                                       &quot;rad&quot;, each 
      displayUnit =                                                                                              &quot;deg&quot;) if get_angles 
    &quot;Angles to rotate world frame into frame_a via &#39;sequence&#39;&quot;;
  Blocks.Interfaces.RealOutput w[3](each final quantity=&quot;AngularVelocity&quot;, each final 
            unit =                                                                           &quot;1/s&quot;) if get_w 
    &quot;Absolute angular velocity vector&quot;;
  Blocks.Interfaces.RealOutput z[3](each final quantity=&quot;AngularAcceleration&quot;, each final 
            unit =                                                                               &quot;1/s2&quot;) if get_z 
    &quot;Absolute angular acceleration vector&quot;;

  extends Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor;

  Interfaces.Frame_resolve frame_resolve if resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve 
    &quot;If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the output signals are resolved in this frame&quot;;


  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show arrow)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameA resolveInFrame=
      Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_a 
    &quot;Frame in which vectors are resolved (1: world, 2: frame_a, 3: frame_resolve)&quot;;
  parameter Boolean get_r=false 
    &quot;= true, to measure the absolute position vector of the origin of frame_a&quot;;
  parameter Boolean get_v=false 
    &quot;= true, to measure the absolute velocity of the origin of frame_a&quot;;
  parameter Boolean get_a=false 
    &quot;= true, to measure the absolute acceleration of the origin of frame_a&quot;;
  parameter Boolean get_w=false 
    &quot;= true, to measure the absolute angular velocity of frame_a&quot;;
  parameter Boolean get_z=false 
    &quot;= true, to measure the absolute angular acceleration of frame_a&quot;;
  parameter Boolean get_angles=false &quot;= true, to measure the 3 rotation angles&quot;;
  parameter Types.RotationSequence sequence(
    min={1,1,1},
    max={3,3,3}) = {1,2,3} 
    &quot;If get_angles=true: Angles are returned to rotate world frame around axes sequence[1], sequence[2] and finally sequence[3] into frame_a&quot;;
  parameter SI.Angle guessAngle1=0 
    &quot;If get_angles=true: Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum&quot;;

  input SI.Diameter arrowDiameter=world.defaultArrowDiameter 
    &quot;Diameter of absolute arrow from world frame to frame_a&quot;;
  input Types.Color arrowColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot;Color of absolute arrow from world frame to frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  AbsolutePosition position(resolveInFrame=resolveInFrame) if get_r;

protected 
  AbsoluteVelocity velocity(resolveInFrame=resolveInFrame) if get_v;
  Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles absoluteAngles(sequence=
        sequence, guessAngle1=guessAngle1) if get_angles;
  AbsoluteAngularVelocity angularVelocity(resolveInFrame=resolveInFrame) if get_w;

protected 
  Blocks.Continuous.Der der1[3] if get_a;
protected 
  Blocks.Continuous.Der der2[3] if get_z;

protected 
  Modelica.Mechanics.MultiBody.Sensors.TansformAbsoluteVector
    transformVector_a(
      frame_r_in=Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world,
      frame_r_out=resolveInFrame) if 
       get_a;
  Modelica.Mechanics.MultiBody.Sensors.TansformAbsoluteVector
    transformVector_z(
      frame_r_in=Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world,
      frame_r_out=resolveInFrame) if 
       get_z;

protected 
  outer Modelica.Mechanics.MultiBody.World world;

  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Arrow arrow(
    r_head=frame_a.r_0,
    diameter=arrowDiameter,
    color=arrowColor,
    specularCoefficient) if world.enableAnimation and animation;

protected 
  AbsoluteVelocity absoluteVelocity(resolveInFrame=Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) if get_a;
  AbsoluteAngularVelocity absoluteAngularVelocity(resolveInFrame=Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world) if 
       get_z;
  Internal.ZeroForceAndTorque zeroForce1;
  Internal.ZeroForceAndTorque zeroForce2 if resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve;
equation 
  connect(zeroForce1.frame_a, frame_a);
  connect(absoluteAngles.angles, angles);
  connect(angularVelocity.frame_a, frame_a);
  connect(angularVelocity.w, w);
  connect(frame_resolve, position.frame_resolve);
  connect(frame_resolve,zeroForce2. frame_a);
  connect(angularVelocity.frame_resolve, frame_resolve);
  connect(transformVector_a.frame_a, frame_a);
  connect(transformVector_a.frame_resolve, frame_resolve);
  connect(transformVector_a.r_out, a);
  connect(der2.y, transformVector_z.r_in);
  connect(transformVector_z.r_out, z);
  connect(transformVector_z.frame_a, frame_a);
  connect(transformVector_z.frame_resolve, frame_resolve);
  connect(frame_a, position.frame_a);
  connect(absoluteAngles.frame_a, frame_a);
  connect(position.r, r);
  connect(velocity.frame_a, frame_a);
  connect(velocity.frame_resolve, frame_resolve);
  connect(velocity.v, v);
  connect(der1.y, transformVector_a.r_in);
  connect(absoluteVelocity.v, der1.u);
  connect(absoluteVelocity.frame_a, frame_a);
  connect(absoluteAngularVelocity.frame_a, frame_a);
  connect(absoluteAngularVelocity.w, der2.u);
end AbsoluteSensor;</code></pre>
<hr />
<h1 id="image37-modelica.mechanics.multibody.sensors.relativesensor"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativeSensorI.png" alt="image37" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.RelativeSensor</h1>
<p><strong>Measure relative kinematic quantities between two frame connectors</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>Relative kinematic quantities between frame_a and frame_b are determined and provided at the conditional output signal connectors. For example, if parameter &quot;get_r_rel = <strong>true</strong>&quot;, the connector &quot;r_rel&quot; is enabled and contains the relative vector from frame_a to frame_b. The following quantities can be provided as output signals:</p>
<ol>
<li>Relative position vector (= r_rel)</li>
<li>Relative velocity vector (= v_rel)</li>
<li>Relative acceleration vector (= a_rel)</li>
<li>Three angles to rotate frame_a into frame_b (= angles)</li>
<li>Relative angular velocity vector (= w_rel)</li>
<li>Relative angular acceleration vector (= z_rel)</li>
</ol>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame a vector is resolved (before differentiation):</p>
<table>
<col width="41%" />
<col width="52%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vectors in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vectors in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve vectors in frame_b</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve vectors in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and the vectors are resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>In the following figure the animation of a RelativeSensor component is shown. The light blue coordinate system is frame_a, the dark blue coordinate system is frame_b, and the yellow arrow is the animated sensor.</p>
<p>Note, derivatives of relative kinematic quantities are always performed with respect to the frame, in which the vector to be differentiated is resolved. After differentiation, it is possible via parameter <strong>resolveInFrameAfterDifferentiation</strong> (in the &quot;Advanced&quot; menu) to resolve the differentiated vector in another frame.</p>
<p>For example, if resolveInFrame = <strong>Types.ResolveInFrameAB.frame_b</strong>, then</p>
<pre><code>r_rel = resolve2(frame_b.R, frame_b.r_0 - frame_a.r0);
v_rel = der(r_rel);</code></pre>
<p>is returned (r_rel = resolve2(frame_b.R, frame_b.r_0 -frame_a.r0)), i.e., the derivative of the relative distance from frame_a to frame_b, resolved in frame_b. If <strong>resolveInFrameAfterDifferentiation</strong> = Types.ResolveInFrameAB.world, then v_rel is additionally transformed to:</p>
<pre><code>v_rel = resolve1(frame_b.R, der(r_rel))</code></pre>
<p>The cut-force and the cut-torque in frame_resolve are always zero, whether frame_resolve is connected or not.</p>
<p>If <strong>get_angles</strong> = <strong>true</strong>, the 3 angles to rotate frame_a into frame_b along the axes defined by parameter <strong>sequence</strong> are returned. For example, if sequence = {3,1,2} then frame_a is rotated around angles[1] along the z-axis, afterwards it is rotated around angles[2] along the x-axis, and finally it is rotated around angles[3] along the y-axis and is then identical to frame_b. The 3 angles are returned in the range</p>
<pre><code>-p &lt;= angles[i] &lt;= p</code></pre>
<p>There are <strong>two solutions</strong> for &quot;angles[1]&quot; in this range. Via parameter <strong>guessAngle1</strong> (default = 0) the returned solution is selected such that |angles[1] - guessAngle1| is minimal. The relative transformation matrix between frame_a and frame_b may be in a singular configuration with respect to &quot;sequence&quot;, i.e., there is an infinite number of angle values leading to the same relative transformation matrix. In this case, the returned solution is selected by setting angles[1] = guessAngle1. Then angles[2] and angles[3] can be uniquely determined in the above range.</p>
<p>The parameter <strong>sequence</strong> has the restriction that only values 1,2,3 can be used and that sequence[1] ≠ sequence[2] and sequence[2] ≠ sequence[3]. Often used values are:</p>
<pre><code>sequence = {1,2,3}  // Cardan or Tait-Bryan angle sequence
         = {3,1,3}  // Euler angle sequence
         = {3,2,1}</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor">Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor</a> (Partial relative sensor model for sensors defined by components).</p>
<h2 id="parameters-1">Parameters</h2>
<table>
<col width="36%" />
<col width="11%" />
<col width="10%" />
<col width="41%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show arrow)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which vectors are resolved before differentiation (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_r_rel</td>
<td align="left">false</td>
<td align="left">= true, to measure the relative position vector from the origin of frame_a to frame_b</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">get_v_rel</td>
<td align="left">false</td>
<td align="left">= true, to measure the relative velocity of the origin of frame_b with respect to frame_a</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_a_rel</td>
<td align="left">false</td>
<td align="left">= true, to measure the relative acceleration of the origin of frame_b with respect to frame_a</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">get_w_rel</td>
<td align="left">false</td>
<td align="left">= true, to measure the relative angular velocity of frame_b with respect to frame_a</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_z_rel</td>
<td align="left">false</td>
<td align="left">= true, to measure the relative angular acceleration of frame_b with respect to frame_a</td>
</tr>
<tr class="even">
<td align="left">3 angles to rotate frame_a into frame_b along the axes defined in &quot;sequence&quot;</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">get_angles</td>
<td align="left">false</td>
<td align="left">= true, to measure the 3 rotation angles</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence</td>
<td align="left">{1,2,3}</td>
<td align="left">If get_angles=true: Angles are returned to rotate frame_a around axes sequence[1], sequence[2] and finally sequence[3] into frame_b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">guessAngle1</td>
<td align="left">0</td>
<td align="left">If get_angles=true: Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum [rad]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">arrowDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of relative arrow from frame_a to frame_b [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">arrowColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of relative arrow from frame_a to frame_b</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if get_v_rel or get_a_rel or get_z_rel</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrameAfterDifferentiation</td>
<td align="left">resolveInFrame</td>
<td align="left">Frame in which vectors are resolved after differentiation (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-1">Connectors</h2>
<table>
<col width="49%" />
<col width="7%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the output signals are resolved in this frame</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">r_rel[3]</td>
<td align="left">Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame [m]</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">v_rel[3]</td>
<td align="left">Relative velocity vector [m/s]</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">a_rel[3]</td>
<td align="left">Relative acceleration vector [m/s2]</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">angles[3]</td>
<td align="left">Angles to rotate frame_a into frame_b via 'sequence' [rad]</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">w_rel[3]</td>
<td align="left">Relative angular velocity vector [1/s]</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">z_rel[3]</td>
<td align="left">Relative angular acceleration vector [1/s2]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>model RelativeSensor 
  &quot;Measure relative kinematic quantities between two frame connectors&quot;

  import SI = Modelica.SIunits;
  extends Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor;

  Interfaces.Frame_resolve frame_resolve if 
        resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve or 
        resolveInFrameAfterDifferentiation == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve 
    &quot;If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the output signals are resolved in this frame&quot;;


  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show arrow)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrame=
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a 
    &quot;Frame in which vectors are resolved before differentiation (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;
  parameter Boolean get_r_rel=false 
    &quot;= true, to measure the relative position vector from the origin of frame_a to frame_b&quot;;
  parameter Boolean get_v_rel=false 
    &quot;= true, to measure the relative velocity of the origin of frame_b with respect to frame_a&quot;;
  parameter Boolean get_a_rel=false 
    &quot;= true, to measure the relative acceleration of the origin of frame_b with respect to frame_a&quot;;
  parameter Boolean get_w_rel=false 
    &quot;= true, to measure the relative angular velocity of frame_b with respect to frame_a&quot;;
  parameter Boolean get_z_rel=false 
    &quot;= true, to measure the relative angular acceleration of frame_b with respect to frame_a&quot;;
  parameter Boolean get_angles=false &quot;= true, to measure the 3 rotation angles&quot;;
  parameter Types.RotationSequence sequence(
    min={1,1,1},
    max={3,3,3}) = {1,2,3} 
    &quot;If get_angles=true: Angles are returned to rotate frame_a around axes sequence[1], sequence[2] and finally sequence[3] into frame_b&quot;;
  parameter SI.Angle guessAngle1=0 
    &quot;If get_angles=true: Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum&quot;;

  input SI.Diameter arrowDiameter=world.defaultArrowDiameter 
    &quot;Diameter of relative arrow from frame_a to frame_b&quot;;
  input Types.Color arrowColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot;Color of relative arrow from frame_a to frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrameAfterDifferentiation = resolveInFrame 
    &quot;Frame in which vectors are resolved after differentiation (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;

  Blocks.Interfaces.RealOutput r_rel[3](each final quantity=&quot;Position&quot;, each final 
            unit =                                                                        &quot;m&quot;) if get_r_rel 
    &quot;Relative position vector frame_b.r_0 - frame_a.r_0 resolved in frame defined by resolveInFrame&quot;;
  Blocks.Interfaces.RealOutput v_rel[3](each final quantity=&quot;Velocity&quot;, each final 
            unit =                                                                        &quot;m/s&quot;) if get_v_rel 
    &quot;Relative velocity vector&quot;;
  Blocks.Interfaces.RealOutput a_rel[3](each final quantity=&quot;Acceleration&quot;,
      each final unit=&quot;m/s2&quot;) if                                                                  get_a_rel 
    &quot;Relative acceleration vector&quot;;
  Blocks.Interfaces.RealOutput angles[3](each final quantity=&quot;Angles&quot;, each final 
            unit =                                                                       &quot;rad&quot;, each 
      displayUnit =                                                                                              &quot;deg&quot;) if get_angles 
    &quot;Angles to rotate frame_a into frame_b via &#39;sequence&#39;&quot;;
  Blocks.Interfaces.RealOutput w_rel[3](each final quantity=&quot;AngularVelocity&quot;, each final 
            unit =                                                                               &quot;1/s&quot;) if get_w_rel 
    &quot;Relative angular velocity vector&quot;;
  Blocks.Interfaces.RealOutput z_rel[3](each final quantity=&quot;AngularAcceleration&quot;, each final 
            unit =                                                                                   &quot;1/s2&quot;) if get_z_rel 
    &quot;Relative angular acceleration vector&quot;;

protected 
  RelativePosition relativePosition(         resolveInFrame=resolveInFrame) if 
                                                get_r_rel or get_v_rel or get_a_rel;

protected 
  Blocks.Continuous.Der der1[3] if get_v_rel or get_a_rel;
  Blocks.Continuous.Der der2[3] if get_a_rel;
  Modelica.Mechanics.MultiBody.Sensors.RelativeAngles relativeAngles(
                                         sequence=sequence, guessAngle1=
        guessAngle1) if                     get_angles;
  RelativeAngularVelocity relativeAngularVelocity(         resolveInFrame=
        resolveInFrame) if                                    get_w_rel or get_z_rel;

protected 
  Blocks.Continuous.Der der3[3] if get_z_rel;
  Internal.ZeroForceAndTorque zeroForce1;
  Internal.ZeroForceAndTorque zeroForce2;
  Internal.ZeroForceAndTorque zeroForce3 if resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve;

protected 
  Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector
    transformVector_v_rel(                       frame_r_in=resolveInFrame,
      frame_r_out=resolveInFrameAfterDifferentiation) if get_v_rel;
  Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector
    transformVector_a_rel(                       frame_r_in=resolveInFrame,
      frame_r_out=resolveInFrameAfterDifferentiation) if get_a_rel;
  Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVector
    transformVector_z_rel(                       frame_r_in=resolveInFrame,
      frame_r_out=resolveInFrameAfterDifferentiation) if 
       get_z_rel;

protected 
  outer Modelica.Mechanics.MultiBody.World world;

  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Arrow arrow(
    r=frame_a.r_0,
    r_head=frame_b.r_0 - frame_a.r_0,
    diameter=arrowDiameter,
    color=arrowColor,
    specularCoefficient) if world.enableAnimation and animation;
equation 
  connect(relativePosition.frame_a, frame_a);
  connect(relativePosition.frame_b, frame_b);
  connect(relativePosition.r_rel, r_rel);
  connect(zeroForce1.frame_a, frame_a);
  connect(zeroForce2.frame_a, frame_b);
  connect(relativePosition.r_rel, der1.u);
  connect(der2.u, der1.y);
  connect(relativeAngles.frame_a, frame_a);
  connect(relativeAngles.frame_b, frame_b);
  connect(relativeAngles.angles, angles);
  connect(relativeAngularVelocity.frame_b, frame_b);
  connect(relativeAngularVelocity.frame_a, frame_a);
  connect(relativeAngularVelocity.w_rel, w_rel);
  connect(relativeAngularVelocity.w_rel, der3.u);
  connect(der1.y, transformVector_v_rel.r_in);
  connect(transformVector_v_rel.r_out, v_rel);
  connect(transformVector_v_rel.frame_a, frame_a);
  connect(transformVector_v_rel.frame_b, frame_b);
  connect(transformVector_v_rel.frame_resolve, frame_resolve);
  connect(frame_resolve, relativePosition.frame_resolve);
  connect(frame_resolve, zeroForce3.frame_a);
  connect(relativeAngularVelocity.frame_resolve, frame_resolve);
  connect(der2.y, transformVector_a_rel.r_in);
  connect(transformVector_a_rel.frame_a, frame_a);
  connect(transformVector_a_rel.frame_b, frame_b);
  connect(transformVector_a_rel.frame_resolve, frame_resolve);
  connect(transformVector_a_rel.r_out, a_rel);
  connect(der3.y, transformVector_z_rel.r_in);
  connect(transformVector_z_rel.r_out, z_rel);
  connect(transformVector_z_rel.frame_a, frame_a);
  connect(transformVector_z_rel.frame_b, frame_b);
  connect(transformVector_z_rel.frame_resolve, frame_resolve);
end RelativeSensor;</code></pre>
<hr />
<h1 id="image38-modelica.mechanics.multibody.sensors.absoluteposition"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsolutePositionI.png" alt="image38" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.AbsolutePosition</h1>
<p><strong>Measure absolute position vector of the origin of a frame connector</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>The absolute position vector of the origin of frame_a is determined and provided at the output signal connector <strong>r</strong>.</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the position vector is resolved:</p>
<table>
<col width="40%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameA.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and r is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>Example: If resolveInFrame = Types.ResolveInFrameA.frame_a, the output vector is computed as:</p>
<pre><code>r = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor">Internal.PartialAbsoluteSensor</a> (Partial absolute sensor model for sensors defined by components).</p>
<h2 id="parameters-2">Parameters</h2>
<table>
<col width="43%" />
<col width="7%" />
<col width="13%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector r shall be resolved (1: world, 2: frame_a, 3:frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-2">Connectors</h2>
<table>
<col width="56%" />
<col width="8%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system at which the kinematic quantities are measured</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">r[3]</td>
<td align="left">Absolute position vector resolved in frame defined by resolveInFrame [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which output vector r is optionally resolved</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>model AbsolutePosition 
  &quot;Measure absolute position vector of the origin of a frame connector&quot;
  extends Internal.PartialAbsoluteSensor;
  Blocks.Interfaces.RealOutput r[3](each final quantity=&quot;Position&quot;, each final 
            unit =                                                                    &quot;m&quot;) 
    &quot;Absolute position vector resolved in frame defined by resolveInFrame&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve 
    &quot;Coordinate system in which output vector r is optionally resolved&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameA resolveInFrame=
  Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_a 
    &quot;Frame in which output vector r shall be resolved (1: world, 2: frame_a, 3:frame_resolve)&quot;;

protected 
  Internal.BasicAbsolutePosition position(resolveInFrame=resolveInFrame);

  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve);

equation 
  connect(position.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, position.frame_resolve);
  connect(position.r, r);
  connect(position.frame_a, frame_a);
end AbsolutePosition;</code></pre>
<hr />
<h1 id="image39-modelica.mechanics.multibody.sensors.absolutevelocity"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocityI.png" alt="image39" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.AbsoluteVelocity</h1>
<p><strong>Measure absolute velocity vector of origin of frame connector</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>The absolute velocity vector of the origin of frame_a is determined and provided at the output signal connector <strong>v</strong>.</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the velocity vector is resolved:</p>
<table>
<col width="40%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameA.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and v is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>Example: If resolveInFrame = Types.ResolveInFrameA.frame_a, the output vector is computed as:</p>
<pre><code>v0 = der(frame_a.r_0);
v  = MultiBody.Frames.resolve2(frame_a.R, v0);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor">Internal.PartialAbsoluteSensor</a> (Partial absolute sensor model for sensors defined by components).</p>
<h2 id="parameters-3">Parameters</h2>
<table>
<col width="43%" />
<col width="7%" />
<col width="13%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector v shall be resolved (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-3">Connectors</h2>
<table>
<col width="55%" />
<col width="8%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system at which the kinematic quantities are measured</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">v[3]</td>
<td align="left">Absolute velocity vector resolved in frame defined by resolveInFrame [m/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which output vector v is optionally resolved</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>model AbsoluteVelocity 
  &quot;Measure absolute velocity vector of origin of frame connector&quot;
  extends Internal.PartialAbsoluteSensor;
  Blocks.Interfaces.RealOutput v[3](each final quantity=&quot;Velocity&quot;, each final 
            unit =                                                                    &quot;m/s&quot;) 
    &quot;Absolute velocity vector resolved in frame defined by resolveInFrame&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if 
    resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve 
    &quot;Coordinate system in which output vector v is optionally resolved&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameA resolveInFrame=
      Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_a 
    &quot;Frame in which output vector v shall be resolved (1: world, 2: frame_a, 3: frame_resolve)&quot;;

protected 
  Internal.BasicAbsolutePosition position(resolveInFrame=Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world);
  Blocks.Continuous.Der der1[3];
  TansformAbsoluteVector tansformAbsoluteVector(
    frame_r_in=Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.world,
      frame_r_out=resolveInFrame);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition;
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition1 if 
       not (
    resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve);
equation 
  connect(position.r, der1.u);
  connect(position.frame_a, frame_a);
  connect(der1.y, tansformAbsoluteVector.r_in);
  connect(tansformAbsoluteVector.r_out, v);
  connect(zeroPosition.frame_resolve, position.frame_resolve);
  connect(tansformAbsoluteVector.frame_a, frame_a);
  connect(tansformAbsoluteVector.frame_resolve, zeroPosition1.frame_resolve);
  connect(tansformAbsoluteVector.frame_resolve, frame_resolve);
end AbsoluteVelocity;</code></pre>
<hr />
<h1 id="image40-modelica.mechanics.multibody.sensors.absoluteangles"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteAnglesI.png" alt="image40" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.AbsoluteAngles</h1>
<p><strong>Measure absolute angles between frame connector and the world frame</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p>This model determines the 3 angles to rotate the world frame into frame_a along the axes defined by parameter <strong>sequence</strong>. For example, if sequence = {3,1,2} then the world frame is rotated around angles[1] along the z-axis, afterwards it is rotated around angles[2] along the x-axis, and finally it is rotated around angles[3] along the y-axis and is then identical to frame_a. The 3 angles are returned in the range</p>
<pre><code>-p &lt;= angles[i] &lt;= p</code></pre>
<p>There are <strong>two solutions</strong> for &quot;angles[1]&quot; in this range. Via parameter <strong>guessAngle1</strong> (default = 0) the returned solution is selected such that |angles[1] - guessAngle1| is minimal. The transformation matrix between the world frame and frame_a may be in a singular configuration with respect to &quot;sequence&quot;, i.e., there is an infinite number of angle values leading to the same relative transformation matrix. In this case, the returned solution is selected by setting angles[1] = guessAngle1. Then angles[2] and angles[3] can be uniquely determined in the above range.</p>
<p>The parameter <strong>sequence</strong> has the restriction that only values 1,2,3 can be used and that sequence[1] ≠ sequence[2] and sequence[2] ≠ sequence[3]. Often used values are:</p>
<pre><code>sequence = {1,2,3}  // Cardan or Tait-Bryan angle sequence
         = {3,1,3}  // Euler angle sequence
         = {3,2,1}</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.RotationalSensor">Modelica.Icons.RotationalSensor</a> (Icon representing a round measurement device).</p>
<h2 id="parameters-4">Parameters</h2>
<table>
<col width="44%" />
<col width="5%" />
<col width="4%" />
<col width="45%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence</td>
<td align="left">{1,2,3}</td>
<td align="left">Angles are returned to rotate world frame around axes sequence[1], sequence[2] and finally sequence[3] into frame_a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">guessAngle1</td>
<td align="left">0</td>
<td align="left">Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum [rad]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-4">Connectors</h2>
<table>
<col width="57%" />
<col width="7%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a from which the angles shall be determined</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">angles[3]</td>
<td align="left">Angles to rotate world frame into frame_a via 'sequence' [rad]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>model AbsoluteAngles 
  &quot;Measure absolute angles between frame connector and the world frame&quot;
  extends Modelica.Icons.RotationalSensor;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
    &quot;Coordinate system a from which the angles shall be determined&quot;;

  Modelica.Blocks.Interfaces.RealOutput angles[3](each final quantity=&quot;Angles&quot;, each final 
            unit =                                                                                &quot;rad&quot;, each 
      displayUnit =                                                                                                    &quot;deg&quot;) 
    &quot;Angles to rotate world frame into frame_a via &#39;sequence&#39;&quot;;
  parameter MultiBody.Types.RotationSequence sequence(
    min={1,1,1},
    max={3,3,3})={1,2,3} 
    &quot;Angles are returned to rotate world frame around axes sequence[1], sequence[2] and finally sequence[3] into frame_a&quot;;
  parameter SI.Angle guessAngle1=0 
    &quot;Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum&quot;;

equation 
  frame_a.f = zeros(3);
  frame_a.t = zeros(3);
  angles = MultiBody.Frames.axesRotationsAngles(
    frame_a.R,
    sequence,
    guessAngle1);
end AbsoluteAngles;</code></pre>
<hr />
<h1 id="image41-modelica.mechanics.multibody.sensors.absoluteangularvelocity"><img src="Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocityI.png" alt="image41" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.AbsoluteAngularVelocity</h1>
<p><strong>Measure absolute angular velocity of frame connector</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p>The absolute angular velocity of frame_a with respect to the world frame is determined and provided at the output signal connector <strong>w</strong>.</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the angular velocity is resolved:</p>
<table>
<col width="41%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameA.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and w is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>Example: If resolveInFrame = Types.ResolveInFrameA.frame_a, the output vector is computed as:</p>
<pre><code>w = MultiBody.Frames.angularVelocity2(frame_a.R);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialAbsoluteSensor">Internal.PartialAbsoluteSensor</a> (Partial absolute sensor model for sensors defined by components).</p>
<h2 id="parameters-5">Parameters</h2>
<table>
<col width="43%" />
<col width="7%" />
<col width="13%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector w shall be resolved (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-5">Connectors</h2>
<table>
<col width="45%" />
<col width="7%" />
<col width="47%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system at which the kinematic quantities are measured</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">w[3]</td>
<td align="left">Absolute angular velocity vector of frame_a with respect to world frame, resolved in frame defined by resolveInFrame [1/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which w is optionally resolved</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>model AbsoluteAngularVelocity 
  &quot;Measure absolute angular velocity of frame connector&quot;
  extends Internal.PartialAbsoluteSensor;
  Blocks.Interfaces.RealOutput w[3](each final quantity=&quot;AngularVelocity&quot;, each final 
            unit =                                                                           &quot;1/s&quot;) 
    &quot;Absolute angular velocity vector of frame_a with respect to world frame, resolved in frame defined by resolveInFrame&quot;;


  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve 
    &quot;Coordinate system in which w is optionally resolved&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameA resolveInFrame=
  Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_a 
    &quot;Frame in which output vector w shall be resolved (1: world, 2: frame_a, 3: frame_resolve)&quot;;

protected 
  Internal.BasicAbsoluteAngularVelocity angularVelocity(resolveInFrame=
        resolveInFrame);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve);

equation 
  connect(angularVelocity.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, angularVelocity.frame_resolve);
  connect(angularVelocity.w, w);
  connect(angularVelocity.frame_a, frame_a);
end AbsoluteAngularVelocity;</code></pre>
<hr />
<h1 id="image42-modelica.mechanics.multibody.sensors.relativeposition"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativePositionI.png" alt="image42" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.RelativePosition</h1>
<p><strong>Measure relative position vector between the origins of two frame connectors</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p>The relative position vector between the origins of frame_a and frame_b are determined and provided at the output signal connector <strong>r_rel</strong>.</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the position vector is resolved:</p>
<table>
<col width="41%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve vector in frame_b</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and r_rel is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>Example: If resolveInFrame = Types.ResolveInFrameAB.frame_a, the output vector is computed as:</p>
<pre><code>r_rel = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor">Internal.PartialRelativeSensor</a> (Partial relative sensor model for sensors defined by components).</p>
<h2 id="parameters-6">Parameters</h2>
<table>
<col width="41%" />
<col width="6%" />
<col width="12%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector r_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-6">Connectors</h2>
<table>
<col width="57%" />
<col width="8%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">r_rel[3]</td>
<td align="left">Relative position vector resolved in frame defined by resolveInFrame</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which r_rel is optionally resolved</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>model RelativePosition 
  &quot;Measure relative position vector between the origins of two frame connectors&quot;
  extends Internal.PartialRelativeSensor;
  Blocks.Interfaces.RealOutput r_rel[3] 
    &quot;Relative position vector resolved in frame defined by resolveInFrame&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve 
    &quot;Coordinate system in which r_rel is optionally resolved&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrame=
  Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a 
    &quot;Frame in which output vector r_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;

protected 
  Internal.BasicRelativePosition relativePosition(resolveInFrame=resolveInFrame);

  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve);

equation 
  connect(relativePosition.frame_a, frame_a);
  connect(relativePosition.frame_b, frame_b);
  connect(relativePosition.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, relativePosition.frame_resolve);
  connect(relativePosition.r_rel, r_rel);
end RelativePosition;</code></pre>
<hr />
<h1 id="image43-modelica.mechanics.multibody.sensors.relativevelocity"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativeVelocityI.png" alt="image43" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.RelativeVelocity</h1>
<p><strong>Measure relative velocity vector between the origins of two frame connectors</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<p>The relative velocity vector between the origins of frame_a and of frame_b are determined and provided at the output signal connector <strong>v_rel</strong>. This vector is defined as:</p>
<pre><code>r_rel = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
v_rel = der(r_rel);</code></pre>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the velocity vector is resolved:</p>
<table>
<col width="41%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve vector in frame_b</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and v_rel is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>Example: If resolveInFrame = Types.ResolveInFrameAB.frame_b, the output vector is computed as:</p>
<pre><code>r_rel   = MultiBody.Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
v_rel_a = der(r_rel);
v_rel   = MultiBody.Frames.resolveRelative(frame_a.R, frame_b.R, v_rel_a);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor">Internal.PartialRelativeSensor</a> (Partial relative sensor model for sensors defined by components).</p>
<h2 id="parameters-7">Parameters</h2>
<table>
<col width="41%" />
<col width="6%" />
<col width="12%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector v_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-7">Connectors</h2>
<table>
<col width="55%" />
<col width="8%" />
<col width="35%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">v_rel[3]</td>
<td align="left">Relative velocity vector resolved in frame defined by resolveInFrame [m/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which v_rel is optionally resolved</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>model RelativeVelocity 
  &quot;Measure relative velocity vector between the origins of two frame connectors&quot;
  extends Internal.PartialRelativeSensor;
  Modelica.Blocks.Interfaces.RealOutput v_rel[3](each final quantity=&quot;Velocity&quot;, each final 
            unit =                                                                        &quot;m/s&quot;) 
    &quot;Relative velocity vector resolved in frame defined by resolveInFrame&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve 
    &quot;Coordinate system in which v_rel is optionally resolved&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrame=
  Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a 
    &quot;Frame in which output vector v_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;

protected 
  RelativePosition relativePosition(resolveInFrame=Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve);
  Modelica.Blocks.Continuous.Der der_r_rel[3];
  TansformRelativeVector tansformRelativeVector(
      frame_r_in= Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a,
      frame_r_out=resolveInFrame);
equation 
  connect(relativePosition.frame_a, frame_a);
  connect(relativePosition.frame_b, frame_b);
  connect(relativePosition.r_rel, der_r_rel.u);
  connect(der_r_rel.y, tansformRelativeVector.r_in);
  connect(tansformRelativeVector.r_out, v_rel);
  connect(tansformRelativeVector.frame_a, frame_a);
  connect(tansformRelativeVector.frame_b, frame_b);
  connect(tansformRelativeVector.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, tansformRelativeVector.frame_resolve);
end RelativeVelocity;</code></pre>
<hr />
<h1 id="image44-modelica.mechanics.multibody.sensors.relativeangles"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativeAnglesI.png" alt="image44" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.RelativeAngles</h1>
<p><strong>Measure relative angles between two frame connectors</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<p>This model determines the 3 angles to rotate frame_a into frame_b along the axes defined by parameter <strong>sequence</strong>. For example, if sequence = {3,1,2} then frame_a is rotated around angles[1] along the z-axis, afterwards it is rotated around angles[2] along the x-axis, and finally it is rotated around angles[3] along the y-axis and is then identical to frame_b. The 3 angles are returned in the range</p>
<pre><code>-p &lt;= angles[i] &lt;= p</code></pre>
<p>There are <strong>two solutions</strong> for &quot;angles[1]&quot; in this range. Via parameter <strong>guessAngle1</strong> (default = 0) the returned solution is selected such that |angles[1] - guessAngle1| is minimal. The relative transformation matrix between frame_a and frame_b may be in a singular configuration with respect to &quot;sequence&quot;, i.e., there is an infinite number of angle values leading to the same relative transformation matrix. In this case, the returned solution is selected by setting angles[1] = guessAngle1. Then angles[2] and angles[3] can be uniquely determined in the above range.</p>
<p>The parameter <strong>sequence</strong> has the restriction that only values 1,2,3 can be used and that sequence[1] ≠ sequence[2] and sequence[2] ≠ sequence[3]. Often used values are:</p>
<pre><code>sequence = {1,2,3}  // Cardan or Tait-Bryan angle sequence
         = {3,1,3}  // Euler angle sequence
         = {3,2,1}</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.RotationalSensor">Modelica.Icons.RotationalSensor</a> (Icon representing a round measurement device).</p>
<h2 id="parameters-8">Parameters</h2>
<table>
<col width="44%" />
<col width="6%" />
<col width="4%" />
<col width="44%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence</td>
<td align="left">{1,2,3}</td>
<td align="left">Angles are returned to rotate frame_a around axes sequence[1], sequence[2] and finally sequence[3] into frame_b</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">guessAngle1</td>
<td align="left">0</td>
<td align="left">Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum [rad]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-8">Connectors</h2>
<table>
<col width="58%" />
<col width="7%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">angles[3]</td>
<td align="left">Angles to rotate frame_a into frame_b via 'sequence' [rad]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>model RelativeAngles 
  &quot;Measure relative angles between two frame connectors&quot;
  extends Modelica.Icons.RotationalSensor;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a &quot;Coordinate system a&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b &quot;Coordinate system b&quot;;

  Modelica.Blocks.Interfaces.RealOutput angles[3](each final quantity=&quot;Angles&quot;, each final 
            unit =                                                                                &quot;rad&quot;, displayUnit=&quot;deg&quot;) 
    &quot;Angles to rotate frame_a into frame_b via &#39;sequence&#39;&quot;;
  parameter MultiBody.Types.RotationSequence sequence(
    min={1,1,1},
    max={3,3,3})={1,2,3} 
    &quot;Angles are returned to rotate frame_a around axes sequence[1], sequence[2] and finally sequence[3] into frame_b&quot;;
  parameter SI.Angle guessAngle1=0 
    &quot;Select angles[1] such that abs(angles[1] - guessAngle1) is a minimum&quot;;
  Modelica.Mechanics.MultiBody.Frames.Orientation R_rel 
    &quot;Relative orientation object from frame_a to frame_b&quot;;

equation 
  frame_a.f = zeros(3);
  frame_a.t = zeros(3);
  frame_b.f = zeros(3);
  frame_b.t = zeros(3);
  R_rel = Modelica.Mechanics.MultiBody.Frames.relativeRotation(frame_a.R, frame_b.R);
  angles = MultiBody.Frames.axesRotationsAngles(
    R_rel,
    sequence,
    guessAngle1);
end RelativeAngles;</code></pre>
<hr />
<h1 id="image45-modelica.mechanics.multibody.sensors.relativeangularvelocity"><img src="Modelica.Mechanics.MultiBody.Sensors.RelativeAngularVelocityI.png" alt="image45" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.RelativeAngularVelocity</h1>
<p><strong>Measure relative angular velocity between two frame connectors</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<p>The relative angular velocity between frame_a and frame_b is determined and provided at the output signal connector <strong>w_rel</strong>.</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the angular velocity is resolved:</p>
<table>
<col width="41%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve vector in frame_b</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and w_rel is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>Example: If resolveInFrame = Types.ResolveInFrameAB.frame_a, the output vector is computed as:</p>
<pre><code>// Relative orientation object from frame_a to frame_b
R_rel = MultiBody.Frames.relativeRotation(frame_a.R, frame_b.R);

// Angular velocity resolved in frame_a
w_rel = MultiBody.Frames.angularVelocity1(R_rel);</code></pre>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor">Internal.PartialRelativeSensor</a> (Partial relative sensor model for sensors defined by components).</p>
<h2 id="parameters-9">Parameters</h2>
<table>
<col width="41%" />
<col width="6%" />
<col width="12%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector w_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-9">Connectors</h2>
<table>
<col width="47%" />
<col width="7%" />
<col width="45%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">w_rel[3]</td>
<td align="left">Relative angular velocity vector between frame_a and frame_b resolved in frame defined by resolveInFrame [1/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which w_rel is optionally resolved</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>model RelativeAngularVelocity 
  &quot;Measure relative angular velocity between two frame connectors&quot;
  extends Internal.PartialRelativeSensor;
  Blocks.Interfaces.RealOutput w_rel[3](each final quantity=&quot;AngularVelocity&quot;, each final 
            unit =                                                                               &quot;1/s&quot;) 
    &quot;Relative angular velocity vector between frame_a and frame_b resolved in frame defined by resolveInFrame&quot;;


  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if resolveInFrame ==
    Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve 
    &quot;Coordinate system in which w_rel is optionally resolved&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB
    resolveInFrame=
  Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a 
    &quot;Frame in which output vector w_rel shall be resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;

protected 
  Internal.BasicRelativeAngularVelocity relativeAngularVelocity(resolveInFrame=
        resolveInFrame);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve);

equation 
  connect(relativeAngularVelocity.frame_a, frame_a);
  connect(relativeAngularVelocity.frame_b, frame_b);
  connect(relativeAngularVelocity.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, relativeAngularVelocity.frame_resolve);
  connect(relativeAngularVelocity.w_rel, w_rel);
end RelativeAngularVelocity;</code></pre>
<hr />
<h1 id="image46-modelica.mechanics.multibody.sensors.distance"><img src="Modelica.Mechanics.MultiBody.Sensors.DistanceI.png" alt="image46" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.Distance</h1>
<p><strong>Measure the distance between the origins of two frame connectors</strong></p>
<h2 id="information-11">Information</h2>
<p>::</p>
<p>The <strong>distance</strong> between the origins of frame_a and of frame_b are determined and provided at the output signal connector <strong>distance</strong>. This distance is always positive. <strong>Derivatives</strong> of this signal can be easily obtained by connecting the block <a href="Modelica_Blocks_Continuous.html#Modelica.Blocks.Continuous.Der">Modelica.Blocks.Continuous.Der</a> to &quot;distance&quot; (this block performs analytic differentiation of the input signal using the der(..) operator).</p>
<p>In the following figure the animation of a Distance sensor is shown. The light blue coordinate system is frame_a, the dark blue coordinate system is frame_b, and the yellow arrow is the animated sensor.</p>
<p>If the distance is smaller as parameter <strong>s_small</strong> (in the &quot;advanced&quot; menu), it is approximated such that its derivative is finite for zero distance. Without such an approximation, the derivative would be infinite and a division by zero would occur. The approximation is performed in the following way: If distance &gt; s_small, it is computed as sqrt(r*r) where r is the position vector from the origin of frame_a to the origin of frame_b. If the distance becomes smaller as s_small, the &quot;sqrt()&quot; function is approximated by a second order polynomial, such that the function value and its first derivative are identical for sqrt() and the polynomial at s_small. Futhermore, the polynomial passes through zero. The effect is, that the distance function is continuous and differentiable everywhere. The derivative at zero distance is 3/(2*s_small).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected), <a href="Modelica_Icons.html#Modelica.Icons.TranslationalSensor">Modelica.Icons.TranslationalSensor</a> (Icon representing a linear measurement device).</p>
<h2 id="parameters-10">Parameters</h2>
<table>
<col width="46%" />
<col width="9%" />
<col width="13%" />
<col width="30%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show arrow)</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">arrowDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of relative arrow from frame_a to frame_b [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">arrowColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of relative arrow from frame_a to frame_b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">s_small</td>
<td align="left">1.E-10</td>
<td align="left">Prevent zero-division if distance between frame_a and frame_b is zero [m]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-10">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">distance</td>
<td align="left">Distance between the origin of frame_a and the origin of frame_b</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>model Distance 
  &quot;Measure the distance between the origins of two frame connectors&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Frames;
  import Modelica.Mechanics.MultiBody.Types;

  extends Interfaces.PartialTwoFrames;
  extends Modelica.Icons.TranslationalSensor;
  Modelica.Blocks.Interfaces.RealOutput distance 
    &quot;Distance between the origin of frame_a and the origin of frame_b&quot;;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show arrow)&quot;;
  input SI.Diameter arrowDiameter=world.defaultArrowDiameter 
    &quot;Diameter of relative arrow from frame_a to frame_b&quot;;
  input Types.Color arrowColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot;Color of relative arrow from frame_a to frame_b&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  input SI.Position s_small(min=sqrt(Modelica.Constants.small))=1.E-10 
    &quot;Prevent zero-division if distance between frame_a and frame_b is zero&quot;;
protected 
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Arrow arrow(
    r=frame_a.r_0,
    r_head=frame_b.r_0 - frame_a.r_0,
    diameter=arrowDiameter,
    color=arrowColor,
    specularCoefficient=specularCoefficient) if world.enableAnimation and animation;

protected 
  SI.Position r_rel_0[3] = frame_b.r_0 - frame_a.r_0 
    &quot;Position vector from frame_a to frame_b resolved in world frame&quot;;
  SI.Area L2 = r_rel_0*r_rel_0;
  SI.Area s_small2 = s_small^2;
equation 
  frame_a.f = zeros(3);
  frame_b.f = zeros(3);
  frame_a.t = zeros(3);
  frame_b.t = zeros(3);

  distance =  smooth(1,if noEvent(L2 &gt; s_small2) then sqrt(L2) else L2/(2*s_small)*(3-L2/s_small2));
end Distance;</code></pre>
<hr />
<h1 id="image47-modelica.mechanics.multibody.sensors.cutforce"><img src="Modelica.Mechanics.MultiBody.Sensors.CutForceI.png" alt="image47" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.CutForce</h1>
<p><strong>Measure cut force vector</strong></p>
<h2 id="information-12">Information</h2>
<p>::</p>
<p>The cut-force acting between the two frames to which this model is connected, is determined and provided at the output signal connector <strong>force</strong> (= frame_a.f). If parameter <strong>positiveSign</strong> = <strong>false</strong>, the negative cut-force is provided (= frame_b.f).</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the force vector is resolved:</p>
<table>
<col width="41%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve vector in frame_b</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and output force is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>In the following figure the animation of a CutForce sensor is shown. The dark blue coordinate system is frame_b, and the green arrow is the cut force acting at frame_b and with negative sign at frame_a.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor">Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor</a> (Base model to measure the cut force and/or torque between two frames, defined by components).</p>
<h2 id="parameters-11">Parameters</h2>
<table>
<col width="41%" />
<col width="8%" />
<col width="12%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show arrow)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">positiveSign</td>
<td align="left">true</td>
<td align="left">= true, if force with positive sign is returned (= frame_a.f), otherwise with negative sign (= frame_b.f)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector(s) is/are resolved (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">N_to_m</td>
<td align="left">1000</td>
<td align="left">Force arrow scaling (length = force/N_to_m) [N/m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">forceDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of force arrow [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">forceColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of force arrow</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-11">Connectors</h2>
<table>
<col width="52%" />
<col width="8%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">force[3]</td>
<td align="left">Cut force resolved in frame defined by resolveInFrame [N]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Output vectors are optionally resolved in this frame (cut-force/-torque are set to zero)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>model CutForce &quot;Measure cut force vector&quot;

  import SI = Modelica.SIunits;

  Modelica.Blocks.Interfaces.RealOutput force[3](final quantity=&quot;Force&quot;, final unit=&quot;N&quot;) 
    &quot;Cut force resolved in frame defined by resolveInFrame&quot;;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show arrow)&quot;;
  parameter Boolean positiveSign=true 
    &quot;= true, if force with positive sign is returned (= frame_a.f), otherwise with negative sign (= frame_b.f)&quot;;

  input Real N_to_m(unit=&quot;N/m&quot;) = 1000 
    &quot; Force arrow scaling (length = force/N_to_m)&quot;;
  input SI.Diameter forceDiameter=world.defaultArrowDiameter 
    &quot; Diameter of force arrow&quot;;
  input Types.Color forceColor=Modelica.Mechanics.MultiBody.Types.Defaults.
      ForceColor &quot; Color of force arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  extends Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor;

protected 
  SI.Position f_in_m[3]=frame_a.f*(if positiveSign then +1 else -1)/N_to_m 
    &quot;Force mapped from N to m for animation&quot;;
  Visualizers.Advanced.Arrow forceArrow(
    diameter=forceDiameter,
    color=forceColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=f_in_m,
    r_head=-f_in_m) if world.enableAnimation and animation;

  Internal.BasicCutForce cutForce(resolveInFrame=resolveInFrame, positiveSign=
        positiveSign);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve);
equation 
  connect(cutForce.frame_a, frame_a);
  connect(cutForce.frame_b, frame_b);
  connect(cutForce.frame_resolve, frame_resolve);
  connect(cutForce.force, force);
  connect(zeroPosition.frame_resolve, cutForce.frame_resolve);
end CutForce;</code></pre>
<hr />
<h1 id="image48-modelica.mechanics.multibody.sensors.cuttorque"><img src="Modelica.Mechanics.MultiBody.Sensors.CutTorqueI.png" alt="image48" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.CutTorque</h1>
<p><strong>Measure cut torque vector</strong></p>
<h2 id="information-13">Information</h2>
<p>::</p>
<p>The cut-torque acting between the two frames to which this model is connected, is determined and provided at the output signal connector <strong>torque</strong> (= frame_a.t). If parameter <strong>positiveSign</strong> = <strong>false</strong>, the negative cut-torque is provided (= frame_b.t).</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the torque vector is resolved:</p>
<table>
<col width="41%" />
<col width="51%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vector in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vector in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve vector in frame_b</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve vector in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and output torque is resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>In the following figure the animation of a CutTorque sensor is shown. The dark blue coordinate system is frame_b, and the green arrow is the cut torque acting at frame_b and with negative sign at frame_a.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor">Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor</a> (Base model to measure the cut force and/or torque between two frames, defined by components).</p>
<h2 id="parameters-12">Parameters</h2>
<table>
<col width="41%" />
<col width="8%" />
<col width="12%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show arrow)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">positiveSign</td>
<td align="left">true</td>
<td align="left">= true, if torque with positive sign is returned (= frame_a.t), otherwise with negative sign (= frame_b.t)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector(s) is/are resolved (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">Nm_to_m</td>
<td align="left">1000</td>
<td align="left">Torque arrow scaling (length = torque/Nm_to_m) [N.m/m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">torqueDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of torque arrow [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">torqueColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of torque arrow</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-12">Connectors</h2>
<table>
<col width="52%" />
<col width="8%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">torque[3]</td>
<td align="left">Cut torque resolved in frame defined by resolveInFrame</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Output vectors are optionally resolved in this frame (cut-force/-torque are set to zero)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-12">Modelica definition</h2>
<pre><code>model CutTorque &quot;Measure cut torque vector&quot;

  import SI = Modelica.SIunits;

  Modelica.Blocks.Interfaces.RealOutput torque[3] 
    &quot;Cut torque resolved in frame defined by resolveInFrame&quot;;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show arrow)&quot;;
  parameter Boolean positiveSign=true 
    &quot;= true, if torque with positive sign is returned (= frame_a.t), otherwise with negative sign (= frame_b.t)&quot;;
  input Real Nm_to_m(unit=&quot;N.m/m&quot;) = 1000 
    &quot;Torque arrow scaling (length = torque/Nm_to_m)&quot;;
  input SI.Diameter torqueDiameter=world.defaultArrowDiameter 
    &quot;Diameter of torque arrow&quot;;
  input Types.Color torqueColor=Modelica.Mechanics.MultiBody.Types.Defaults.TorqueColor 
    &quot;Color of torque arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  extends Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor;

protected 
  SI.Position t_in_m[3]=frame_a.t*(if positiveSign then +1 else -1)/Nm_to_m 
    &quot;Torque mapped from Nm to m for animation&quot;;
  Visualizers.Advanced.DoubleArrow torqueArrow(
    diameter=torqueDiameter,
    color=torqueColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=t_in_m,
    r_head=-t_in_m) if world.enableAnimation and animation;
  Internal.BasicCutTorque cutTorque(resolveInFrame=resolveInFrame, positiveSign=
       positiveSign);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve);
equation 
  connect(cutTorque.frame_a, frame_a);
  connect(cutTorque.frame_b, frame_b);
  connect(cutTorque.torque, torque);
  connect(cutTorque.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, cutTorque.frame_resolve);
end CutTorque;</code></pre>
<hr />
<h1 id="image49-modelica.mechanics.multibody.sensors.cutforceandtorque"><img src="Modelica.Mechanics.MultiBody.Sensors.CutForceAndTorqueI.png" alt="image49" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.CutForceAndTorque</h1>
<p><strong>Measure cut force and cut torque vector</strong></p>
<h2 id="information-14">Information</h2>
<p>::</p>
<p>The cut-force and cut-torque acting between the two frames to which this model is connected, are determined and provided at the output signal connectors <strong>force</strong> (= frame_a.f) and <strong>torque</strong> (= frame_a.t). If parameter <strong>positiveSign</strong> = <strong>false</strong>, the negative cut-force and cut-torque is provided (= frame_b.f, frame_b.t).</p>
<p>Via parameter <strong>resolveInFrame</strong> it is defined, in which frame the two vectors are resolved:</p>
<table>
<col width="41%" />
<col width="52%" />
<thead>
<tr class="header">
<th align="left"><strong>resolveInFrame = Types.ResolveInFrameAB.</strong></th>
<th align="left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">world</td>
<td align="left">Resolve vectors in world frame</td>
</tr>
<tr class="even">
<td align="left">frame_a</td>
<td align="left">Resolve vectors in frame_a</td>
</tr>
<tr class="odd">
<td align="left">frame_b</td>
<td align="left">Resolve vectors in frame_b</td>
</tr>
<tr class="even">
<td align="left">frame_resolve</td>
<td align="left">Resolve vectors in frame_resolve</td>
</tr>
</tbody>
</table>
<p>If resolveInFrame = Types.ResolveInFrameAB.frame_resolve, the conditional connector &quot;frame_resolve&quot; is enabled and the output vectors force and torque are resolved in the frame, to which frame_resolve is connected. Note, if this connector is enabled, it must be connected.</p>
<p>In the following figure the animation of a CutForceAndTorque sensor is shown. The dark blue coordinate system is frame_b, and the green arrows are the cut force and the cut torque, respectively, acting at frame_b and with negative sign at frame_a.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor">Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor</a> (Base model to measure the cut force and/or torque between two frames, defined by components).</p>
<h2 id="parameters-13">Parameters</h2>
<table>
<col width="39%" />
<col width="7%" />
<col width="11%" />
<col width="41%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show force and torque arrow)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">positiveSign</td>
<td align="left">true</td>
<td align="left">= true, if force and torque with positive sign is returned (= frame_a.f/.t), otherwise with negative sign (= frame_b.f/.t)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">resolveInFrame</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which output vector(s) is/are resolved (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">N_to_m</td>
<td align="left">1000</td>
<td align="left">Force arrow scaling (length = force/N_to_m) [N/m]</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">Nm_to_m</td>
<td align="left">1000</td>
<td align="left">Torque arrow scaling (length = torque/Nm_to_m) [N.m/m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">forceDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of force arrow [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">torqueDiameter</td>
<td align="left">forceDiameter</td>
<td align="left">Diameter of torque arrow [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">forceColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of force arrow</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">torqueColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of torque arrow</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-13">Connectors</h2>
<table>
<col width="52%" />
<col width="8%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">force[3]</td>
<td align="left">Cut force resolved in frame defined by resolveInFrame [N]</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">torque[3]</td>
<td align="left">Cut torque resolved in frame defined by resolveInFrame</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Output vectors are optionally resolved in this frame (cut-force/-torque are set to zero)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-13">Modelica definition</h2>
<pre><code>model CutForceAndTorque &quot;Measure cut force and cut torque vector&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;

  Modelica.Blocks.Interfaces.RealOutput force[3](final quantity=&quot;Force&quot;, final unit=&quot;N&quot;) 
    &quot;Cut force resolved in frame defined by resolveInFrame&quot;;
  Modelica.Blocks.Interfaces.RealOutput torque[3] 
    &quot;Cut torque resolved in frame defined by resolveInFrame&quot;;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show force and torque arrow)&quot;;
  parameter Boolean positiveSign=true 
    &quot;= true, if force and torque with positive sign is returned (= frame_a.f/.t), otherwise with negative sign (= frame_b.f/.t)&quot;;
  input Real N_to_m(unit=&quot;N/m&quot;) = 1000 
    &quot;Force arrow scaling (length = force/N_to_m)&quot;;
  input Real Nm_to_m(unit=&quot;N.m/m&quot;) = 1000 
    &quot;Torque arrow scaling (length = torque/Nm_to_m)&quot;;
  input SI.Diameter forceDiameter=world.defaultArrowDiameter 
    &quot;Diameter of force arrow&quot;;
  input SI.Diameter torqueDiameter=forceDiameter &quot; Diameter of torque arrow&quot;;
  input Types.Color forceColor=Modelica.Mechanics.MultiBody.Types.Defaults.ForceColor 
    &quot;Color of force arrow&quot;;
  input Types.Color torqueColor=Modelica.Mechanics.MultiBody.Types.Defaults.TorqueColor 
    &quot;Color of torque arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  extends Modelica.Mechanics.MultiBody.Sensors.Internal.PartialCutForceSensor;

protected 
  parameter Integer csign=if positiveSign then +1 else -1;
  SI.Position f_in_m[3]=frame_a.f*csign/N_to_m 
    &quot;Force mapped from N to m for animation&quot;;
  SI.Position t_in_m[3]=frame_a.t*csign/Nm_to_m 
    &quot;Torque mapped from Nm to m for animation&quot;;
  Visualizers.Advanced.Arrow forceArrow(
    diameter=forceDiameter,
    color=forceColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=f_in_m,
    r_head=-f_in_m) if world.enableAnimation and animation;
  Visualizers.Advanced.DoubleArrow torqueArrow(
    diameter=torqueDiameter,
    color=torqueColor,
    specularCoefficient=specularCoefficient,
    R=frame_b.R,
    r=frame_b.r_0,
    r_tail=t_in_m,
    r_head=-t_in_m) if world.enableAnimation and animation;
  Internal.BasicCutForce cutForce(resolveInFrame=resolveInFrame, positiveSign=
        positiveSign);
  Internal.BasicCutTorque cutTorque(resolveInFrame=resolveInFrame, positiveSign=
       positiveSign);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (resolveInFrame == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve);
equation 
  connect(cutForce.frame_a, frame_a);
  connect(cutForce.frame_b, cutTorque.frame_a);
  connect(cutTorque.frame_b, frame_b);
  connect(cutForce.force, force);
  connect(cutTorque.torque, torque);
  connect(zeroPosition.frame_resolve, cutTorque.frame_resolve);
  connect(zeroPosition.frame_resolve, cutForce.frame_resolve);
  connect(cutForce.frame_resolve, frame_resolve);
  connect(cutTorque.frame_resolve, frame_resolve);
end CutForceAndTorque;</code></pre>
<hr />
<h1 id="image50-modelica.mechanics.multibody.sensors.power"><img src="Modelica.Mechanics.MultiBody.Sensors.PowerI.png" alt="image50" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.Power</h1>
<p><strong>Measure power flowing from frame_a to frame_b</strong></p>
<h2 id="information-15">Information</h2>
<p>::</p>
<p>This component provides the power flowing from frame_a to frame_b as output signal <strong>power</strong>.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.RotationalSensor">Modelica.Icons.RotationalSensor</a> (Icon representing a round measurement device), <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="connectors-14">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">power</td>
<td align="left">Power at frame_a as output signal [W]</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-14">Modelica definition</h2>
<pre><code>model Power &quot;Measure power flowing from frame_a to frame_b&quot;
  import SI = Modelica.SIunits;
  extends Modelica.Icons.RotationalSensor;

  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  Modelica.Blocks.Interfaces.RealOutput power(quantity=&quot;Power&quot;,unit=&quot;W&quot;) 
    &quot;Power at frame_a as output signal&quot;;

equation 
  Connections.branch(frame_a.R, frame_b.R);
  frame_a.r_0 = frame_b.r_0;
  frame_a.R = frame_b.R;
  zeros(3) = frame_a.f + frame_b.f;
  zeros(3) = frame_a.t + frame_b.t;
  power = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0))
     + frame_a.t*Frames.angularVelocity2(frame_a.R);
end Power;</code></pre>
<hr />
<h1 id="image51-modelica.mechanics.multibody.sensors.tansformabsolutevector"><img src="Modelica.Mechanics.MultiBody.Sensors.TansformAbsoluteVectorI.png" alt="image51" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.TansformAbsoluteVector</h1>
<p><strong>Transform absolute vector in to another frame</strong></p>
<h2 id="information-16">Information</h2>
<p>::</p>
<p>The input vector &quot;Real r_in[3]&quot; is assumed to be an absolute kinematic quantity of frame_a that is defined to be resolved in the frame defined with parameter &quot;frame_r_in&quot;. This model resolves vector r_in in the coordinate system defined with parameter &quot;frame_r_out&quot; and returns the transformed output vector as &quot;Real r_out[3]&quot;;</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.RotationalSensor">Modelica.Icons.RotationalSensor</a> (Icon representing a round measurement device).</p>
<h2 id="parameters-14">Parameters</h2>
<table>
<col width="40%" />
<col width="6%" />
<col width="12%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">frame_r_in</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which vector r_in is resolved (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameA">ResolveInFrameA</a></td>
<td align="left">frame_r_out</td>
<td align="left">frame_r_in</td>
<td align="left">Frame in which vector r_in shall be resolved and provided as r_out (1: world, 2: frame_a, 3: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-15">Connectors</h2>
<table>
<col width="56%" />
<col width="8%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system from which absolute kinematic quantities are measured</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which r_in or r_out is optionally resolved</td>
</tr>
<tr class="odd">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">r_in[3]</td>
<td align="left">Input vector resolved in frame defined by frame_r_in</td>
</tr>
<tr class="even">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">r_out[3]</td>
<td align="left">Input vector r_in resolved in frame defined by frame_r_out</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-15">Modelica definition</h2>
<pre><code>model TansformAbsoluteVector 
  &quot;Transform absolute vector in to another frame&quot;
  extends Modelica.Icons.RotationalSensor;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
    &quot;Coordinate system from which absolute kinematic quantities are measured&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if 
   (frame_r_in  == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve) or 
   (frame_r_out == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve) 
    &quot;Coordinate system in which r_in or r_out is optionally resolved&quot;;

  Blocks.Interfaces.RealInput r_in[3] 
    &quot;Input vector resolved in frame defined by frame_r_in&quot;;
  Blocks.Interfaces.RealOutput r_out[3] 
    &quot;Input vector r_in resolved in frame defined by frame_r_out&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameA frame_r_in=
  Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_a 
    &quot;Frame in which vector r_in is resolved (1: world, 2: frame_a, 3: frame_resolve)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameA frame_r_out=
                  frame_r_in 
    &quot;Frame in which vector r_in shall be resolved and provided as r_out (1: world, 2: frame_a, 3: frame_resolve)&quot;;

protected 
  Internal.BasicTransformAbsoluteVector basicTransformVector(frame_r_in=
        frame_r_in, frame_r_out=frame_r_out);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (frame_r_in == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve or 
         frame_r_out == Modelica.Mechanics.MultiBody.Types.ResolveInFrameA.frame_resolve);

equation 
  connect(basicTransformVector.frame_a, frame_a);
  connect(basicTransformVector.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, basicTransformVector.frame_resolve);
  connect(basicTransformVector.r_out, r_out);
  connect(basicTransformVector.r_in, r_in);
end TansformAbsoluteVector;</code></pre>
<hr />
<h1 id="image52-modelica.mechanics.multibody.sensors.tansformrelativevector"><img src="Modelica.Mechanics.MultiBody.Sensors.TansformRelativeVectorI.png" alt="image52" /> <a href="Modelica_Mechanics_MultiBody_Sensors.html#Modelica.Mechanics.MultiBody.Sensors">Modelica.Mechanics.MultiBody.Sensors</a>.TansformRelativeVector</h1>
<p><strong>Transform relative vector in to another frame</strong></p>
<h2 id="information-17">Information</h2>
<p>::</p>
<p>The input vector &quot;Real r_in[3]&quot; is assumed to be a relative kinematic quantity between frame_a and frame_b that is defined to be resolved in the frame defined with parameter &quot;frame_r_in&quot;. This model resolves vector r_in in the coordinate system defined with parameter &quot;frame_r_out&quot; and returns the transformed output vector as &quot;Real r_out[3]&quot;;</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Sensors_Internal.html#Modelica.Mechanics.MultiBody.Sensors.Internal.PartialRelativeSensor">Internal.PartialRelativeSensor</a> (Partial relative sensor model for sensors defined by components).</p>
<h2 id="parameters-15">Parameters</h2>
<table>
<col width="39%" />
<col width="5%" />
<col width="11%" />
<col width="42%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">frame_r_in</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Frame in which vector r_in is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB">ResolveInFrameAB</a></td>
<td align="left">frame_r_out</td>
<td align="left">frame_r_in</td>
<td align="left">Frame in which vector r_in shall be resolved and provided as r_out (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-16">Connectors</h2>
<table>
<col width="58%" />
<col width="8%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system a</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system b</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve">Frame_resolve</a></td>
<td align="left">frame_resolve</td>
<td align="left">Coordinate system in which r_in or r_out is optionally resolved</td>
</tr>
<tr class="even">
<td align="left">input <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput">RealInput</a></td>
<td align="left">r_in[3]</td>
<td align="left">Input vector resolved in frame defined by frame_r_in</td>
</tr>
<tr class="odd">
<td align="left">output <a href="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealOutput">RealOutput</a></td>
<td align="left">r_out[3]</td>
<td align="left">Input vector r_in resolved in frame defined by frame_r_out</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-16">Modelica definition</h2>
<pre><code>model TansformRelativeVector 
  &quot;Transform relative vector in to another frame&quot;
  extends Internal.PartialRelativeSensor;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_resolve frame_resolve if 
   (frame_r_in  == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve) or 
   (frame_r_out == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve) 
    &quot;Coordinate system in which r_in or r_out is optionally resolved&quot;;

  Blocks.Interfaces.RealInput r_in[3] 
    &quot;Input vector resolved in frame defined by frame_r_in&quot;;
  Blocks.Interfaces.RealOutput r_out[3] 
    &quot;Input vector r_in resolved in frame defined by frame_r_out&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB frame_r_in=
  Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_a 
    &quot;Frame in which vector r_in is resolved (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB frame_r_out=
                  frame_r_in 
    &quot;Frame in which vector r_in shall be resolved and provided as r_out (1: world, 2: frame_a, 3: frame_b, 4: frame_resolve)&quot;;

protected 
  Modelica.Mechanics.MultiBody.Sensors.Internal.BasicTransformRelativeVector
    basicTransformVector(
      frame_r_in=frame_r_in,
      frame_r_out=frame_r_out);
  Modelica.Mechanics.MultiBody.Interfaces.ZeroPosition zeroPosition if 
    not (frame_r_in == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve or 
         frame_r_out == Modelica.Mechanics.MultiBody.Types.ResolveInFrameAB.frame_resolve);

equation 
  connect(basicTransformVector.frame_a, frame_a);
  connect(basicTransformVector.frame_b, frame_b);
  connect(basicTransformVector.frame_resolve, frame_resolve);
  connect(zeroPosition.frame_resolve, basicTransformVector.frame_resolve);
  connect(basicTransformVector.r_out, r_out);
  connect(basicTransformVector.r_in, r_in);
end TansformRelativeVector;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:30:39 2010.</p>
</body>
</html>
