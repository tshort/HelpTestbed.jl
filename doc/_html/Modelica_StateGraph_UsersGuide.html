<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.StateGraph.UsersGuide</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.StateGraph.UsersGuide</h1>
</div>
<h1 id="modelica.stategraph.usersguide-modelica.stategraph.usersguide"><img src="Modelica.StateGraph.UsersGuideI.png" alt="Modelica.StateGraph.UsersGuide" /> <a href="Modelica_StateGraph.html#Modelica.StateGraph">Modelica.StateGraph</a>.UsersGuide</h1>
<p>::</p>
<p>Library <strong>StateGraph</strong> is a <strong>free</strong> Modelica package providing components to model <strong>discrete event</strong> and <strong>reactive</strong> systems in a convenient way. This package contains the <strong>User's Guide</strong> for the library and has the following content:</p>
<ol>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.OverView">Overview of library</a> gives an overview of the library.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.FirstExample">A first example</a> demonstrates at hand of a first example how to use this library.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ApplicationExample">An application example</a> demonstrates varies features at hand of the control of a two tank system.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2">Comparison with StateGraph2</a> compares Modelica.StateGraph with the much improved version Modelica_StateGraph2.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ReleaseNotes">Release Notes</a> summarizes the differences between different versions of this library.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature">Literature</a> provides references that have been used to design and implement this library.</li>
<li><a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Contact">Contact</a> provides information about the authors of the library as well as acknowledgments.</li>
</ol>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information">Modelica.Icons.Information</a> (Icon for general information packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="85%" />
<col width="14%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="image8" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.OverView">OverView</a></td>
<td align="left">Overview of library</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="image9" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.FirstExample">FirstExample</a></td>
<td align="left">A first example</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="image10" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ApplicationExample">ApplicationExample</a></td>
<td align="left">An application example</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.StateGraph.UsersGuide.OverViewS.png" alt="image11" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ComparisonWithStateGraph2">ComparisonWithStateGraph2</a></td>
<td align="left">Comparison with StateGraph2</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.StateGraph.UsersGuide.ReleaseNotesS.png" alt="image12" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.ReleaseNotes">ReleaseNotes</a></td>
<td align="left">Release notes</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.StateGraph.UsersGuide.LiteratureS.png" alt="image13" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature">Literature</a></td>
<td align="left">Literature</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.StateGraph.UsersGuide.ContactS.png" alt="image14" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Contact">Contact</a></td>
<td align="left">Contact</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image15-modelica.stategraph.usersguide.overview"><img src="Modelica.StateGraph.UsersGuideI.png" alt="image15" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide">Modelica.StateGraph.UsersGuide</a>.OverView</h1>
<p>::</p>
<p>In this section, an overview of the most important features of this library is given.</p>
<h3 id="steps-and-transitions">Steps and Transitions</h3>
<p>A <strong>StateGraph</strong> is an enhanced finite state machine. It is based on the JGraphChart method and takes advantage of Modelica features for the &quot;action&quot; language. JGraphChart is a further development of Grafcet to include elements of StateCharts that are not present in Grafcet/Sequential Function Charts. Therefore, the StateGraph library has a similar modeling power as StateCharts but avoids some deficiences of StateCharts.</p>
<p>The basic elements of StateGraphs are <strong>steps</strong> and <strong>transitions</strong>:</p>
<p><strong>Steps</strong> represent the possible states a StateGraph can have. If a step is active the Boolean variable <strong>active</strong> of the step is <strong>true</strong>. If it is deactivated, <strong>active</strong> = <strong>false</strong>. At the initial time, all &quot;usual&quot; steps are deactivated. The <strong>InitialStep</strong> objects are steps that are activated at the initial time. They are characterized by a double box (see figure above).</p>
<p><strong>Transitions</strong> are used to change the state of a StateGraph. When the step connected to the input of a transition is active, the step connected to the output of this transition is deactivated and the transition condition becomes true, then the transition fires. This means that the step connected to the input to the transition is deactivated and the step connected to the output of the transition is activated.</p>
<p>The transition <strong>condition</strong> is defined via the parameter menu of the transition object. Clicking on object &quot;transition1&quot; in the above figure, results in the following menu:</p>
<p>In the input field &quot;<strong>condition</strong>&quot;, any type of time varying Boolean expression can be given (in Modelica notation, this is a modification of the time varying variable <strong>condition</strong>). Whenever this condition is true, the transition can fire. Additionally, it is possible to activate a timer, via <strong>enableTimer</strong> (see menu above) and provide a <strong>waitTime</strong>. In this case the firing of the transition is delayed according to the provided waitTime. The transition condition and the waitTime are displayed in the transition icon.</p>
<p>In the above example, the simulation starts at <strong>initialStep</strong>. After 1 second, <strong>transition1</strong> fires and <strong>step1</strong> becomes active. After another second <strong>transition2</strong> fires and <strong>initialStep</strong> becomes again active. After a further second <strong>step1</strong> becomes again active, and so on.</p>
<p>In JGrafcharts, Grafcet and Sequential Function Charts, the network of steps and transitions is drawn from top to bottom. In StateGraphs, no particular direction is defined, since steps and transitions are blocks with input and output connectors that can be arbitrarily placed and connected. Usually, it is most practical to define the network from left to right, as in the example above, since then it is easy to read the labels on the icons.</p>
<h3 id="conditions-and-actions">Conditions and Actions</h3>
<p>With the block <strong>TransitionWithSignal</strong>, the firing condition can be provided as Boolean input signal, instead as entry in the menu of the transition. An example is given in the next figure:</p>
<p>Component &quot;step&quot; is an instance of &quot;StepWithSignal&quot; that is a usual step where the active flag is available as Boolean output signal. To this output, component &quot;Timer&quot; from library &quot;Modelica.Blocks.Logical&quot; is connected. It measures the time from the time instant where the Boolean input (i.e., the active flag of the step) became true upto the current time instant. The timer is connected to a comparison component. The output is true, once the timer reaches 1 second. This signal is used as condition input of the transition. As a result, &quot;transition2&quot; fires, once step &quot;step&quot; has been active for 1 second. Of course, any other Modelica block with a Boolean output signal can be connected to the condition input of such a transition block as well.</p>
<p>Conditions of a transition can either be computed by a network of logical blocks from the Logical library as in the figure above, or via the &quot;SetBoolean&quot; component any type of logical expression can be defined in textual form, as shown in the next figure:</p>
<p>With the block &quot;<strong>SetBoolean</strong>&quot;, a time varying expression can be provided as modification to the output signal <strong>y</strong> (see block with icon text &quot;timer.y &gt; 1&quot; in the figure above). The output signal can be in turn connected to the condition input of a TransitionWithSignal block.</p>
<p>The &quot;<strong>SetBoolean</strong>&quot; block can also be used to compute a Boolean signal depending on the active step. In the figure above, the output of the block with the icon text &quot;step.active&quot; is true, when &quot;step&quot; is active, otherwise it is false (note, the icon text of &quot;SetBoolean&quot; displays the modification of the output signal &quot;y&quot;). This signal can then be used to compute desired <strong>actions</strong> in the physical systems model. For example, if a <strong>valve</strong> shall be open, when the StateGraph is in &quot;step1&quot; or in &quot;step4&quot;, a &quot;SetBoolean&quot; block may be connected to the valve model using the following condition:</p>
<pre><code>valve = step1.active or step2.active</code></pre>
<p>Via the Modelica operators <strong>edge</strong>(..) and <strong>change</strong>(..), conditions depending on rising and falling edges of Boolean expressions can be used when needed.</p>
<p>In JGrafcharts, Grafcet, Sequential Function Charts and StateCharts, <strong>actions</strong> are formulated <strong>within a step</strong>. Such actions are distinguished as <strong>entry</strong>, <strong>normal</strong>, <strong>exit</strong> and <strong>abort</strong> actions. For example, a valve might be opened by an entry action of a step and might be closed by an exit action of the same step. In StateGraphs, this is (fortunately) <strong>not possible</strong> due to Modelicas &quot;single assignment rule&quot; that requires that every variable is defined by exactly one equation. Instead, the approach explained above is used. For example, via the &quot;SetBoolean&quot; component, the valve variable is set to true when the StateGraph is in particular steps.</p>
<p>This feature of a StateGraph is <strong>very useful</strong>, since it allows a Modelica translator to <strong>guarantee</strong> that a given StateGraph has always <strong>deterministic</strong> behaviour without conflicts. In the other methodologies this is much more cumbersome. For example, if two steps are executed in parallel and both step actions modify the same variable, the result is either non-deterministic or non-obvious rules have to be defined which action takes priority. In a StateGraph, such a situation is detected by the translator resulting in an error, since there are two equations to compute one variable. Additional benefits of the StateGraph approach are:</p>
<ul>
<li>A JGrafchart or a StateChart need to potentially access variables in a step that are defined in higher hierarchical levels of a model. Therefore, mostly <strong>global variables</strong> are used in the whole network, even if the network is structured hierarchically. In StateGraphs this is not necessary, since the physical systems outside of a StateGraph might access the step or transition state via a hierarchical name. This means that <strong>no global variables</strong> are needed, because the local variables in the StateGraph are accessed from local variables outside of the StateGraph.</li>
<li>It is simpler for a user to understand the information that is provided in the non-graphical definition, since every variable is defined at exactly one place. In the other methodologies, the setting and re-setting of the same variable is cluttered within the whole network.</li>
</ul>
<p>To emphasize this important difference between these methodologies, consider the case that a state machine has the following hierarchy:</p>
<pre><code>stateMachine.superstate1.superstate2.step1</code></pre>
<p>Within &quot;step1&quot; a StateChart would, e.g., access variable &quot;stateMachine.openValve&quot;, say as &quot;entry action: openValve = true&quot;. This typical usage has the severe drawback that it is not possible to use the hierarchical state &quot;superstate1&quot; as component in another context, because &quot;step1&quot; references a particular name outside of this component.</p>
<p>In a StateGraph, there would be typically a &quot;SetBoolean&quot; component in the &quot;stateMachine&quot; component stating:</p>
<pre><code>openValve = superstate1.superstate2.step1.active;</code></pre>
<p>As a result, the &quot;superstate1&quot; component can be used in another context, because it does not depend on the environment where it is used.</p>
<h3 id="execution-model">Execution Model</h3>
<p>The execution model of a StateGraph follows from its Modelica implementation: Given the states of all steps, i.e., whether a step is active or not active, the equations of all steps, transitions, transition conditions, actions etc. are sorted resulting in an execution sequence to compute essentially the new values of the steps. If conflicts occur, e.g., if there are more equations as variables, of if there are algebraic loops between Boolean variables, an exception is raised. Once all equations have been processed, the <strong>active</strong> variable of all steps are updated to the newly calculated values. Afterwards, the equations are again evaluated. The iteration stops, once no step changes its state anymore, i.e., once no transition fires anymore. Then, simulation continuous until a new event is triggered, (when a relation changes its value).</p>
<p>With the Modelica &quot;sampled(..)&quot; operator, a StateGraph might also be executed within a discrete controller that is called at regular time instants. In a future version of the StateGraph library, this might be more directly supported.</p>
<h3 id="parallel-and-alternative-execution">Parallel and Alternative Execution</h3>
<p>Parallel activities can be defined by component <strong>Parallel</strong> and alternative activities can be defined by component <strong>Alternative</strong>. An example for both components is given in the next figure.</p>
<p>Here, the branch from &quot;step2&quot; to &quot;step5&quot; is executed in parallel to &quot;step1&quot;. A transition connected to the output of a parallel branch component can only fire if the final steps in all parallel branches are active simultaneously. The figure above is a screen-shot from the animation of the StateGraph: Whenever a step is active or a transition can fire, the corresponding component is marked in <strong>green</strong> color.</p>
<p>The three branches within &quot;step2&quot; to &quot;step5&quot; are executed alternatively, depending which transition condition of &quot;transition3&quot;, &quot;transition4&quot;, &quot;transition4a&quot; fires first. Since all three transitions fire after 1 second, they are all candidates for the active branch. If two or more transitions would fire at the same time instant, a priority selection is made: The alternative and parallel components have a vector of connectors. Every branch has to be connected to exactly one entry of the connector vector. The entry with the lowest number has the highest priority.</p>
<p>Parallel, Alternative and Step components have vectors of connectors. The dimensions of these vectors are set in the corresponding parameter menu. E.g. in a &quot;Parallel&quot; component:</p>
<p>Currently in Dymola the following menu pops up, when a branch is connected to a vector of components in order to define the vector index to which the component shall be connected:</p>
<h3 id="compositesteps-suspend-and-resume-port">CompositeSteps, Suspend and Resume Port</h3>
<p>A StateGraph can be hierarchically structured by using a <strong>CompositeStep</strong>. This is a component that inherits from <strong>PartialCompositeStep</strong>. An example is given in the next figure (from Examples.ControlledTanks):</p>
<p>The CompositeStep component contains a local StateGraph that is entered by one or more input transitions and that is left by one or more output transitions. Also, other needed signals may enter a CompositeStep. The CompositeStep has similiar properties as a &quot;usual&quot; step: The CompositeStep is <strong>active</strong> once at least one step within the CompositeStep is active. Variable <strong>active</strong> defines the state of the CompositeStep.</p>
<p>Additionally, a CompositeStep has a <strong>suspend</strong> port. Whenever the transition connected to this port fires, the CompositeStep is left at once. When leaving the CompositeStep via the suspend port, the internal state of the CompositeStep is saved, i.e., the active flags of all steps within the CompositeStep. The CompositeStep might be entered via its <strong>resume</strong> port. In this case the internal state from the suspend transition is reconstructed and the CompositeStep continues the execution that it had before the suspend transition fired (this corresponds to the history ports of StateCharts or JGrafCharts).</p>
<p>A CompositeStep may contain other CompositeSteps. At every level, a CompositeStep and all of its content can be left via its suspend ports (actually, there is a vector of suspend connectors, i.e., a CompositeStep might be aborted due to different transitions).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information">Modelica.Icons.Information</a> (Icon for general information packages).</p>
<hr />
<h1 id="image16-modelica.stategraph.usersguide.firstexample"><img src="Modelica.StateGraph.UsersGuideI.png" alt="image16" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide">Modelica.StateGraph.UsersGuide</a>.FirstExample</h1>
<p>::</p>
<p>A first example will be given here (not yet done).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information">Modelica.Icons.Information</a> (Icon for general information packages).</p>
<hr />
<h1 id="image17-modelica.stategraph.usersguide.applicationexample"><img src="Modelica.StateGraph.UsersGuideI.png" alt="image17" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide">Modelica.StateGraph.UsersGuide</a>.ApplicationExample</h1>
<p>::</p>
<p>In this section a more realistic, still simple, application example is given, to demonstrate various features of the StateGraph library. This example shows the control of a two tank system from the master thesis of Isolde Dressler (<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature">see literature</a>).</p>
<p>In the following figure the top level of the model is shown. This model is available as StateGraph.Examples.ControlledTanks.</p>
<p>In the right part of the figure, two tanks are shown. At the top part, a large fluid source is present from which fluid can be filled in <strong>tank1</strong> when <strong>valve1</strong> is open. Tank1 can be emptied via <strong>valve2</strong> that is located in the bottom of tank2 and fills a second <strong>tank2</strong> which in turn is emptied via <strong>valve3</strong>. The actual levels of the tanks are measured and are provided as signals <strong>level1</strong> and <strong>level2</strong> to the <strong>tankController</strong>.</p>
<p>The <strong>tankController</strong> is controlled by three buttons, <strong>start</strong>, <strong>stop</strong> and <strong>shut</strong> (for shutdown) that are mutually exclusive. This means that whenever one button is pressed (i.e., its state is <strong>true</strong>) then the other two buttons are not pressed (i.e., their states are <strong>false</strong>). When button <strong>start</strong> is pressed, the &quot;normal&quot; operation to fill and to empty the two tanks is processed:</p>
<ol>
<li>Valve 1 is opened and tank 1 is filled.</li>
<li>When tank 1 reaches its fill level limit, valve 1 is closed.</li>
<li>After a waiting time, valve 2 is opened and the fluid flows from tank 1 into tank 2.</li>
<li>When tank 1 is empty, valve 2 is closed.</li>
<li>After a waiting time, valve 3 is opened and the fluid flows out of tank 2</li>
<li>When tank 2 is empty, valve 3 is closed</li>
</ol>
<p>The above &quot;normal&quot; process can be influenced by the following buttons:</p>
<ul>
<li>Button <strong>start</strong> starts the above process. When this button is pressed after a &quot;stop&quot; or &quot;shut&quot; operation, the process operation continues.</li>
<li>Button <strong>stop</strong> stops the above process by closing all valves. Then, the controller waits for further input (either &quot;start&quot; or &quot;shut&quot; operation).</li>
<li>Button <strong>shut</strong> is used to shutdown the process, by emptying at once both tanks. When this is achieved, the process goes back to its start configuration. Clicking on &quot;start&quot;, restarts the process.</li>
</ul>
<p>The implementation of the <strong>tankController</strong> is shown in the next figure:</p>
<p>When the &quot;<strong>start</strong>&quot; button is pressed, the stateGraph is within the CompositeStep &quot;<strong>makeProduct</strong>&quot;. During normal operation this CompositeStep is only left, once tank2 is empty. Afterwards, the CompositeStep is at once re-entered.</p>
<p>When the &quot;<strong>stop</strong>&quot; button is pressed, the &quot;makeProduct&quot; CompositeStep is at once terminated via the &quot;<strong>suspend</strong>&quot; port and the stateGraph waits in step &quot;<strong>s2</strong>&quot; for further commands. When the &quot;<strong>start</strong>&quot; button is pressed, the CompositeStep is re-entered via its <strong>resume</strong> port and the &quot;normal&quot; operation continues at the state where it was aborted by the suspend transition. If the &quot;<strong>shut</strong>&quot; button is pressed, the stateGraph waits in the &quot;<strong>emptyTanks</strong>&quot; step, until both tanks are empty and then waits at the initial step &quot;<strong>s1</strong>&quot; for further input.</p>
<p>The opening and closing of valves is <strong>not</strong> directly defined in the stateGraph. Instead via the &quot;<strong>setValveX</strong>&quot; components, the Boolean state of the valves are computed. For example, the output y of &quot;setValve2&quot; is computed as:</p>
<pre><code>y = makeProduct.fillTank2.active or emptyTanks.active</code></pre>
<p>i.e., valve2 is open, when step &quot;makeProduct.fillTank2 or when step &quot;emptyTanks&quot; is active. Otherwise, valve2 is closed.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information">Modelica.Icons.Information</a> (Icon for general information packages).</p>
<hr />
<h1 id="image18-modelica.stategraph.usersguide.comparisonwithstategraph2"><img src="Modelica.StateGraph.UsersGuideI.png" alt="image18" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide">Modelica.StateGraph.UsersGuide</a>.ComparisonWithStateGraph2</h1>
<p>::</p>
<p>There is a much improved library available called &quot;Modelica_StateGraph2&quot;. If this library is not yet distributed with your Modelica tool, you can download it from <a href="http://www.modelica.org/libraries/Modelica_StateGraph2">http://www.modelica.org/libraries/Modelica_StateGraph2</a>. Find below a comparison with respect to Modelica.StateGraph. It is not yet clear whether Modelica_StateGraph2 will be included in a future version of the Modelica package. Another option is to provide built-in support for state machines in a future Modelica language version which would allow an even more powerful treatment of state machines in Modelica.</p>
<p>The Modelica_StateGraph2 library (called StateGraph2 below) is based on the experience with the current Modelica.StateGraph library (called StateGraph1 below) and is a significantly further development of StateGraph1. Furthermore, it is heavily based on the article (Malmheden et. al. 2008), see Literature below, but uses a different implementation technique as described in this article. The StateGraph2 library has the following improvements with respect to the StateGraph1 library:</p>
<ul>
<li><dl>
<dt><strong>3 Basic Components (Step, Transition, Parallel)</strong></dt>
<dd><p>All multiple versions of a component are combined in only one</p>
</dd>
</dl>
version (e.g., one step and not 4 step components). This is easier to understand and more convenient to use. The &quot;Parallel&quot; component is both used as &quot;composite step&quot; (so only one branch), as well as &quot;parallel step&quot; (so several execution branches).</li>
<li><dl>
<dt><strong>Conveniently connecting components</strong></dt>
<dd><p>Connecting components of a state machine in Modelica means to</p>
</dd>
</dl>
provide new vector dimensions and to provide a vector index to connect to. In StateGraph2, the new &quot;connectorSizing&quot; annotation is used and therefore all this is now performed automatically (from a users point of view, these actions are hidden; this is not the case in StateGraph1 and makes the usage of the StateGraph1 library clumsy).</li>
<li><dl>
<dt><strong>Safer state machines</strong></dt>
<dd><p>It is no longer possible to construct a wrong state machine in the</p>
</dd>
</dl>
sense that properties of the graph are violated (e.g., two initial steps, or branching wrongly out of a parallel component). Contrary to StateGraph2, in StateGraph1 such wrong graphs do not lead to an error but to unexpected simulation results. Still, other desirable properties of a state machine, such as &quot;no deadlock&quot; or &quot;lifeliness&quot; or &quot;every step reachable&quot;, are not (yet) guaranteed with the current StateGraph2.</li>
<li><dl>
<dt><strong>Composite, autonomous, synchronized, preempted subgraphs</strong></dt>
<dd><p>Composite steps and parallel steps are described in a much better</p>
</dd>
</dl>
<p>and more powerful way as in StateGraph1: Either by component &quot;Parallel&quot; or by inheriting from &quot;PartialParallel&quot;. The first alternative has the advantage that it is simple to use (not necessary to construct a new class and instanciating this class, and easy variable access since no new hierarchy is constructed), the second alternative has the advantage that it introduces a Modelica hierarchy (useful for large subgraphs). In both cases, various options are possible, such as</p>
<ol>
<li>autonomous subgraphs (branches are executed in parallel autonomously),</li>
<li>synchronized subgraphs (branches are executed in parallel and are synchronized before leaving the subgraph via the outPort),</li>
<li>subgraphs with preemption and exception (a parallel step can be interrupted via the suspend ports and can continue execution via the resume ports).</li>
</ol>
This is achieved by enabling/disabling the different ports.</li>
<li><dl>
<dt><strong>No infinite looping</strong>:</dt>
<dd><p>As in StateGraph1, there are two types of transitions: immediate</p>
</dd>
</dl>
<p>transitions (during event iteration all immediate transitions fire until no transition condition is true anymore) and delayed transitions (a transition fires only after a delay). Contrary to StateGraph1, in StateGraph2 every loop must have at least one delayed transition. If this is not the case a translation error occurs which states that the model contains an algebraic loop between Booleans with the name &quot;checkOneDelayedTransitionPerLoop&quot;. This property guarantees that an event iteration over a StateGraph2 converges after a finite number of iterations, provided the modeller does not introduce an unsafe construct in the actions associated with a StateGraph2 (e.g., &quot;i = pre(i) + 1&quot; in the equation section outside of a when-clause will give an event iteration that never stops). It is possible to switch off this feature, by setting parameter &quot;loopCheck = <strong>false</strong>&quot; in one transition of a loop, instead of using a &quot;delayed transition&quot; at this place (in cases where immediate transitions are important and the transition conditions are in a form that they cannot fire at the same time instant).</p></li>
</ul>
<h3 id="literature">Literature</h3>
<p>The Modelica_StateGraph2 library is described in detail in (Otter et. al. 2009, see below) and is additionally based on the following references:</p>
<dl>
<dt>André, C. (2003):</dt>
<dd><p><a href="http://www.i3s.unice.fr/~map/WEBSPORTS/Documents/2003a2005/SSMsemantics.pdf">Semantics of S.S.M (Safe State Machine).</a>. I3S Laboratory, UMR 6070 University of Nice-Sophia Antipolis / CNRS.</p>
</dd>
<dt>Arzen K.-E. (2004):</dt>
<dd><p><strong>JGrafchart User Manual. Version 1.5</strong>. Department of Automatic Control, Lund Institute of Technology, Lund, Sweden, Feb. 13, 2004.</p>
</dd>
<dt>Dressler I. (2004):</dt>
<dd><p><a href="http://www.control.lth.se/documents/2004/5726.pdf">Code Generation From JGrafchart to Modelica.</a>. Master thesis, supervisor: Karl-Erik Arzen, Department of Automatic Control, Lund Institute of Technology, Lund, Sweden, March 30, 2004.</p>
</dd>
<dt>Elmqvist H., Mattsson S.E., Otter M. (2001):</dt>
<dd><p><strong>Object-Oriented and Hybrid Modeling in Modelica</strong>. Journal Europeen des systemes automatises (JESA), Volume 35 - n. 1, 2001.</p>
</dd>
<dt>Harel, D. (1987):</dt>
<dd><p><a href="http://www.inf.ed.ac.uk/teaching/courses/seoc1/2005_2006/resources/statecharts.pdf">A Visual Formalism for Complex Systems</a>. Science of Computer Programming 8, 231-274. Department of Applied Mathematics, The Weizmann Institute of Science, Rehovot, Israel.</p>
</dd>
<dt>Malmheden M. (2007):</dt>
<dd><p><a href="http://www.control.lth.se/documents/2007/5808.pdf">ModeGraph - A Mode-Automata-Based Modelica Library for Embedded Control</a>. Master thesis, Department of Automatic Control, Lund University, Sweden.</p>
</dd>
<dt>Malmheden M., Elmqvist H., Mattsson S.E., Henrisson D., Otter M. (2008):</dt>
<dd><p><a href="http://www.modelica.org/events/modelica2008/Proceedings/sessions/session3a3.pdf">ModeGraph - A Modelica Library for Embedded Control based on Mode-Automata</a>. Modelica'2008 Conference, March 3-4, 2008.</p>
</dd>
<dt>Maraninchi F., Rémond, Y. (2002):</dt>
<dd><p><a href="http://www.sciencedirect.com/science?_ob=MImg&amp;_imagekey=B6V17-461XK2H-2-1&amp;_cdi=5667&amp;_user=100058&amp;_pii=S016764230200093X&amp;_origin=search&amp;_coverDate=03%2F31%2F2003&amp;_sk=999539996&amp;view=c&amp;wchp=dGLzVlz-zSkWA&amp;md5=7ef5d0b715e52fa5deec5cca6e0a4d99&amp;ie=/sdarticle.pdf">Mode-Automata: A New Domain-Specific Construct for the Development of Safe Critical Systems</a>.</p>
</dd>
<dt>Mosterman P., Otter M., Elmqvist H. (1998):</dt>
<dd><p><a href="http://www.modelica.org/publications/papers/scsc98fp.pdf">Modeling Petri Nets as Local Constraint Equations for Hybrid Systems using Modelica</a>. SCSC'98, Reno, Nevada, USA, Society for Computer Simulation International, pp. 314-319, 1998.</p>
</dd>
<dt>Otter M., Malmheden M., Elmqvist H., Mattsson S.E., Johnsson C. (2009):</dt>
<dd><p><a href="http://www.modelica.org/events/modelica2009">A New Formalism for Modeling of Reactive and Hybrid Systems</a>. Modelica'2009 Conference, Como, Italy, Sept. 20-22, 2009.</p>
</dd>
</dl>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Information">Modelica.Icons.Information</a> (Icon for general information packages).</p>
<hr />
<h1 id="image19-modelica.stategraph.usersguide.releasenotes"><img src="Modelica.StateGraph.UsersGuide.ReleaseNotesI.png" alt="image19" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide">Modelica.StateGraph.UsersGuide</a>.ReleaseNotes</h1>
<p>::</p>
<h3 id="version-0.87-2004-06-23">Version 0.87, 2004-06-23</h3>
<ul>
<li>Included in Modelica standard library 2.0 Beta 1 with the new block connectors. Changed all the references to the block connectors and the Logical library correspondingly.</li>
</ul>
<h3 id="version-0.86-2004-06-20">Version 0.86, 2004-06-20</h3>
<ul>
<li>New components &quot;Alternative&quot; and &quot;Parallel&quot; for alternative and parallel execution paths.</li>
<li>A step has now a vector of input and output connectors in order that multiple connections to and from a step are possible</li>
<li>Removed components &quot;AlternativeSplit&quot;, &quot;AlternativeJoin&quot;, &quot;ParallelSplit&quot; and &quot;ParallelJoin&quot; since the newly introduced components (&quot;Alternative&quot;, &quot;Parallel&quot;, vector connectors of steps) have the same modeling power but are safer and more convenient.</li>
<li>Removed the timer in a step (attach instead Logical.Timer to the &quot;active&quot; port of a &quot;StepWithSignal&quot; component). Note, that in most cases it is more convenient and more efficient to use the built-in timer of a transition.</li>
<li>Component &quot;StepInitial&quot; renamed to &quot;InitialStep&quot;.</li>
<li>New component &quot;Timer&quot; within sublibrary Logical.</li>
<li>Updated and improved documentation of the library.</li>
</ul>
<h3 id="version-0.85-2004-06-17">Version 0.85, 2004-06-17</h3>
<ul>
<li>Renamed &quot;MacroStep&quot; to &quot;CompositeStep&quot; and the ports of the MacroStep from &quot;abort&quot; to &quot;suspend&quot; and &quot;histoy&quot; to &quot;resume&quot;.</li>
<li>Nested &quot;CompositeStep&quot; components are supported, based on the experimental feature of nested inner/outer components introduced by Dymola. This means that CompositeSteps can be suspended and resumed at every level.</li>
<li>New example &quot;Examples.ShowExceptions&quot; to demonstrate the new feature of nested CompositeSteps.</li>
<li>New package &quot;Logical&quot;. It contains all components of ModelicaAdditions.Blocks.Logical, but with new block connectors and nicer icons. Additionally, logical blocks are also added.</li>
<li>Improved icons for several components of the StateGraph library.</li>
</ul>
<h3 id="version-0.83-2004-05-21">Version 0.83, 2004-05-21</h3>
<ul>
<li>The &quot;abort&quot; and &quot;history&quot; connectors are no longer visible in the diagram layer of a CompositeStep since it is not allowed to connect to them in a CompositeStep.</li>
<li>Made the diagram/icon size of a CompositeStep smaller (from 200/-200 to 150/-150).</li>
<li>Improved icons for &quot;SetBoolean/SetInteger/SetReal&quot; components.</li>
<li>Renamed &quot;ParameterReal&quot; to &quot;SetRealParameter&quot;.</li>
</ul>
<h3 id="version-0.82-2004-05-18">Version 0.82, 2004-05-18</h3>
<p>Implemented a first version that is provided to other people.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.ReleaseNotes">Modelica.Icons.ReleaseNotes</a> (Icon for release notes in documentation).</p>
<hr />
<h1 id="image20-modelica.stategraph.usersguide.literature"><img src="Modelica.StateGraph.UsersGuide.LiteratureI.png" alt="image20" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide">Modelica.StateGraph.UsersGuide</a>.Literature</h1>
<p>::</p>
<p>The StateGraph library is based on the following references:</p>
<dl>
<dt>Arzen K.-E. (2004):</dt>
<dd><p><strong>JGrafchart User Manual. Version 1.5</strong>. Department of Automatic Control, Lund Institute of Technology, Lund, Sweden, Feb. 13</p>
</dd>
<dt>Dressler I. (2004):</dt>
<dd><p><strong>Code Generation From JGrafchart to Modelica</strong>. Master thesis, supervisor: Karl-Erik Arzen, Department of Automatic Control, Lund Institute of Technology, Lund, Sweden, March 30</p>
</dd>
<dt>Elmqvist H., Mattsson S.E., Otter M. (2001):</dt>
<dd><p><strong>Object-Oriented and Hybrid Modeling in Modelica</strong>. Journal Europeen des systemes automatises (JESA), Volume 35 - n. 1.</p>
</dd>
<dt>Mosterman P., Otter M., Elmqvist H. (1998):</dt>
<dd><p><strong>Modeling Petri Nets as Local Constraint Equations for Hybrid Systems using Modelica</strong>. SCSC'98, Reno, Nevada, USA, Society for Computer Simulation International, pp. 314-319.</p>
</dd>
</dl>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.References">Modelica.Icons.References</a> (Icon for external references).</p>
<hr />
<h1 id="image21-modelica.stategraph.usersguide.contact"><img src="Modelica.StateGraph.UsersGuide.ContactI.png" alt="image21" /> <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide">Modelica.StateGraph.UsersGuide</a>.Contact</h1>
<p>::</p>
<p><strong>Main Author:</strong></p>
<dl>
<dt><a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a></dt>
<dd><p>Deutsches Zentrum für Luft und Raumfahrt e.V. (DLR) Institut für Robotik und Mechatronik Abteilung für Entwurfsorientierte Regelungstechnik Postfach 1116 D-82230 Wessling Germany email: <script type="text/javascript">
<!--
h='&#100;&#108;&#114;&#46;&#100;&#x65;';a='&#64;';n='&#x6d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x6f;&#116;&#116;&#x65;&#114;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'<script type="text/javascript">
<!--
h='&#100;&#108;&#114;&#46;&#100;&#x65;';a='&#64;';n='&#x6d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x6f;&#116;&#116;&#x65;&#114;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+'Martin.Otter@dlr.de'+'<\/'+'a'+'>');
// -->
</script><noscript>&#x4d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x4f;&#116;&#116;&#x65;&#114;&#64;&#100;&#108;&#114;&#46;&#100;&#x65;&#32;&#40;&#x6d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x6f;&#116;&#116;&#x65;&#114;&#32;&#x61;&#116;&#32;&#100;&#108;&#114;&#32;&#100;&#x6f;&#116;&#32;&#100;&#x65;&#x29;</noscript>'+'<\/'+'a'+'>');
// -->
</script><noscript>&#60;&#x73;&#x63;&#114;&#x69;&#112;&#116;&#32;&#116;&#x79;&#112;&#x65;&#x3d;&#34;&#116;&#x65;&#120;&#116;&#x2f;&#106;&#x61;&#118;&#x61;&#x73;&#x63;&#114;&#x69;&#112;&#116;&#34;&#62;&#10;&#60;&#x21;&#x2d;&#x2d;&#10;&#104;&#x3d;&#x27;&#100;&#108;&#114;&#46;&#100;&#x65;&#x27;&#x3b;&#x61;&#x3d;&#x27;&#64;&#x27;&#x3b;&#110;&#x3d;&#x27;&#x6d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x6f;&#116;&#116;&#x65;&#114;&#x27;&#x3b;&#x65;&#x3d;&#110;&#x2b;&#x61;&#x2b;&#104;&#x3b;&#10;&#100;&#x6f;&#x63;&#x75;&#x6d;&#x65;&#110;&#116;&#46;&#x77;&#114;&#x69;&#116;&#x65;&#40;&#x27;&#60;&#x61;&#32;&#104;&#x27;&#x2b;&#x27;&#114;&#x65;&#102;&#x27;&#x2b;&#x27;&#x3d;&#34;&#x6d;&#x61;&#x27;&#x2b;&#x27;&#x69;&#108;&#116;&#x6f;&#x27;&#x2b;&#x27;&#58;&#x27;&#x2b;&#x65;&#x2b;&#x27;&#34;&#62;&#x27;&#x2b;&#x27;&#x4d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x4f;&#116;&#116;&#x65;&#114;&#64;&#100;&#108;&#114;&#46;&#100;&#x65;&#x27;&#x2b;&#x27;&#60;&#92;&#x2f;&#x27;&#x2b;&#x27;&#x61;&#x27;&#x2b;&#x27;&#62;&#x27;&#x29;&#x3b;&#10;&#x2f;&#x2f;&#32;&#x2d;&#x2d;&#62;&#10;&#60;&#x2f;&#x73;&#x63;&#114;&#x69;&#112;&#116;&#62;&#60;&#110;&#x6f;&#x73;&#x63;&#114;&#x69;&#112;&#116;&#62;&#x4d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x4f;&#116;&#116;&#x65;&#114;&#64;&#100;&#108;&#114;&#46;&#100;&#x65;&#32;&#40;&#x6d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x6f;&#116;&#116;&#x65;&#114;&#32;&#x61;&#116;&#32;&#100;&#108;&#114;&#32;&#100;&#x6f;&#116;&#32;&#100;&#x65;&#x29;&#60;&#x2f;&#110;&#x6f;&#x73;&#x63;&#114;&#x69;&#112;&#116;&#62;&#32;&#40;&#x6d;&#x61;&#114;&#116;&#x69;&#110;&#46;&#x6f;&#116;&#116;&#x65;&#114;&#32;&#x61;&#116;&#32;&#100;&#108;&#114;&#32;&#100;&#x6f;&#116;&#32;&#100;&#x65;&#x29;</noscript></p>
</dd>
</dl>
<p><strong>Acknowledgements:</strong></p>
<ul>
<li>The development of this library was strongly motivated by the master thesis of Isolde Dressler (<a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature">see literature</a>), in which a compiler from JGrafChart to Modelica was designed and implemented. This project was supervised by Karl-Erik Arzen from Departement of Automatic Control, Lund Institut of Technology, Lund, Sweden.</li>
<li>This library profits also from the experience gained in the focused research program (Schwerpunktprogramm) &quot;Continuous-Discrete Dynamic Systems&quot; (KONDISK), sponsored by the Deutsche Forschungsgemeinschaft under grants OT174/1-2 and EN152/22-2. This support is most gratefully acknowledged.</li>
<li>The implementation of the basic components of this library by describing finite state machines with equations is based on (Elmqvist, Mattsson and Otter, 2001), which in turn uses ideas from (Mosterman, Otter and Elmqvist, 1998), see <a href="Modelica_StateGraph_UsersGuide.html#Modelica.StateGraph.UsersGuide.Literature">literature</a></li>
</ul>
<p>::</p>
<p>Extends from <a href="Modelica_Icons.html#Modelica.Icons.Contact">Modelica.Icons.Contact</a> (Icon for contact information).</p>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:27:41 2010.</p>
</body>
</html>
