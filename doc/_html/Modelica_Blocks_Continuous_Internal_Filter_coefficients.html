<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Blocks.Continuous.Internal.Filter.coefficients</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Blocks.Continuous.Internal.Filter.coefficients</h1>
</div>
<h1 id="modelica.blocks.continuous.internal.filter.coefficients"><a href="Modelica_Blocks_Continuous_Internal_Filter.html#Modelica.Blocks.Continuous.Internal.Filter">Modelica.Blocks.Continuous.Internal.Filter</a>.coefficients</h1>
<p><strong>Filter coefficients</strong></p>
<h2 id="information">Information</h2>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="75%" />
<col width="24%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" alt="image4" /> <a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass">lowPass</a></td>
<td align="left">Return low pass filter coefficients at given cut-off frequency</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" alt="image5" /> <a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass">highPass</a></td>
<td align="left">Return high pass filter coefficients at given cut-off frequency</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" alt="image6" /> <a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass">bandPass</a></td>
<td align="left">Return band pass filter coefficients at given cut-off frequency</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" alt="image7" /> <a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop">bandStop</a></td>
<td align="left">Return band stop filter coefficients at given cut-off frequency</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="modelica.blocks.continuous.internal.filter.coefficients.lowpass"><a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients">Modelica.Blocks.Continuous.Internal.Filter.coefficients</a>.lowPass</h1>
<p><strong>Return low pass filter coefficients at given cut-off frequency</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>::</p>
<h2 id="inputs">Inputs</h2>
<table>
<col width="41%" />
<col width="17%" />
<col width="7%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of real poles</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1_in[size(c0_in, 1)]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">f_cut</td>
<td align="left">
</td>
<td align="left">Cut-off frequency [Hz]</td>
</tr>
</tbody>
</table>
<h2 id="outputs">Outputs</h2>
<table>
<col width="10%" />
<col width="27%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr[size(cr_in, 1)]</td>
<td align="left">Coefficient of real pole</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0[size(c0_in, 1)]</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1[size(c0_in, 1)]</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>function lowPass 
  &quot;Return low pass filter coefficients at given cut-off frequency&quot;

  input Real cr_in[:] &quot;Coefficients of real poles&quot;;
  input Real c0_in[:] &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  input Real c1_in[size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;
  input Modelica.SIunits.Frequency f_cut &quot;Cut-off frequency&quot;;

  output Real cr[size(cr_in,1)] &quot;Coefficient of real pole&quot;;
  output Real c0[size(c0_in,1)] 
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  output Real c1[size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;

protected 
  constant Real pi=Modelica.Constants.pi;
  Modelica.SIunits.AngularVelocity w_cut=2*pi*f_cut &quot;Cut-off angular frequency&quot;;
  Real w_cut2=w_cut*w_cut;

algorithm 
  assert(f_cut &gt; 0, &quot;Cut-off frequency f_cut must be positive&quot;);

  /* Change filter coefficients according to transformation new(s) = s/w_cut
     s + cr           -&gt; (s/w) + cr              = (s + w*cr)/w
     s^2 + c1*s + c0  -&gt; (s/w)^2 + c1*(s/w) + c0 = (s^2 + (c1*w)*s + (c0*w^2))/w^2
  */
  cr := w_cut*cr_in;
  c1 := w_cut*c1_in;
  c0 := w_cut2*c0_in;

end lowPass;</code></pre>
<hr />
<h1 id="modelica.blocks.continuous.internal.filter.coefficients.highpass"><a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients">Modelica.Blocks.Continuous.Internal.Filter.coefficients</a>.highPass</h1>
<p><strong>Return high pass filter coefficients at given cut-off frequency</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>::</p>
<h2 id="inputs-1">Inputs</h2>
<table>
<col width="41%" />
<col width="17%" />
<col width="7%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of real poles</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1_in[size(c0_in, 1)]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">f_cut</td>
<td align="left">
</td>
<td align="left">Cut-off frequency [Hz]</td>
</tr>
</tbody>
</table>
<h2 id="outputs-1">Outputs</h2>
<table>
<col width="10%" />
<col width="27%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr[size(cr_in, 1)]</td>
<td align="left">Coefficient of real pole</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0[size(c0_in, 1)]</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1[size(c0_in, 1)]</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>function highPass 
  &quot;Return high pass filter coefficients at given cut-off frequency&quot;

  input Real cr_in[:] &quot;Coefficients of real poles&quot;;
  input Real c0_in[:] &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  input Real c1_in[size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;
  input Modelica.SIunits.Frequency f_cut &quot;Cut-off frequency&quot;;

  output Real cr[size(cr_in,1)] &quot;Coefficient of real pole&quot;;
  output Real c0[size(c0_in,1)] 
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  output Real c1[size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;

protected 
  constant Real pi=Modelica.Constants.pi;
  Modelica.SIunits.AngularVelocity w_cut=2*pi*f_cut &quot;Cut-off angular frequency&quot;;
  Real w_cut2=w_cut*w_cut;

algorithm 
  assert(f_cut &gt; 0, &quot;Cut-off frequency f_cut must be positive&quot;);

  /* Change filter coefficients according to transformation: new(s) = 1/s
        1/(s + cr)          -&gt; 1/(1/s + cr)                = (1/cr)*s / (s + (1/cr))
        1/(s^2 + c1*s + c0) -&gt; 1/((1/s)^2 + c1*(1/s) + c0) = (1/c0)*s^2 / (s^2 + (c1/c0)*s + 1/c0)

     Check whether transformed roots are also conjugate complex:
        c0 - c1^2/4 &gt; 0  -&gt; (1/c0) - (c1/c0)^2 / 4
                            = (c0 - c1^2/4) / c0^2 &gt; 0
        It is therefore guaranteed that the roots remain conjugate complex

     Change filter coefficients according to transformation new(s) = s/w_cut
        s + 1/cr                -&gt; (s/w) + 1/cr                   = (s + w/cr)/w
        s^2 + (c1/c0)*s + 1/c0  -&gt; (s/w)^2 + (c1/c0)*(s/w) + 1/c0 = (s^2 + (w*c1/c0)*s + (w^2/c0))/w^2
  */
  for i in 1:size(cr_in,1) loop
     cr[i] := w_cut/cr_in[i];
  end for;

  for i in 1:size(c0_in,1) loop
     c0[i] := w_cut2/c0_in[i];
     c1[i] := w_cut*c1_in[i]/c0_in[i];
  end for;

end highPass;</code></pre>
<hr />
<h1 id="modelica.blocks.continuous.internal.filter.coefficients.bandpass"><a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients">Modelica.Blocks.Continuous.Internal.Filter.coefficients</a>.bandPass</h1>
<p><strong>Return band pass filter coefficients at given cut-off frequency</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>::</p>
<h2 id="inputs-2">Inputs</h2>
<table>
<col width="37%" />
<col width="15%" />
<col width="6%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of real poles</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1_in[size(c0_in, 1)]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">f_min</td>
<td align="left">
</td>
<td align="left">Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db) [Hz]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">f_max</td>
<td align="left">
</td>
<td align="left">Upper band frequency [Hz]</td>
</tr>
</tbody>
</table>
<h2 id="outputs-2">Outputs</h2>
<table>
<col width="8%" />
<col width="41%" />
<col width="50%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr[0]</td>
<td align="left">Coefficient of real pole</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0[size(cr_in, 1) + 2*size(c0_in, 1)]</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1[size(cr_in, 1) + 2*size(c0_in, 1)]</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">cn</td>
<td align="left">Numerator coefficient of the PT2 terms</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>function bandPass 
  &quot;Return band pass filter coefficients at given cut-off frequency&quot;

  input Real cr_in[:] &quot;Coefficients of real poles&quot;;
  input Real c0_in[:] &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  input Real c1_in[size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;
  input Modelica.SIunits.Frequency f_min 
    &quot;Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db)&quot;;
  input Modelica.SIunits.Frequency f_max &quot;Upper band frequency&quot;;

  output Real cr[0] &quot;Coefficient of real pole&quot;;
  output Real c0[size(cr_in,1) + 2*size(c0_in,1)] 
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  output Real c1[size(cr_in,1) + 2*size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;
  output Real cn &quot;Numerator coefficient of the PT2 terms&quot;;
protected 
  constant Real pi=Modelica.Constants.pi;
  Modelica.SIunits.Frequency f0 = sqrt(f_min*f_max);
  Modelica.SIunits.AngularVelocity w_cut=2*pi*f0 &quot;Cut-off angular frequency&quot;;
  Modelica.SIunits.AngularVelocity w_band = (f_max - f_min) / f0;
  Real w_cut2=w_cut*w_cut;
  Real c;
  Real alpha;
  Integer j;
algorithm 
  assert(f_min &gt; 0 and f_min &lt; f_max, &quot;Band frequencies f_min and f_max are wrong&quot;);

    /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -&gt; 1/(s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -&gt; 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 / ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -&gt; c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -&gt; equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

     Check whether roots remain conjugate complex
        c0 - (c1/2)^2 &gt; 0:    1/alpha^2 - (c/alpha)^2/4
                              = 1/alpha^2*(1 - c^2/4)    -&gt; not possible to figure this out

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        w_band*s/(s^2 + c1*s + c0)  -&gt; w_band*(s/w)/((s/w)^2 + c1*(s/w) + c0 =
                                       (w_band/w)*s/(s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                       (w_band*w)*s/(s^2 + (c1*w)*s + (c0*w^2))
    */
    for i in 1:size(cr_in,1) loop
       c1[i] := w_cut*cr_in[i]*w_band;
       c0[i] := w_cut2;
    end for;

    for i in 1:size(c1_in,1) loop
      alpha :=
        Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(
              c1_in[i],
              c0_in[i],
              w_band);
       c       := c1_in[i]*w_band / (alpha + 1/alpha);
       j       := size(cr_in,1) + 2*i - 1;
       c1[j]   := w_cut*c/alpha;
       c1[j+1] := w_cut*c*alpha;
       c0[j]   := w_cut2/alpha^2;
       c0[j+1] := w_cut2*alpha^2;
    end for;

    cn :=w_band*w_cut;

end bandPass;</code></pre>
<hr />
<h1 id="modelica.blocks.continuous.internal.filter.coefficients.bandstop"><a href="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients">Modelica.Blocks.Continuous.Internal.Filter.coefficients</a>.bandStop</h1>
<p><strong>Return band stop filter coefficients at given cut-off frequency</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>::</p>
<h2 id="inputs-3">Inputs</h2>
<table>
<col width="37%" />
<col width="15%" />
<col width="6%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of real poles</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0_in[:]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1_in[size(c0_in, 1)]</td>
<td align="left">
</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">f_min</td>
<td align="left">
</td>
<td align="left">Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db) [Hz]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Frequency">Frequency</a></td>
<td align="left">f_max</td>
<td align="left">
</td>
<td align="left">Upper band frequency [Hz]</td>
</tr>
</tbody>
</table>
<h2 id="outputs-3">Outputs</h2>
<table>
<col width="8%" />
<col width="41%" />
<col width="50%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">cr[0]</td>
<td align="left">Coefficient of real pole</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">c0[size(cr_in, 1) + 2*size(c0_in, 1)]</td>
<td align="left">Coefficients of s^0 term if conjugate complex pole</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">c1[size(cr_in, 1) + 2*size(c0_in, 1)]</td>
<td align="left">Coefficients of s^1 term if conjugate complex pole</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>function bandStop 
  &quot;Return band stop filter coefficients at given cut-off frequency&quot;

  input Real cr_in[:] &quot;Coefficients of real poles&quot;;
  input Real c0_in[:] &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  input Real c1_in[size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;
  input Modelica.SIunits.Frequency f_min 
    &quot;Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db)&quot;;
  input Modelica.SIunits.Frequency f_max &quot;Upper band frequency&quot;;

  output Real cr[0] &quot;Coefficient of real pole&quot;;
  output Real c0[size(cr_in,1) + 2*size(c0_in,1)] 
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;;
  output Real c1[size(cr_in,1) + 2*size(c0_in,1)] 
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;;
protected 
  constant Real pi=Modelica.Constants.pi;
  Modelica.SIunits.Frequency f0 = sqrt(f_min*f_max);
  Modelica.SIunits.AngularVelocity w_cut=2*pi*f0 &quot;Cut-off angular frequency&quot;;
  Modelica.SIunits.AngularVelocity w_band = (f_max - f_min) / f0;
  Real w_cut2=w_cut*w_cut;
  Real c;
  Real ww;
  Real alpha;
  Integer j;
algorithm 
  assert(f_min &gt; 0 and f_min &lt; f_max, &quot;Band frequencies f_min and f_max are wrong&quot;);

    /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -&gt; 1/(s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -&gt; 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 / ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -&gt; c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -&gt; equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

       The band stop filter is derived from the low pass filter by
       the transformation new(s) = w/( (s + 1/s) )   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       cr/(s + cr)         -&gt; 1/( w/(s + 1/s) ) + cr)
                              = (s^2 + 1) / (s^2 + (w/cr)*s + 1)

       c0/(s^2 + c1*s + c0) -&gt; c0/( w^2/(s + 1/s)^2 + c1*w/(s + 1/s) + c0 )
                               = c0*(s^2 + 1)^2 / (s^4 + c1*w*s^3/c0 + (2+w^2/b)*s^2 + c1*w*s/c0 + 1)

                               Assume the following description with PT2:
                               = c0*(s^2 + 1)^2 / ( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                                    (s^2 + s*(c*alpha) + alpha^2) )
                               = c0*(s^2 + 1)^2 / (  s^4 + c*(alpha + 1/alpha)*s^3
                                                         + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                         + c*(alpha + 1/alpha)*p + 1 )

                            and therefore:
                              c*(alpha + 1/alpha) = c1*w/b         -&gt; c = c1*w/(c0*(alpha + 1/alpha))
                              alpha^2 + 1/alpha^2 + c^2 = 2+w^2/c0 -&gt; equation to determine alpha
                              alpha^4 + 1 + (c1*w/c0*alpha^2)^2/(1+alpha^2)^2 = (2+w^2/c0)*alpha^2
                              or z = alpha^2
                              z^2 + (c1*w/c0*z)^2/(1+z)^2 - (2+w^2/c0)*z + 1 = 0

                            same as:  ww = w/c0
                              z^2 + (c1*ww*z)^2/(1+z)^2 - (2+c0*ww)*z + 1 = 0  -&gt; same equation as for BandPass

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        c0*(s^2+1)(s^2 + c1*s + c0)  -&gt; c0*((s/w)^2 + 1) / ((s/w)^2 + c1*(s/w) + c0 =
                                        c0/w^2*(s^2 + w^2) / (s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                        (s^2 + c0*w^2) / (s^2 + (c1*w)*s + (c0*w^2))
    */
    for i in 1:size(cr_in,1) loop
       c1[i] := w_cut*w_band/cr_in[i];
       c0[i] := w_cut2;
    end for;

    for i in 1:size(c1_in,1) loop
       ww      := w_band/c0_in[i];
      alpha :=
        Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(
              c1_in[i],
              c0_in[i],
              ww);
       c       := c1_in[i]*ww / (alpha + 1/alpha);
       j       := size(cr_in,1) + 2*i - 1;
       c1[j]   := w_cut*c/alpha;
       c1[j+1] := w_cut*c*alpha;
       c0[j]   := w_cut2/alpha^2;
       c0[j+1] := w_cut2*alpha^2;
    end for;

end bandStop;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:27:36 2010.</p>
</body>
</html>
