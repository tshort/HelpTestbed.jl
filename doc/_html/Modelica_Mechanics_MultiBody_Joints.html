<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Mechanics.MultiBody.Joints</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Mechanics.MultiBody.Joints</h1>
</div>
<h1 id="modelica.mechanics.multibody.joints"><a href="Modelica_Mechanics_MultiBody.html#Modelica.Mechanics.MultiBody">Modelica.Mechanics.MultiBody</a>.Joints</h1>
<p><strong>Components that constrain the motion between two frames</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>This package contains <strong>joint components</strong>, that is, idealized, massless elements that constrain the motion between frames. In subpackage <strong>Assemblies</strong> aggregation joint components are provided to handle kinematic loops analytically (this means that non-linear systems of equations occuring in these joint aggregations are analytically solved, i.e., robustly and efficiently).</p>
<h3 id="content">Content</h3>
<p><strong><em>Model</em></strong></p>
<p><strong><em>Description</em></strong></p>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Prismatic">Prismatic</a></p>
<p>Prismatic joint and actuated prismatic joint (1 translational degree-of-freedom, 2 potential states) <img src="../Resources/Images/MultiBody/Joints/Prismatic.png" alt="image0" /></p>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Revolute">Revolute</a></p>
<p>Revolute and actuated revolute joint (1 rotational degree-of-freedom, 2 potential states) <img src="../Resources/Images/MultiBody/Joints/Revolute.png" alt="image1" /></p>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Cylindrical">Cylindrical</a></p>
<dl>
<dt>Cylindrical joint (2 degrees-of-freedom, 4 potential states)</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Joints/Cylindrical.png" alt="image2" /><p class="caption">image2</p>
</div>
</dd>
</dl>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Universal">Universal</a></p>
<dl>
<dt>Universal joint (2 degrees-of-freedom, 4 potential states)</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Joints/Universal.png" alt="image3" /><p class="caption">image3</p>
</div>
</dd>
</dl>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Planar">Planar</a></p>
<dl>
<dt>Planar joint (3 degrees-of-freedom, 6 potential states)</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Joints/Planar.png" alt="image4" /><p class="caption">image4</p>
</div>
</dd>
</dl>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Spherical">Spherical</a></p>
<p>Spherical joint (3 constraints and no potential states, or 3 degrees-of-freedom and 3 states) <img src="../Resources/Images/MultiBody/Joints/Spherical.png" alt="image5" /></p>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.FreeMotion">FreeMotion</a></p>
<dl>
<dt>Free motion joint (6 degrees-of-freedom, 12 potential states)</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Joints/FreeMotion.png" alt="image6" /><p class="caption">image6</p>
</div>
</dd>
</dl>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.SphericalSpherical">SphericalSpherical</a></p>
<p>Spherical - spherical joint aggregation (1 constraint, no potential states) with an optional point mass in the middle <img src="../Resources/Images/MultiBody/Joints/SphericalSpherical.png" alt="image7" /></p>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.UniversalSpherical">UniversalSpherical</a></p>
<p>Universal - spherical joint aggregation (1 constraint, no potential states) <img src="../Resources/Images/MultiBody/Joints/UniversalSpherical.png" alt="image8" /></p>
<p><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.GearConstraint">GearConstraint</a></p>
<p>Ideal 3-dim. gearbox (arbitrary shaft directions)</p>
<p><a href="Modelica_Mechanics_MultiBody_Joints_Assemblies.html#Modelica.Mechanics.MultiBody.Joints.Assemblies">MultiBody.Joints.Assemblies</a></p>
<p><strong>Package</strong> of joint aggregations for analytic loop handling.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="51%" />
<col width="48%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.PrismaticS.png" alt="image25" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Prismatic">Prismatic</a></td>
<td align="left">Prismatic joint (1 translational degree-of-freedom, 2 potential states, optional axis flange)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.RevoluteS.png" alt="image26" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Revolute">Revolute</a></td>
<td align="left">Revolute joint (1 rotational degree-of-freedom, 2 potential states, optional axis flange)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.RevolutePlanarLoopConstraintS.png" alt="image27" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.RevolutePlanarLoopConstraint">RevolutePlanarLoopConstraint</a></td>
<td align="left">Revolute joint that is described by 2 positional constraints for usage in a planar loop (the ambiguous cut-force perpendicular to the loop and the ambiguous cut-torques are set arbitrarily to zero)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.CylindricalS.png" alt="image28" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Cylindrical">Cylindrical</a></td>
<td align="left">Cylindrical joint (2 degrees-of-freedom, 4 potential states)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.UniversalS.png" alt="image29" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Universal">Universal</a></td>
<td align="left">Universal joint (2 degrees-of-freedom, 4 potential states)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.PlanarS.png" alt="image30" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Planar">Planar</a></td>
<td align="left">Planar joint (3 degrees-of-freedom, 6 potential states)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.SphericalS.png" alt="image31" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.Spherical">Spherical</a></td>
<td align="left">Spherical joint (3 constraints and no potential states, or 3 degrees-of-freedom and 3 states)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.FreeMotionS.png" alt="image32" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.FreeMotion">FreeMotion</a></td>
<td align="left">Free motion joint (6 degrees-of-freedom, 12 potential states)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.FreeMotionS.png" alt="image33" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.FreeMotionScalarInit">FreeMotionScalarInit</a></td>
<td align="left">Free motion joint with scalar initialization and state selection (6 degrees-of-freedom, 12 potential states)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.SphericalSphericalS.png" alt="image34" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.SphericalSpherical">SphericalSpherical</a></td>
<td align="left">Spherical - spherical joint aggregation (1 constraint, no potential states) with an optional point mass in the middle</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.UniversalSphericalS.png" alt="image35" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.UniversalSpherical">UniversalSpherical</a></td>
<td align="left">Universal - spherical joint aggregation (1 constraint, no potential states)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.GearConstraintS.png" alt="image36" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.GearConstraint">GearConstraint</a></td>
<td align="left">Ideal 3-dim. gearbox (arbitrary shaft directions)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.RollingWheelS.png" alt="image37" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.RollingWheel">RollingWheel</a></td>
<td align="left">Joint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane z=0)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.RollingWheelSetS.png" alt="image38" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.RollingWheelSet">RollingWheelSet</a></td>
<td align="left">Joint (no mass, no inertia) that describes an ideal rolling wheel set (two ideal rolling wheels connected together by an axis)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.AssembliesS.png" alt="image39" /> <a href="Modelica_Mechanics_MultiBody_Joints_Assemblies.html#Modelica.Mechanics.MultiBody.Joints.Assemblies">Assemblies</a></td>
<td align="left">Joint aggregations for analytic loop handling</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Joints.AssembliesS.png" alt="image40" /> <a href="Modelica_Mechanics_MultiBody_Joints_Internal.html#Modelica.Mechanics.MultiBody.Joints.Internal">Internal</a></td>
<td align="left">Components used for analytic solution of kinematic loops (use only if you know what you are doing)</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image41-modelica.mechanics.multibody.joints.prismatic"><img src="Modelica.Mechanics.MultiBody.Joints.PrismaticI.png" alt="image41" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.Prismatic</h1>
<p><strong>Prismatic joint (1 translational degree-of-freedom, 2 potential states, optional axis flange)</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>Joint where frame_b is translated along axis n which is fixed in frame_a. The two frames coincide when the relative distance &quot;s = 0&quot;.</p>
<p>Optionally, two additional 1-dimensional mechanical flanges (flange &quot;axis&quot; represents the driving flange and flange &quot;support&quot; represents the bearing) can be enabled via parameter <strong>useAxisFlange</strong>. The enabled axis flange can be driven with elements of the <a href="Modelica_Mechanics_Translational.html#Modelica.Mechanics.Translational">Modelica.Mechanics.Translational</a> library.</p>
<p>In the &quot;Advanced&quot; menu it can be defined via parameter <strong>stateSelect</strong> that the relative distance &quot;s&quot; and its derivative shall be definitely used as states by setting stateSelect=StateSelect.always. Default is StateSelect.prefer to use the relative distance and its derivative as preferred states. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the StateSelect.always setting.</p>
<p>In the following figure the animation of a prismatic joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint. The black arrow is parameter vector &quot;n&quot; defining the translation axis (here: n = {1,1,0}).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialElementaryJoint">Modelica.Mechanics.MultiBody.Interfaces.PartialElementaryJoint</a> (Base model for elementary joints (has two frames + outer world + assert to guarantee that the joint is connected)).</p>
<h2 id="parameters">Parameters</h2>
<table>
<col width="48%" />
<col width="9%" />
<col width="14%" />
<col width="28%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useAxisFlange</td>
<td align="left">false</td>
<td align="left">= true, if axis flange is enabled</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of translation resolved in frame_a (= same as in frame_b) [1]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">boxWidthDirection</td>
<td align="left">{0,1,0}</td>
<td align="left">Vector in width direction of box, resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">boxWidth</td>
<td align="left">world.defaultJointWidth</td>
<td align="left">Width of prismatic joint box [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">boxHeight</td>
<td align="left">boxWidth</td>
<td align="left">Height of prismatic joint box [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">boxColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of prismatic joint box</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use distance s and v=der(s) as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors">Connectors</h2>
<table>
<col width="48%" />
<col width="5%" />
<col width="46%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the joint with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the joint with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">axis</td>
<td align="left">1-dim. translational flange that drives the joint</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Translational_Interfaces.html#Modelica.Mechanics.Translational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">support</td>
<td align="left">1-dim. translational flange of the drive drive support (assumed to be fixed in the world frame, NOT in the joint)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>model Prismatic 
  &quot;Prismatic joint (1 translational degree-of-freedom, 2 potential states, optional axis flange)&quot;

  import SI = Modelica.SIunits;
  extends Modelica.Mechanics.MultiBody.Interfaces.PartialElementaryJoint;
  Modelica.Mechanics.Translational.Interfaces.Flange_a axis if useAxisFlange 
    &quot;1-dim. translational flange that drives the joint&quot;;
  Modelica.Mechanics.Translational.Interfaces.Flange_b support if useAxisFlange 
    &quot;1-dim. translational flange of the drive drive support (assumed to be fixed in the world frame, NOT in the joint)&quot;;


  parameter Boolean useAxisFlange=false &quot;= true, if axis flange is enabled&quot;;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n={1,0,0} 
    &quot;Axis of translation resolved in frame_a (= same as in frame_b)&quot;;
  constant SI.Position s_offset=0 
    &quot;Relative distance offset (distance between frame_a and frame_b = s_offset + s)&quot;;
  parameter Types.Axis boxWidthDirection={0,1,0} 
    &quot;Vector in width direction of box, resolved in frame_a&quot;;
  parameter SI.Distance boxWidth=world.defaultJointWidth 
    &quot;Width of prismatic joint box&quot;;
  parameter SI.Distance boxHeight=boxWidth &quot;Height of prismatic joint box&quot;;
  input Types.Color boxColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of prismatic joint box&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.prefer 
    &quot;Priority to use distance s and v=der(s) as states&quot;;
  final parameter Real e[3](each final unit=&quot;1&quot;)=
     Modelica.Math.Vectors.normalize(n,0.0) 
    &quot;Unit vector in direction of prismatic axis n&quot;;

  SI.Position s(start=0, final stateSelect=stateSelect) 
    &quot;Relative distance between frame_a and frame_b&quot;;

  SI.Velocity v(start=0,final stateSelect=stateSelect) 
    &quot;First derivative of s (relative velocity)&quot;;
  SI.Acceleration a(start=0) &quot;Second derivative of s (relative acceleration)&quot;;
  SI.Force f &quot;Actuation force in direction of joint axis&quot;;

protected 
  Visualizers.Advanced.Shape box(
    shapeType=&quot;box&quot;,
    color=boxColor,
    specularCoefficient=specularCoefficient,
    length=if noEvent(abs(s + s_offset) &gt; 1.e-6) then s + s_offset else 1.e-6,
    width=boxWidth,
    height=boxHeight,
    lengthDirection=e,
    widthDirection=boxWidthDirection,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
  Translational.Components.Fixed fixed;
  Translational.Interfaces.InternalSupport internalAxis(f = f);
  Translational.Sources.ConstantForce constantForce(f_constant=0) if not useAxisFlange;
equation 
  v = der(s);
  a = der(v);

  // relationships between kinematic quantities of frame_a and of frame_b
  frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, e*(s_offset + s));
  frame_b.R = frame_a.R;

  // Force and torque balance
  zeros(3) = frame_a.f + frame_b.f;
  zeros(3) = frame_a.t + frame_b.t + cross(e*(s_offset + s), frame_b.f);

  // d&#39;Alemberts principle
  f = -e*frame_b.f;

  // Connection to internal connectors
  s = internalAxis.s;

  connect(fixed.flange, support);
  connect(internalAxis.flange, axis);
  connect(constantForce.flange, internalAxis.flange);
end Prismatic;</code></pre>
<hr />
<h1 id="image42-modelica.mechanics.multibody.joints.revolute"><img src="Modelica.Mechanics.MultiBody.Joints.RevoluteI.png" alt="image42" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.Revolute</h1>
<p><strong>Revolute joint (1 rotational degree-of-freedom, 2 potential states, optional axis flange)</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>Joint where frame_b rotates around axis n which is fixed in frame_a. The two frames coincide when the rotation angle &quot;phi = 0&quot;.</p>
<p>Optionally, two additional 1-dimensional mechanical flanges (flange &quot;axis&quot; represents the driving flange and flange &quot;support&quot; represents the bearing) can be enabled via parameter <strong>useAxisFlange</strong>. The enabled axis flange can be driven with elements of the <a href="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational">Modelica.Mechanics.Rotational</a> library.</p>
<p>In the &quot;Advanced&quot; menu it can be defined via parameter <strong>stateSelect</strong> that the rotation angle &quot;phi&quot; and its derivative shall be definitely used as states by setting stateSelect=StateSelect.always. Default is StateSelect.prefer to use the joint angle and its derivative as preferred states. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the StateSelect.always setting.</p>
<p>If a <strong>planar loop</strong> is present, e.g., consisting of 4 revolute joints where the joint axes are all parallel to each other, then there is no longer a unique mathematical solution and the symbolic algorithms will fail. Usually, an error message will be printed pointing out this situation. In this case, one revolute joint of the loop has to be replaced by a Joints.RevolutePlanarLoopConstraint joint. The effect is that from the 5 constraints of a usual revolute joint, 3 constraints are removed and replaced by appropriate known variables (e.g., the force in the direction of the axis of rotation is treated as known with value equal to zero; for standard revolute joints, this force is an unknown quantity).</p>
<p>In the following figure the animation of a revolute joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint. The black arrow is parameter vector &quot;n&quot; defining the translation axis (here: n = {0,0,1}, phi.start = 45<sup>o</sup>).</p>
<p>::</p>
<h2 id="parameters-1">Parameters</h2>
<table>
<col width="48%" />
<col width="9%" />
<col width="14%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useAxisFlange</td>
<td align="left">false</td>
<td align="left">= true, if axis flange is enabled</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show axis as cylinder)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{0,0,1}</td>
<td align="left">Axis of rotation resolved in frame_a (= same as in frame_b) [1]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderLength</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Length of cylinder representing the joint axis [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">world.defaultJointWidth</td>
<td align="left">Diameter of cylinder representing the joint axis [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinder representing the joint axis</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use joint angle phi and w=der(phi) as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-1">Connectors</h2>
<table>
<col width="48%" />
<col width="5%" />
<col width="45%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">axis</td>
<td align="left">1-dim. rotational flange that drives the joint</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">support</td>
<td align="left">1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the joint with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the joint with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>model Revolute 
  &quot;Revolute joint (1 rotational degree-of-freedom, 2 potential states, optional axis flange)&quot;

  import SI = Modelica.SIunits;

  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis if useAxisFlange 
    &quot;1-dim. rotational flange that drives the joint&quot;;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b support if useAxisFlange 
    &quot;1-dim. rotational flange of the drive support (assumed to be fixed in the world frame, NOT in the joint)&quot;;


  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed to the joint with one cut-force and cut-torque&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b 
    &quot;Coordinate system fixed to the joint with one cut-force and cut-torque&quot;;

  parameter Boolean useAxisFlange=false &quot;= true, if axis flange is enabled&quot;;
  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show axis as cylinder)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n={0,0,1} 
    &quot;Axis of rotation resolved in frame_a (= same as in frame_b)&quot;;
  constant SI.Angle phi_offset=0 
    &quot;Relative angle offset (angle = phi_offset + phi)&quot;;
  parameter SI.Distance cylinderLength=world.defaultJointLength 
    &quot;Length of cylinder representing the joint axis&quot;;
  parameter SI.Distance cylinderDiameter=world.defaultJointWidth 
    &quot;Diameter of cylinder representing the joint axis&quot;;
  input Modelica.Mechanics.MultiBody.Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of cylinder representing the joint axis&quot;;
  input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient
    specularCoefficient =                                                            world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.prefer 
    &quot;Priority to use joint angle phi and w=der(phi) as states&quot;;

  SI.Angle phi(start=0, final stateSelect=stateSelect) 
    &quot;Relative rotation angle from frame_a to frame_b&quot;;
  SI.AngularVelocity w(start=0, stateSelect=stateSelect) 
    &quot;First derivative of angle phi (relative angular velocity)&quot;;
  SI.AngularAcceleration a(start=0) 
    &quot;Second derivative of angle phi (relative angular acceleration)&quot;;
  SI.Torque tau &quot;Driving torque in direction of axis of rotation&quot;;
  SI.Angle angle &quot;= phi_offset + phi&quot;;

protected 
  outer Modelica.Mechanics.MultiBody.World world;
  parameter Real e[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                       n,0.0) 
    &quot;Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)&quot;;
  Frames.Orientation R_rel 
    &quot;Relative orientation object from frame_a to frame_b or from frame_b to frame_a&quot;;
  Visualizers.Advanced.Shape cylinder(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=cylinderLength,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=e,
    widthDirection={0,1,0},
    r_shape=-e*(cylinderLength/2),
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;

protected 
  Modelica.Mechanics.Rotational.Components.Fixed fixed 
    &quot;support flange is fixed to ground&quot;;
  Rotational.Interfaces.InternalSupport internalAxis(tau=tau);
  Rotational.Sources.ConstantTorque constantTorque(tau_constant=0) if not useAxisFlange;
equation 
  Connections.branch(frame_a.R, frame_b.R);

  assert(cardinality(frame_a) &gt; 0,
    &quot;Connector frame_a of revolute joint is not connected&quot;);
  assert(cardinality(frame_b) &gt; 0,
    &quot;Connector frame_b of revolute joint is not connected&quot;);

  angle = phi_offset + phi;
  w = der(phi);
  a = der(w);

  // relationships between quantities of frame_a and of frame_b
  frame_b.r_0 = frame_a.r_0;

  if rooted(frame_a.R) then
    R_rel = Frames.planarRotation(e, phi_offset + phi, w);
    frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
    frame_a.f = -Frames.resolve1(R_rel, frame_b.f);
    frame_a.t = -Frames.resolve1(R_rel, frame_b.t);
  else
    R_rel = Frames.planarRotation(-e, phi_offset + phi, w);
    frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel);
    frame_b.f = -Frames.resolve1(R_rel, frame_a.f);
    frame_b.t = -Frames.resolve1(R_rel, frame_a.t);
  end if;

  // d&#39;Alemberts principle
  tau = -frame_b.t*e;

  // Connection to internal connectors
  phi = internalAxis.phi;

  connect(fixed.flange, support);
  connect(internalAxis.flange, axis);
  connect(constantTorque.flange, internalAxis.flange);
end Revolute;</code></pre>
<hr />
<h1 id="image43-modelica.mechanics.multibody.joints.revoluteplanarloopconstraint"><img src="Modelica.Mechanics.MultiBody.Joints.RevolutePlanarLoopConstraintI.png" alt="image43" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.RevolutePlanarLoopConstraint</h1>
<p><strong>Revolute joint that is described by 2 positional constraints for usage in a planar loop (the ambiguous cut-force perpendicular to the loop and the ambiguous cut-torques are set arbitrarily to zero)</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>Joint where frame_b rotates around axis n which is fixed in frame_a and where this joint is used in a planar loop providing 2 constraint equations on position level.</p>
<p>If a <strong>planar loop</strong> is present, e.g., consisting of 4 revolute joints where the joint axes are all parallel to each other, then there is no unique mathematical solution if all revolute joints are modelled with Joints.Revolute and the symbolic algorithms will fail. The reason is that, e.g., the cut-forces in the revolute joints perpendicular to the planar loop are not uniquely defined when 3-dim. descriptions of revolute joints are used. Usually, an error message will be printed pointing out this situation. In this case, <strong>one</strong> revolute joint in the loop has to be replaced by model Joints.RevolutePlanarLoopCutJoint. The effect is that from the 5 constraints of a 3-dim. revolute joint, 3 constraints are removed and replaced by appropriate known variables (e.g., the force in the direction of the axis of rotation is treated as known with value equal to zero; for standard revolute joints, this force is an unknown quantity).</p>
<p>::</p>
<h2 id="parameters-2">Parameters</h2>
<table>
<col width="48%" />
<col width="9%" />
<col width="14%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show axis as cylinder)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{0,0,1}</td>
<td align="left">Axis of rotation resolved in frame_a (= same as in frame_b) [1]</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderLength</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Length of cylinder representing the joint axis [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">world.defaultJointWidth</td>
<td align="left">Diameter of cylinder representing the joint axis [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinder representing the joint axis</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-2">Connectors</h2>
<table>
<col width="55%" />
<col width="6%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the joint with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the joint with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>model RevolutePlanarLoopConstraint 
  &quot;Revolute joint that is described by 2 positional constraints for usage in a planar loop (the ambiguous cut-force perpendicular to the loop and the ambiguous cut-torques are set arbitrarily to zero)&quot;

  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;
  import T = Modelica.Mechanics.MultiBody.Frames.TransformationMatrices;
  import Modelica.Mechanics.MultiBody.Types;

  Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed to the joint with one cut-force and cut-torque&quot;;
  Interfaces.Frame_b frame_b 
    &quot;Coordinate system fixed to the joint with one cut-force and cut-torque&quot;;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show axis as cylinder)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n={0,0,1} 
    &quot;Axis of rotation resolved in frame_a (= same as in frame_b)&quot;;
  parameter SI.Distance cylinderLength=world.defaultJointLength 
    &quot;Length of cylinder representing the joint axis&quot;;
  parameter SI.Distance cylinderDiameter=world.defaultJointWidth 
    &quot;Diameter of cylinder representing the joint axis&quot;;
  input Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of cylinder representing the joint axis&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
protected 
  outer Modelica.Mechanics.MultiBody.World world;
  parameter Real e[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                       n,0.0) 
    &quot;Unit vector in direction of rotation axis, resolved in frame_a (= same as in frame_b)&quot;;
  parameter Real nnx_a[3](each final unit=&quot;1&quot;)=if abs(e[1]) &gt; 0.1 then {0,1,0} else (if abs(e[2])
       &gt; 0.1 then {0,0,1} else {1,0,0}) 
    &quot;Arbitrary vector that is not aligned with rotation axis n&quot;;
  parameter Real ey_a[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                          cross(e, nnx_a),0.0) 
    &quot;Unit vector orthogonal to axis n of revolute joint, resolved in frame_a&quot;;
  parameter Real ex_a[3](each final unit=&quot;1&quot;)=cross(ey_a, e) 
    &quot;Unit vector orthogonal to axis n of revolute joint and to ey_a, resolved in frame_a&quot;;
  Real ey_b[3](each final unit=&quot;1&quot;) &quot;ey_a, resolved in frame_b&quot;;
  Real ex_b[3](each final unit=&quot;1&quot;) &quot;ex_a, resolved in frame_b&quot;;
  Frames.Orientation R_rel 
    &quot;Dummy or relative orientation object from frame_a to frame_b&quot;;
  Modelica.SIunits.Position r_rel_a[3] 
    &quot;Position vector from origin of frame_a to origin of frame_b, resolved in frame_a&quot;;
  SI.Force f_c[2] &quot;Dummy or constraint forces in direction of ex_a, ey_a&quot;;

  Visualizers.Advanced.Shape cylinder(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=cylinderLength,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=e,
    widthDirection={0,1,0},
    r_shape=-e*(cylinderLength/2),
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
equation 
  assert(cardinality(frame_a) &gt; 0,
    &quot;Connector frame_a of revolute joint is not connected&quot;);
  assert(cardinality(frame_b) &gt; 0,
    &quot;Connector frame_b of revolute joint is not connected&quot;);

  // Determine relative position vector resolved in frame_a
  R_rel = Frames.relativeRotation(frame_a.R, frame_b.R);
  r_rel_a = Frames.resolve2(frame_a.R, frame_b.r_0 - frame_a.r_0);
  // r_rel_a = T.resolve1(R_rel.T, T.resolve2(frame_b.R.T, frame_b.r_0 - frame_a.r_0));

  // Constraint equations
  0 = ex_a*r_rel_a;
  0 = ey_a*r_rel_a;

  /* Transform forces and torques
     (the torques are assumed to be zero by the assumption
      of a planar joint)
  */
  frame_a.t = zeros(3);
  frame_b.t = zeros(3);

  frame_a.f = [ex_a, ey_a]*f_c;
  frame_b.f = -Frames.resolve2(R_rel, frame_a.f);

  // check that revolute joint is used in planar loop
  ex_b = Frames.resolve2(R_rel, ex_a);
  ey_b = Frames.resolve2(R_rel, ey_a);
  assert(noEvent(abs(e*r_rel_a) &lt;= 1.e-10 and abs(e*ex_b) &lt;= 1.e-10 and 
      abs(e*ey_b) &lt;= 1.e-10), &quot;
The MultiBody.Joints.RevolutePlanarLoopConstraint joint is used as cut-joint of a
planar loop. However, the revolute joint is not part of a planar loop where the
axis of the revolute joint (parameter n) is orthogonal to the possible movements.
Either use instead joint MultiBody.Joints.Revolute or correct the
definition of the axes vectors n in the revolute joints of the planar loop.
&quot;);
end RevolutePlanarLoopConstraint;</code></pre>
<hr />
<h1 id="image44-modelica.mechanics.multibody.joints.cylindrical"><img src="Modelica.Mechanics.MultiBody.Joints.CylindricalI.png" alt="image44" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.Cylindrical</h1>
<p><strong>Cylindrical joint (2 degrees-of-freedom, 4 potential states)</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p>Joint where frame_b rotates around and translates along axis n which is fixed in frame_a. The two frames coincide when &quot;phi=revolute.phi=0&quot; and &quot;s=prismatic.s=0&quot;. This joint has the following potential states;</p>
<ul>
<li>The relative angle phi [rad] around axis n,</li>
<li>the relative distance s [m] along axis n,</li>
<li>the relative angular velocity w [rad/s] (= der(phi)) and</li>
<li>the relative velocity v [m/s] (= der(s)).</li>
</ul>
<p>They are used as candidates for automatic selection of states from the tool. This may be enforced by setting &quot;stateSelect=StateSelect.<strong>always</strong>&quot; in the <strong>Advanced</strong> menu. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the &quot;StateSelect.always&quot; setting.</p>
<p>In the following figure the animation of a cylindrical joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint. The black arrow is parameter vector &quot;n&quot; defining the cylinder axis (here: n = {0,0,1}).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-3">Parameters</h2>
<table>
<col width="49%" />
<col width="9%" />
<col width="14%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show cylinder)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{1,0,0}</td>
<td align="left">Cylinder axis resolved in frame_a (= same as in frame_b) [1]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">world.defaultJointWidth</td>
<td align="left">Diameter of cylinder [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinder</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use joint coordinates (phi, s, w, v) as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-3">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>model Cylindrical 
  &quot;Cylindrical joint (2 degrees-of-freedom, 4 potential states)&quot;
  import SI = Modelica.SIunits;
  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show cylinder)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n={1,0,0} 
    &quot;Cylinder axis resolved in frame_a (= same as in frame_b)&quot;;
  parameter SI.Distance cylinderDiameter=world.defaultJointWidth 
    &quot;Diameter of cylinder&quot;;
  input Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of cylinder&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.prefer 
    &quot;Priority to use joint coordinates (phi, s, w, v) as states&quot;;

  Prismatic prismatic(
    n=n,
    animation=false,
    stateSelect=StateSelect.never);
  Revolute revolute(
    n=n,
    animation=false,
    stateSelect=StateSelect.never);

  SI.Position s(start=0, stateSelect=stateSelect) 
    &quot;Relative distance between frame_a and frame_b&quot;;
  SI.Angle phi(start=0, stateSelect=stateSelect) 
    &quot;Relative rotation angle from frame_a to frame_b&quot;;
  SI.Velocity v(start=0, stateSelect=stateSelect) 
    &quot;First derivative of s (relative velocity)&quot;;
  SI.AngularVelocity w(start=0, stateSelect=stateSelect) 
    &quot;First derivative of angle phi (relative angular velocity)&quot;;
  SI.Acceleration a(start=0) &quot;Second derivative of s (relative acceleration)&quot;;
  SI.AngularAcceleration wd(start=0) 
    &quot;Second derivative of angle phi (relative angular acceleration)&quot;;

protected 
  Visualizers.Advanced.Shape cylinder(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=prismatic.s,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=prismatic.n,
    widthDirection={0,1,0},
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
equation 
  phi = revolute.phi;
  w = der(phi);
  wd = der(w);
  s = prismatic.s;
  v = der(s);
  a = der(v);
  connect(frame_a, prismatic.frame_a);
  connect(prismatic.frame_b, revolute.frame_a);
  connect(revolute.frame_b, frame_b);
end Cylindrical;</code></pre>
<hr />
<h1 id="image45-modelica.mechanics.multibody.joints.universal"><img src="Modelica.Mechanics.MultiBody.Joints.UniversalI.png" alt="image45" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.Universal</h1>
<p><strong>Universal joint (2 degrees-of-freedom, 4 potential states)</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p>Joint where frame_a rotates around axis n_a which is fixed in frame_a and frame_b rotates around axis n_b which is fixed in frame_b. The two frames coincide when &quot;revolute_a.phi=0&quot; and &quot;revolute_b.phi=0&quot;. This joint has the following potential states;</p>
<ul>
<li>The relative angle phi_a = revolute_a.phi [rad] around axis n_a,</li>
<li>the relative angle phi_b = revolute_b.phi [rad] around axis n_b,</li>
<li>the relative angular velocity w_a (= der(phi_a)) and</li>
<li>the relative angular velocity w_b (= der(phi_b)).</li>
</ul>
<p>They are used as candidates for automatic selection of states from the tool. This may be enforced by setting &quot;stateSelect=StateSelect.<strong>always</strong>&quot; in the <strong>Advanced</strong> menu. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the &quot;StateSelect.always&quot; setting.</p>
<p>In the following figure the animation of a universal joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint (here: n_a = {0,0,1}, n_b = {0,1,0}, phi_a.start = 90<sup>o</sup>, phi_b.start = 45<sup>o</sup>).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-4">Parameters</h2>
<table>
<col width="47%" />
<col width="9%" />
<col width="13%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_a</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of revolute joint 1 resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_b</td>
<td align="left">{0,1,0}</td>
<td align="left">Axis of revolute joint 2 resolved in frame_b [1]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderLength</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Length of cylinders representing the joint axes [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">world.defaultJointWidth</td>
<td align="left">Diameter of cylinders representing the joint axes [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinders representing the joint axes</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use joint coordinates (phi_a, phi_b, w_a, w_b) as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-4">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>model Universal 
  &quot;Universal joint (2 degrees-of-freedom, 4 potential states)&quot;
  import SI = Modelica.SIunits;

  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n_a={1,0,0} 
    &quot;Axis of revolute joint 1 resolved in frame_a&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n_b={0,1,0} 
    &quot;Axis of revolute joint 2 resolved in frame_b&quot;;

  parameter SI.Distance cylinderLength=world.defaultJointLength 
    &quot;Length of cylinders representing the joint axes&quot;;
  parameter SI.Distance cylinderDiameter=world.defaultJointWidth 
    &quot;Diameter of cylinders representing the joint axes&quot;;
  input Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of cylinders representing the joint axes&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.prefer 
    &quot;Priority to use joint coordinates (phi_a, phi_b, w_a, w_b) as states&quot;;

  Modelica.Mechanics.MultiBody.Joints.Revolute revolute_a(
    n=n_a,
    stateSelect=StateSelect.never,
    cylinderDiameter=cylinderDiameter,
    cylinderLength=cylinderLength,
    cylinderColor=cylinderColor,
    specularCoefficient=specularCoefficient,
    animation=animation);
  Modelica.Mechanics.MultiBody.Joints.Revolute revolute_b(
    n=n_b,
    stateSelect=StateSelect.never,
    animation=animation,
    cylinderDiameter=cylinderDiameter,
    cylinderLength=cylinderLength,
    cylinderColor=cylinderColor,
    specularCoefficient=specularCoefficient);

  SI.Angle phi_a(start=0, stateSelect=stateSelect) 
    &quot;Relative rotation angle from frame_a to intermediate frame&quot;;
  SI.Angle phi_b(start=0, stateSelect=stateSelect) 
    &quot;Relative rotation angle from intermediate frame to frame_b&quot;;
  SI.AngularVelocity w_a(start=0, stateSelect=stateSelect) 
    &quot;First derivative of angle phi_a (relative angular velocity a)&quot;;
  SI.AngularVelocity w_b(start=0, stateSelect=stateSelect) 
    &quot;First derivative of angle phi_b (relative angular velocity b)&quot;;
  SI.AngularAcceleration a_a(start=0) 
    &quot;Second derivative of angle phi_a (relative angular acceleration a)&quot;;
  SI.AngularAcceleration a_b(start=0) 
    &quot;Second derivative of angle phi_b (relative angular acceleration b)&quot;;

equation 
  phi_a = revolute_a.phi;
  phi_b = revolute_b.phi;
  w_a = der(phi_a);
  w_b = der(phi_b);
  a_a = der(w_a);
  a_b = der(w_b);
  connect(frame_a, revolute_a.frame_a);
  connect(revolute_b.frame_b, frame_b);
  connect(revolute_a.frame_b, revolute_b.frame_a);
end Universal;</code></pre>
<hr />
<h1 id="image46-modelica.mechanics.multibody.joints.planar"><img src="Modelica.Mechanics.MultiBody.Joints.PlanarI.png" alt="image46" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.Planar</h1>
<p><strong>Planar joint (3 degrees-of-freedom, 6 potential states)</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p>Joint where frame_b can move in a plane and can rotate around an axis orthogonal to the plane. The plane is defined by vector n which is perpendicular to the plane and by vector n_x, which points in the direction of the x-axis of the plane. frame_a and frame_b coincide when s_x=prismatic_x.s=0, s_y=prismatic_y.s=0 and phi=revolute.phi=0. This joint has the following potential states:</p>
<ul>
<li>the relative distance s_x = prismatic_x.s [m] along axis n_x,</li>
<li>the relative distance s_y = prismatic_y.s [m] along axis n_y = cross(n,n_x),</li>
<li>the relative angle phi = revolute.phi [rad] around axis n,</li>
<li>the relative velocity v_x (= der(s_x)).</li>
<li>the relative velocity v_y (= der(s_y)).</li>
<li>the relative angular velocity w (= der(phi))</li>
</ul>
<p>They are used as candidates for automatic selection of states from the tool. This may be enforced by setting &quot;stateSelect=StateSelect.<strong>always</strong>&quot; in the <strong>Advanced</strong> menu. The states are usually selected automatically. In certain situations, especially when closed kinematic loops are present, it might be slightly more efficient, when using the &quot;StateSelect.always&quot; setting.</p>
<p>In the following figure the animation of a planar joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint. The black arrows are parameter vectors &quot;n&quot; and &quot;n_x&quot; (here: n = {0,1,0}, n_x = {0,0,1}, s_x.start = 0.5, s_y.start = 0.5, phi.start = 45<sup>o</sup>).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-5">Parameters</h2>
<table>
<col width="37%" />
<col width="8%" />
<col width="14%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{0,0,1}</td>
<td align="left">Axis orthogonal to unconstrained plane, resolved in frame_a (= same as in frame_b) [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_x</td>
<td align="left">{1,0,0}</td>
<td align="left">Vector in direction of x-axis of plane, resolved in frame_a (n_x shall be orthogonal to n) [1]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderLength</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Length of revolute cylinder [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">world.defaultJointWidth</td>
<td align="left">Diameter of revolute cylinder [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of revolute cylinder</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">boxWidth</td>
<td align="left">0.3*cylinderDiameter</td>
<td align="left">Width of prismatic joint boxes [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">boxHeight</td>
<td align="left">boxWidth</td>
<td align="left">Height of prismatic joint boxes [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">boxColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of prismatic joint boxes</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.prefer</td>
<td align="left">Priority to use joint coordinates (s_x, s_y, phi, v_x, v_y, w) as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-5">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>model Planar 
  &quot;Planar joint (3 degrees-of-freedom, 6 potential states)&quot;
  import SI = Modelica.SIunits;

  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n={0,0,1} 
    &quot;Axis orthogonal to unconstrained plane, resolved in frame_a (= same as in frame_b)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n_x={1,0,0} 
    &quot;Vector in direction of x-axis of plane, resolved in frame_a (n_x shall be orthogonal to n)&quot;;
  parameter SI.Distance cylinderLength=world.defaultJointLength 
    &quot;Length of revolute cylinder&quot;;
  parameter SI.Distance cylinderDiameter=world.defaultJointWidth 
    &quot;Diameter of revolute cylinder&quot;;
  input Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of revolute cylinder&quot;;
  parameter SI.Distance boxWidth=0.3*cylinderDiameter 
    &quot;Width of prismatic joint boxes&quot;;
  parameter SI.Distance boxHeight=boxWidth &quot;Height of prismatic joint boxes&quot;;
  input Types.Color boxColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of prismatic joint boxes&quot;;
  parameter StateSelect stateSelect=StateSelect.prefer 
    &quot;Priority to use joint coordinates (s_x, s_y, phi, v_x, v_y, w) as states&quot;;

  Prismatic prismatic_x(
    stateSelect=StateSelect.never,
    n=(cross(cross(n, n_x), n)),
    animation=false);
  Prismatic prismatic_y(
    stateSelect=StateSelect.never,
    n=(cross(n, n_x)),
    animation=false);
  Revolute revolute(
    stateSelect=StateSelect.never,
    n=n,
    animation=false);

  SI.Position s_x(start=0, stateSelect=stateSelect) 
    &quot;Relative distance along first prismatic joint starting at frame_a&quot;;
  SI.Position s_y(start=0, stateSelect=stateSelect) 
    &quot;Relative distance along second prismatic joint starting at first prismatic joint&quot;;
  SI.Angle phi(start=0, stateSelect=stateSelect) 
    &quot;Relative rotation angle from frame_a to frame_b&quot;;
  SI.Velocity v_x(start=0, stateSelect=stateSelect) 
    &quot;First derivative of s_x (relative velocity in s_x direction)&quot;;
  SI.Velocity v_y(start=0, stateSelect=stateSelect) 
    &quot;First derivative of s_y (relative velocity in s_y direction)&quot;;
  SI.AngularVelocity w(start=0, stateSelect=stateSelect) 
    &quot;First derivative of angle phi (relative angular velocity)&quot;;
  SI.Acceleration a_x(start=0) 
    &quot;Second derivative of s_x (relative acceleration in s_x direction)&quot;;
  SI.Acceleration a_y(start=0) 
    &quot;Second derivative of s_y (relative acceleration in s_y direction)&quot;;
  SI.AngularAcceleration wd(start=0) 
    &quot;Second derivative of angle phi (relative angular acceleration)&quot;;

protected 
  parameter Integer ndim=if world.enableAnimation and animation then 1 else 0;
  parameter Real e[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                       n);
protected 
  Visualizers.Advanced.Shape box_x[ndim](
    each shapeType=&quot;box&quot;,
    each color=boxColor,
    each length=prismatic_x.s,
    each width=boxWidth,
    each height=boxWidth,
    each lengthDirection=prismatic_x.e,
    each widthDirection={0,1,0},
    each r=frame_a.r_0,
    each R=frame_a.R);
  Visualizers.Advanced.Shape box_y[ndim](
    each shapeType=&quot;box&quot;,
    each color=boxColor,
    each length=prismatic_y.s,
    each width=boxWidth,
    each height=boxWidth,
    each lengthDirection=prismatic_y.e,
    each widthDirection={1,0,0},
    each r=prismatic_y.frame_a.r_0,
    each R=prismatic_y.frame_a.R);
  Visualizers.Advanced.Shape cylinder[ndim](
    each shapeType=&quot;cylinder&quot;,
    each color=cylinderColor,
    each length=cylinderLength,
    each width=cylinderDiameter,
    each height=cylinderDiameter,
    each lengthDirection=n,
    each widthDirection={0,1,0},
    each r_shape=-e*(cylinderLength/2),
    each r=revolute.frame_b.r_0,
    each R=revolute.frame_b.R);
equation 
  s_x = prismatic_x.s;
  s_y = prismatic_y.s;
  phi = revolute.phi;
  v_x = der(s_x);
  v_y = der(s_y);
  w   = der(phi);
  a_x = der(v_x);
  a_y = der(v_y);
  wd  = der(w);

  connect(frame_a, prismatic_x.frame_a);
  connect(prismatic_x.frame_b, prismatic_y.frame_a);
  connect(prismatic_y.frame_b, revolute.frame_a);
  connect(revolute.frame_b, frame_b);
end Planar;</code></pre>
<hr />
<h1 id="image47-modelica.mechanics.multibody.joints.spherical"><img src="Modelica.Mechanics.MultiBody.Joints.SphericalI.png" alt="image47" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.Spherical</h1>
<p><strong>Spherical joint (3 constraints and no potential states, or 3 degrees-of-freedom and 3 states)</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p>Joint with <strong>3 constraints</strong> that define that the origin of frame_a and the origin of frame_b coincide. By default this joint defines only the 3 constraints without any potential states. If parameter <strong>enforceStates</strong> is set to <strong>true</strong> in the &quot;Advanced&quot; menu, three states are introduced. Depending on parameter <strong>useQuaternions</strong> these are either quaternions and the relative angular velocity or 3 angles and the angle derivatves. In the latter case the orientation of frame_b is computed by rotating frame_a along the axes defined in parameter vector &quot;sequence_angleStates&quot; (default = {1,2,3}, i.e., the Cardan angle sequence) around the angles used as states. For example, the default is to rotate the x-axis of frame_a around angles[1], the new y-axis around angles[2] and the new z-axis around angles[3], arriving at frame_b. If angles are used as states there is the slight disadvantage that a singular configuration is present leading to a divison by zero.</p>
<p>If this joint is used in a <strong>chain</strong> structure, a Modelica translator has to select orientation coordinates of a body as states, if the default setting is used. It is usually better to use relative coordinates in the spherical joint as states, and therefore in this situation parameter enforceStates might be set to <strong>true</strong>.</p>
<p>If this joint is used in a <strong>loop</strong> structure, the default setting results in a <strong>cut-joint</strong> that breaks the loop in independent kinematic pieces, hold together by the constraints of this joint. As a result, a Modelica translator will first try to select 3 generalized coordinates in the joints of the remaining parts of the loop and their first derivative as states and if this is not possible, e.g., because there are only spherical joints in the loop, will select coordinates from a body of the loop as states.</p>
<p>In the following figure the animation of a spherical joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint. (here: angles_start = {45, 45, 45}<sup>o</sup>).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-6">Parameters</h2>
<table>
<col width="41%" />
<col width="8%" />
<col width="12%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show sphere)</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">sphereDiameter</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Diameter of sphere representing the spherical joint [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">sphereColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of sphere representing the spherical joint</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">angles_fixed</td>
<td align="left">false</td>
<td align="left">= true, if angles_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_start</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b at initial time</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">w_rel_a_fixed</td>
<td align="left">false</td>
<td align="left">= true, if w_rel_a_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel_a_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a [rad/s]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">z_rel_a_fixed</td>
<td align="left">false</td>
<td align="left">= true, if z_rel_a_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_rel_a_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular acceleration z_rel_a = der(w_rel_a) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">enforceStates</td>
<td align="left">false</td>
<td align="left">= true, if relative variables of spherical joint shall be used as states (StateSelect.always)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useQuaternions</td>
<td align="left">true</td>
<td align="left">= true, if quaternions shall be used as states otherwise use 3 angles as states (provided enforceStates=true)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_angleStates</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-6">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>model Spherical 
  &quot;Spherical joint (3 constraints and no potential states, or 3 degrees-of-freedom and 3 states)&quot;

  import Modelica.Mechanics.MultiBody.Frames;
  import SI = Modelica.SIunits;

  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show sphere)&quot;;
  parameter SI.Distance sphereDiameter=world.defaultJointLength 
    &quot;Diameter of sphere representing the spherical joint&quot;;
  input Types.Color sphereColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of sphere representing the spherical joint&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  parameter Boolean angles_fixed = false 
    &quot;= true, if angles_start are used as initial values, else as guess values&quot;;
  parameter SI.Angle angles_start[3]={0,0,0} 
    &quot;Initial values of angles to rotate frame_a around &#39;sequence_start&#39; axes into frame_b&quot;;
  parameter Types.RotationSequence sequence_start={1,2,3} 
    &quot;Sequence of rotations to rotate frame_a into frame_b at initial time&quot;;

  parameter Boolean w_rel_a_fixed = false 
    &quot;= true, if w_rel_a_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularVelocity w_rel_a_start[3]={0,0,0} 
    &quot;Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a&quot;;

  parameter Boolean z_rel_a_fixed = false 
    &quot;= true, if z_rel_a_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularAcceleration z_rel_a_start[3]={0,0,0} 
    &quot;Initial values of angular acceleration z_rel_a = der(w_rel_a)&quot;;

  parameter Boolean enforceStates=false 
    &quot; = true, if relative variables of spherical joint shall be used as states (StateSelect.always)&quot;;
  parameter Boolean useQuaternions=true 
    &quot; = true, if quaternions shall be used as states otherwise use 3 angles as states (provided enforceStates=true)&quot;;
  parameter Types.RotationSequence sequence_angleStates={1,2,3} 
    &quot; Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states&quot;;

  final parameter Frames.Orientation R_rel_start=
      Frames.axesRotations(sequence_start, angles_start, zeros(3)) 
    &quot;Orientation object from frame_a to frame_b at initial time&quot;;

protected 
  Visualizers.Advanced.Shape sphere(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection={1,0,0},
    widthDirection={0,1,0},
    r_shape={-0.5,0,0}*sphereDiameter,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;

  // Declarations for quaternions (dummies, if quaternions are not used)
  parameter Frames.Quaternions.Orientation Q_start=
            Modelica.Mechanics.MultiBody.Frames.to_Q(R_rel_start) 
    &quot;Quaternion orientation object from frame_a to frame_b at initial time&quot;;
  Frames.Quaternions.Orientation Q(start=Q_start, each stateSelect=if 
        enforceStates and useQuaternions then StateSelect.prefer else 
        StateSelect.never) 
    &quot;Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)&quot;;

  // Declaration for 3 angles
  parameter SI.Angle phi_start[3]=if sequence_start[1] ==
      sequence_angleStates[1] and sequence_start[2] == sequence_angleStates[2]
       and sequence_start[3] == sequence_angleStates[3] then angles_start else 
       Frames.axesRotationsAngles(R_rel_start, sequence_angleStates) 
    &quot;Potential angle states at initial time&quot;;
  SI.Angle phi[3](start=phi_start, each stateSelect=if enforceStates and not 
        useQuaternions then StateSelect.always else StateSelect.never) 
    &quot;Dummy or 3 angles to rotate frame_a into frame_b&quot;;
  SI.AngularVelocity phi_d[3](each stateSelect=if enforceStates and not 
        useQuaternions then StateSelect.always else StateSelect.never) 
    &quot;= der(phi)&quot;;
  SI.AngularAcceleration phi_dd[3] &quot;= der(phi_d)&quot;;

  // Other declarations
  SI.AngularVelocity w_rel[3](start=Frames.resolve2(R_rel_start, w_rel_a_start),
        fixed = fill(w_rel_a_fixed,3), each stateSelect=if 
        enforceStates and useQuaternions then StateSelect.always else 
        StateSelect.never) 
    &quot;Dummy or relative angular velocity of frame_b with respect to frame_a, resolved in frame_b&quot;;
  Frames.Orientation R_rel 
    &quot;Dummy or relative orientation object to rotate from frame_a to frame_b&quot;;
  Frames.Orientation R_rel_inv 
    &quot;Dummy or relative orientation object to rotate from frame_b to frame_a&quot;;
initial equation 
  if angles_fixed then
    if not enforceStates then
      // no states defined in spherical object
      zeros(3) = Frames.Orientation.equalityConstraint(Frames.absoluteRotation(frame_a.R,R_rel_start),frame_b.R);
    elseif useQuaternions then
      // Quaternions Q are used as states
      zeros(3) = Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
    else
      // The 3 angles &#39;phi&#39; are used as states
      phi = phi_start;
    end if;
  end if;

  if z_rel_a_fixed then
    // Initialize acceleration variables
    der(w_rel) = Frames.resolve2(R_rel_start, z_rel_a_start);
  end if;
equation 
  // torque balance
  zeros(3) = frame_a.t;
  zeros(3) = frame_b.t;

  if enforceStates then
    Connections.branch(frame_a.R, frame_b.R);

    frame_b.r_0 = frame_a.r_0;
    if rooted(frame_a.R) then
      R_rel_inv = Frames.nullRotation();
      frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
      zeros(3) = frame_a.f + Frames.resolve1(R_rel, frame_b.f);
    else
      R_rel_inv = Frames.inverseRotation(R_rel);
      frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
      zeros(3) = frame_b.f + Frames.resolve2(R_rel, frame_a.f);
    end if;

    // Compute relative orientation object
    if useQuaternions then
      // Use Quaternions as states (with dynamic state selection)
      {0} = Frames.Quaternions.orientationConstraint(Q);
      w_rel = Frames.Quaternions.angularVelocity2(Q, der(Q));
      R_rel = Frames.from_Q(Q, w_rel);

      // Dummies
      phi = zeros(3);
      phi_d = zeros(3);
      phi_dd = zeros(3);

    else
      // Use angles as states
      phi_d = der(phi);
      phi_dd = der(phi_d);
      R_rel = Frames.axesRotations(sequence_angleStates, phi, phi_d);
      w_rel = Frames.angularVelocity2(R_rel);

      // Dummies
      Q = zeros(4);
    end if;

  else
    // Spherical joint does not have states
    frame_b.r_0 = frame_a.r_0;
    //frame_b.r_0 = transpose(frame_b.R.T)*(frame_b.R.T*(transpose(frame_a.R.T)*(frame_a.R.T*frame_a.r_0)));

    zeros(3) = frame_a.f + Frames.resolveRelative(frame_b.f, frame_b.R, frame_a.R);

    if w_rel_a_fixed or z_rel_a_fixed then
      w_rel = Frames.angularVelocity2(frame_b.R) - Frames.resolve2(frame_b.R,
         Frames.angularVelocity1(frame_a.R));
    else
      w_rel = zeros(3);
    end if;

    // Dummies
    R_rel = Frames.nullRotation();
    R_rel_inv = Frames.nullRotation();
    Q = zeros(4);
    phi = zeros(3);
    phi_d = zeros(3);
    phi_dd = zeros(3);
  end if;
end Spherical;</code></pre>
<hr />
<h1 id="image48-modelica.mechanics.multibody.joints.freemotion"><img src="Modelica.Mechanics.MultiBody.Joints.FreeMotionI.png" alt="image48" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.FreeMotion</h1>
<p><strong>Free motion joint (6 degrees-of-freedom, 12 potential states)</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<p>Joint which does not constrain the motion between frame_a and frame_b. Such a joint is only meaningful if the <strong>relative</strong> distance and orientation between frame_a and frame_b, and their derivatives, shall be used as <strong>states</strong>.</p>
<p>Note, that <strong>bodies</strong> such as Parts.Body, Parts.BodyShape, have potential states describing the distance and orientation, and their derivatives, between the <strong>world frame</strong> and a <strong>body fixed frame</strong>. Therefore, if these potential state variables are suited, a FreeMotion joint is not needed.</p>
<p>The states of the FreeMotion object are:</p>
<ul>
<li>The <strong>relative position vector</strong> r_rel_a from the origin of frame_a to the origin of frame_b, resolved in frame_a and the <strong>relative velocity</strong> v_rel_a of the origin of frame_b with respect to the origin of frame_a, resolved in frame_a (= der(r_rel_a)).</li>
<li>If parameter <strong>useQuaternions</strong> in the &quot;Advanced&quot; menu is <strong>true</strong> (this is the default), then <strong>4 quaternions</strong> are states. Additionally, the coordinates of the relative angular velocity vector are 3 potential states. If <strong>useQuaternions</strong> in the &quot;Advanced&quot; menu is <strong>false</strong>, then <strong>3 angles</strong> and the derivatives of these angles are potential states. The orientation of frame_b is computed by rotating frame_a along the axes defined in parameter vector &quot;sequence_angleStates&quot; (default = {1,2,3}, i.e., the Cardan angle sequence) around the angles used as states. For example, the default is to rotate the x-axis of frame_a around angles[1], the new y-axis around angles[2] and the new z-axis around angles[3], arriving at frame_b.</li>
</ul>
<p>The quaternions have the slight disadvantage that there is a non-linear constraint equation between the 4 quaternions. Therefore, at least one non-linear equation has to be solved during simulation. A tool might, however, analytically solve this simple constraint equation. Using the 3 angles as states has the disadvantage that there is a singular configuration in which a division by zero will occur. If it is possible to determine in advance for an application class that this singular configuration is outside of the operating region, the 3 angles might be used as states by setting <strong>useQuaternions</strong> = <strong>false</strong>.</p>
<p>In text books about 3-dimensional mechanics often 3 angles and the angular velocity are used as states. This is not the case here, since 3 angles and their derivatives are used as states (if useQuaternions = false). The reason is that for real-time simulation the discretization formula of the integrator might be &quot;inlined&quot; and solved together with the model equations. By appropriate symbolic transformation the performance is drastically increased if angles and their derivatives are used as states, instead of angles and the angular velocity.</p>
<p>If parameter <strong>enforceStates</strong> is set to <strong>true</strong> (= the default) in the &quot;Advanced&quot; menu, then FreeMotion variables are forced to be used as states according to the setting of parameters &quot;useQuaternions&quot; and &quot;sequence_angleStates&quot;.</p>
<p>In the following figure the animation of a FreeMotion joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint. (here: r_rel_a_start = {0.5, 0, 0.5}, angles_start = {45, 45, 45}<sup>o</sup>).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-7">Parameters</h2>
<table>
<col width="40%" />
<col width="8%" />
<col width="11%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show arrow from frame_a to frame_b)</td>
</tr>
<tr class="even">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_rel_a.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Position vector from origin of frame_a to origin of frame_b, resolved in frame_a [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_rel_a.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">= der(r_rel_a), i.e., velocity of origin of frame_b with respect to origin of frame_a, resolved in frame_a [m/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_rel_a.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">= der(v_rel_a) [m/s2]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">angles_fixed</td>
<td align="left">false</td>
<td align="left">= true, if angles_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_start</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b at initial time</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">w_rel_a_fixed</td>
<td align="left">false</td>
<td align="left">= true, if w_rel_a_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel_a_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a [rad/s]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">z_rel_a_fixed</td>
<td align="left">false</td>
<td align="left">= true, if z_rel_a_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_rel_a_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular acceleration z_rel_a = der(w_rel_a) [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">arrowDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of arrow from frame_a to frame_b [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">arrowColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of arrow</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">enforceStates</td>
<td align="left">true</td>
<td align="left">= true, if relative variables between frame_a and frame_b shall be used as states</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useQuaternions</td>
<td align="left">true</td>
<td align="left">= true, if quaternions shall be used as states otherwise use 3 angles as states</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_angleStates</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-7">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>model FreeMotion 
  &quot;Free motion joint (6 degrees-of-freedom, 12 potential states)&quot;

  import Modelica.Math.*;
  import SI = Modelica.SIunits;

  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show arrow from frame_a to frame_b)&quot;;

  SI.Position r_rel_a[3](start={0,0,0}, each stateSelect=if enforceStates then 
              StateSelect.always else StateSelect.prefer) 
    &quot;Position vector from origin of frame_a to origin of frame_b, resolved in frame_a&quot;;
  SI.Velocity v_rel_a[3](start={0,0,0}, each stateSelect=if enforceStates then StateSelect.always else 
              StateSelect.prefer) 
    &quot;= der(r_rel_a), i.e., velocity of origin of frame_b with respect to origin of frame_a, resolved in frame_a&quot;;
  SI.Acceleration a_rel_a[3](start={0,0,0}) &quot;= der(v_rel_a)&quot;;

  parameter Boolean angles_fixed = false 
    &quot;= true, if angles_start are used as initial values, else as guess values&quot;;
  parameter SI.Angle angles_start[3]={0,0,0} 
    &quot;Initial values of angles to rotate frame_a around &#39;sequence_start&#39; axes into frame_b&quot;;
  parameter Types.RotationSequence sequence_start={1,2,3} 
    &quot;Sequence of rotations to rotate frame_a into frame_b at initial time&quot;;

  parameter Boolean w_rel_a_fixed = false 
    &quot;= true, if w_rel_a_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularVelocity w_rel_a_start[3]={0,0,0} 
    &quot;Initial values of angular velocity of frame_b with respect to frame_a, resolved in frame_a&quot;;

  parameter Boolean z_rel_a_fixed = false 
    &quot;= true, if z_rel_a_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularAcceleration z_rel_a_start[3]={0,0,0} 
    &quot;Initial values of angular acceleration z_rel_a = der(w_rel_a)&quot;;

  parameter SI.Length arrowDiameter=world.defaultArrowDiameter 
    &quot;Diameter of arrow from frame_a to frame_b&quot;;
  input Types.Color arrowColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot;Color of arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter Boolean enforceStates=true 
    &quot; = true, if relative variables between frame_a and frame_b shall be used as states&quot;;
  parameter Boolean useQuaternions=true 
    &quot; = true, if quaternions shall be used as states otherwise use 3 angles as states&quot;;
  parameter Types.RotationSequence sequence_angleStates={1,2,3} 
    &quot; Sequence of rotations to rotate frame_a into frame_b around the 3 angles used as states&quot;;

  final parameter Frames.Orientation R_rel_start=
      Modelica.Mechanics.MultiBody.Frames.axesRotations(sequence_start, angles_start,zeros(3)) 
    &quot;Orientation object from frame_a to frame_b at initial time&quot;;

protected 
  Visualizers.Advanced.Arrow arrow(
    r_head=r_rel_a,
    diameter=arrowDiameter,
    color=arrowColor,
    specularCoefficient=specularCoefficient,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;

  // Declarations for quaternions (dummies, if quaternions are not used)
  parameter Frames.Quaternions.Orientation Q_start=Frames.to_Q(R_rel_start) 
    &quot;Quaternion orientation object from frame_a to frame_b at initial time&quot;;
  Frames.Quaternions.Orientation Q(start=Q_start, each stateSelect=if 
        enforceStates then (if useQuaternions then StateSelect.prefer else 
        StateSelect.never) else StateSelect.default) 
    &quot;Quaternion orientation object from frame_a to frame_b (dummy value, if quaternions are not used as states)&quot;;

  // Declaration for 3 angles
  parameter SI.Angle phi_start[3]=if sequence_start[1] ==
      sequence_angleStates[1] and sequence_start[2] == sequence_angleStates[2]
       and sequence_start[3] == sequence_angleStates[3] then angles_start else 
            Frames.axesRotationsAngles(R_rel_start,
      sequence_angleStates) &quot;Potential angle states at initial time&quot;;
  SI.Angle phi[3](start=phi_start, each stateSelect=if enforceStates then (if 
        useQuaternions then StateSelect.never else StateSelect.always) else 
        StateSelect.prefer) &quot;Dummy or 3 angles to rotate frame_a into frame_b&quot;;
  SI.AngularVelocity phi_d[3](each stateSelect=if enforceStates then (if 
        useQuaternions then StateSelect.never else StateSelect.always) else 
        StateSelect.prefer) &quot;= der(phi)&quot;;
  SI.AngularAcceleration phi_dd[3] &quot;= der(phi_d)&quot;;

  // Other declarations
  SI.AngularVelocity w_rel_b[3](start=Frames.resolve2(R_rel_start, w_rel_a_start),
                                fixed=fill(w_rel_a_fixed,3),
                                each stateSelect=if enforceStates then 
                                (if useQuaternions then StateSelect.always else 
                                StateSelect.avoid) else StateSelect.prefer) 
    &quot;Dummy or relative angular velocity of frame_b with respect to frame_a, resolved in frame_b&quot;;
  Frames.Orientation R_rel 
    &quot;Dummy or relative orientation object to rotate from frame_a to frame_b&quot;;
  Frames.Orientation R_rel_inv 
    &quot;Dummy or relative orientation object to rotate from frame_b to frame_a&quot;;

initial equation 
  if angles_fixed then
    // Initialize positional variables
    if not enforceStates then
      // no states defined
      zeros(3) = Frames.Orientation.equalityConstraint(Frames.absoluteRotation(frame_a.R,R_rel_start),frame_b.R);
    elseif useQuaternions then
      // Quaternions Q are used as states
      zeros(3) = Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
    else
      // The 3 angles &#39;phi&#39; are used as states
      phi = phi_start;
    end if;
  end if;

  if z_rel_a_fixed then
    // Initialize acceleration variables
    der(w_rel_b) = Frames.resolve2(R_rel_start, z_rel_a_start);
  end if;

equation 
  // Kinematic differential equations for translational motion
  der(r_rel_a) = v_rel_a;
  der(v_rel_a) = a_rel_a;

  // Kinematic relationships
  frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r_rel_a);

  // Cut-forces and cut-torques are zero
  frame_a.f = zeros(3);
  frame_a.t = zeros(3);
  frame_b.f = zeros(3);
  frame_b.t = zeros(3);

  if enforceStates then
    Connections.branch(frame_a.R, frame_b.R);

    if rooted(frame_a.R) then
      R_rel_inv = Frames.nullRotation();
      frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
    else
      R_rel_inv = Frames.inverseRotation(R_rel);
      frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
    end if;

    // Compute relative orientation object
    if useQuaternions then
      // Use Quaternions as states (with dynamic state selection)
      {0} = Frames.Quaternions.orientationConstraint(Q);
      w_rel_b = Frames.Quaternions.angularVelocity2(Q, der(Q));
      R_rel = Frames.from_Q(Q, w_rel_b);

      // Dummies
      phi = zeros(3);
      phi_d = zeros(3);
      phi_dd = zeros(3);

    else
      // Use angles as states
      phi_d = der(phi);
      phi_dd = der(phi_d);
      R_rel = Frames.axesRotations(sequence_angleStates, phi, phi_d);
      w_rel_b = Frames.angularVelocity2(R_rel);

      // Dummies
      Q = zeros(4);
    end if;

  else
    // Free motion joint does not have states
    if w_rel_a_fixed or z_rel_a_fixed then
      w_rel_b = Frames.angularVelocity2(frame_b.R) - Frames.resolve2(frame_b.
        R, Frames.angularVelocity1(frame_a.R));
    else
      // dummy
      w_rel_b = zeros(3);
    end if;

    // Dummies
    R_rel = Frames.nullRotation();
    R_rel_inv = Frames.nullRotation();
    Q = zeros(4);
    phi = zeros(3);
    phi_d = zeros(3);
    phi_dd = zeros(3);
  end if;
end FreeMotion;</code></pre>
<hr />
<h1 id="image49-modelica.mechanics.multibody.joints.freemotionscalarinit"><img src="Modelica.Mechanics.MultiBody.Joints.FreeMotionI.png" alt="image49" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.FreeMotionScalarInit</h1>
<p><strong>Free motion joint with scalar initialization and state selection (6 degrees-of-freedom, 12 potential states)</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<p>Joint which does not constrain the motion between frame_a and frame_b. Such a joint is meaningful if the <strong>relative</strong> distance and orientation between frame_a and frame_b, and their derivatives, shall be used as <strong>states</strong> or shall be used for non-standard <strong>initialization</strong>. This joint allows to <strong>initialize</strong> every <strong>scalar</strong> element of the relative quantites, as well as to define <strong>StateSelect</strong> attributes for every <strong>scalar</strong> element separately.</p>
<p>In the following figure the animation of a FreeMotionScalarInit joint is shown. The light blue coordinate system is frame_a and the dark blue coordinate system is frame_b of the joint. (here: r_rel_a_1(start = 0.5), r_rel_a_2(start = 0), r_rel_a_3(start = 0.5), angle_1(start = 45<sup>o</sup>), angle_2(start = 45<sup>o</sup>), angle_3(start = 45<sup>o</sup>)).</p>
<p>A example to use this joint for the initialization of a planar double pendulum by providing its tip position, is shown in <a href="Modelica_Mechanics_MultiBody_Examples_Elementary.html#Modelica.Mechanics.MultiBody.Examples.Elementary.DoublePendulumInitTip">Examples.Elementary.DoublePendulumInitTip</a>.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-8">Parameters</h2>
<table>
<col width="45%" />
<col width="11%" />
<col width="13%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show arrow from frame_a to frame_b)</td>
</tr>
<tr class="even">
<td align="left"><strong>Translational Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Position vector r_rel_a from origin of frame_a to origin of frame_b, resolved in frame_a</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">use_r</td>
<td align="left">false</td>
<td align="left">= true, if r_rel_a shall be used</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_rel_a_1.start</td>
<td align="left">0</td>
<td align="left">Relative distance r_rel_a[1] [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_rel_a_2.start</td>
<td align="left">0</td>
<td align="left">Relative distance r_rel_a[2] [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_rel_a_3.start</td>
<td align="left">0</td>
<td align="left">Relative distance r_rel_a[3] [m]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">r_rel_a_1_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of r_rel_a[1]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">r_rel_a_2_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of r_rel_a[2]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">r_rel_a_3_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of r_rel_a[3]</td>
</tr>
<tr class="odd">
<td align="left">Velocity vector v_rel_a = der(r_rel_a)</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">use_v</td>
<td align="left">false</td>
<td align="left">= true, if v_rel_a shall be used</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_rel_a_1.start</td>
<td align="left">0</td>
<td align="left">Relative velocity v_rel_a[1] [m/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_rel_a_2.start</td>
<td align="left">0</td>
<td align="left">Relative velocity v_rel_a[2] [m/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_rel_a_3.start</td>
<td align="left">0</td>
<td align="left">Relative velocity v_rel_a[3] [m/s]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">v_rel_a_1_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of v_rel_a[1]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">v_rel_a_2_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of v_rel_a[2]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">v_rel_a_3_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of v_rel_a[3]</td>
</tr>
<tr class="odd">
<td align="left">Acceleration vector a_rel_a = der(v_rel_a)</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">use_a</td>
<td align="left">false</td>
<td align="left">= true, if a_rel_a shall be used</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_rel_a_1.start</td>
<td align="left">0</td>
<td align="left">Relative acceleration a_rel_a[1] [m/s2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_rel_a_2.start</td>
<td align="left">0</td>
<td align="left">Relative acceleration a_rel_a[2] [m/s2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_rel_a_3.start</td>
<td align="left">0</td>
<td align="left">Relative acceleration a_rel_a[3] [m/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Angle Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Angles to rotate frame_a to frame_b along sequence_start</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">use_angle</td>
<td align="left">false</td>
<td align="left">= true, if angle shall be used</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_start</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of angle rotations</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angle_1.start</td>
<td align="left">0</td>
<td align="left">First rotation angle or dummy [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angle_2.start</td>
<td align="left">0</td>
<td align="left">Second rotation angle or dummy [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angle_3.start</td>
<td align="left">0</td>
<td align="left">Third rotation angle or dummy [rad]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">angle_1_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of angle_1</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">angle_2_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of angle_2</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">angle_3_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of angle_3</td>
</tr>
<tr class="even">
<td align="left">angle_d = der(angle)</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_angle_d</td>
<td align="left">false</td>
<td align="left">= true, if angle_d shall be used</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">angle_d_1.start</td>
<td align="left">0</td>
<td align="left">= der(angle_1) [rad/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">angle_d_2.start</td>
<td align="left">0</td>
<td align="left">= der(angle_2) [rad/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">angle_d_3.start</td>
<td align="left">0</td>
<td align="left">= der(angle_3) [rad/s]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">angle_d_1_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of angle_d_1</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">angle_d_2_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of angle_d_2</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">angle_d_3_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of angle_d_3</td>
</tr>
<tr class="even">
<td align="left">angle_dd = der(angle_d)</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_angle_dd</td>
<td align="left">false</td>
<td align="left">= true, if angle_dd shall be used</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">angle_dd_1.start</td>
<td align="left">0</td>
<td align="left">= der(angle_d_1) [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">angle_dd_2.start</td>
<td align="left">0</td>
<td align="left">= der(angle_d_2) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">angle_dd_3.start</td>
<td align="left">0</td>
<td align="left">= der(angle_d_3) [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Angular Velocity Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Angular velocity w_rel_b of frame_b with respect to frame_a, resolved in frame_b</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_w</td>
<td align="left">false</td>
<td align="left">= true, if w_rel_b shall be used</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel_b_1.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity w_rel_b[1] [rad/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel_b_2.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity w_rel_b[2] [rad/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_rel_b_3.start</td>
<td align="left">0</td>
<td align="left">Relative angular velocity w_rel_b[3] [rad/s]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">w_rel_b_1_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of w_rel_b[1]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">w_rel_b_2_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of w_rel_b[2]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">w_rel_b_3_stateSelect</td>
<td align="left">StateSelect.never</td>
<td align="left">StateSelect of w_rel_b[3]</td>
</tr>
<tr class="even">
<td align="left">Angular acceleration z_rel_b = der(w_rel_b)</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">use_z</td>
<td align="left">false</td>
<td align="left">= true, if z_rel_b shall be used</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_rel_b_1.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration z_rel_b[1] [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_rel_b_2.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration z_rel_b[2] [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_rel_b_3.start</td>
<td align="left">0</td>
<td align="left">Relative angular acceleration z_rel_b[3] [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">arrowDiameter</td>
<td align="left">world.defaultArrowDiameter</td>
<td align="left">Diameter of arrow from frame_a to frame_b [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">arrowColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of arrow</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-8">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>model FreeMotionScalarInit 
  &quot;Free motion joint with scalar initialization and state selection (6 degrees-of-freedom, 12 potential states)&quot;

  import Modelica.Math.*;
  import SI = Modelica.SIunits;

  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show arrow from frame_a to frame_b)&quot;;

  parameter Boolean use_r = false &quot;= true, if r_rel_a shall be used&quot;;
  SI.Position r_rel_a_1(start=0, final stateSelect=r_rel_a_1_stateSelect) = model_r.r_rel_a_1 if use_r 
    &quot;Relative distance r_rel_a[1]&quot;;
  SI.Position r_rel_a_2(start=0, final stateSelect=r_rel_a_2_stateSelect) = model_r.r_rel_a_2 if use_r 
    &quot;Relative distance r_rel_a[2]&quot;;
  SI.Position r_rel_a_3(start=0, final stateSelect=r_rel_a_3_stateSelect) = model_r.r_rel_a_3 if use_r 
    &quot;Relative distance r_rel_a[3]&quot;;

  parameter StateSelect r_rel_a_1_stateSelect=StateSelect.never 
    &quot;StateSelect of r_rel_a[1]&quot;;
  parameter StateSelect r_rel_a_2_stateSelect=StateSelect.never 
    &quot;StateSelect of r_rel_a[2]&quot;;
  parameter StateSelect r_rel_a_3_stateSelect=StateSelect.never 
    &quot;StateSelect of r_rel_a[3]&quot;;

  parameter Boolean use_v = false &quot;= true, if v_rel_a shall be used&quot;;
  SI.Velocity v_rel_a_1(start=0, final stateSelect=v_rel_a_1_stateSelect) = der(r_rel_a_1) if use_r and use_v 
    &quot;Relative velocity v_rel_a[1]&quot;;
  SI.Velocity v_rel_a_2(start=0, final stateSelect=v_rel_a_2_stateSelect) = der(r_rel_a_2) if use_r and use_v 
    &quot;Relative velocity v_rel_a[2]&quot;;
  SI.Velocity v_rel_a_3(start=0, final stateSelect=v_rel_a_3_stateSelect) = der(r_rel_a_3) if use_r and use_v 
    &quot;Relative velocity v_rel_a[3]&quot;;

  parameter StateSelect v_rel_a_1_stateSelect=StateSelect.never 
    &quot;StateSelect of v_rel_a[1]&quot;;
  parameter StateSelect v_rel_a_2_stateSelect=StateSelect.never 
    &quot;StateSelect of v_rel_a[2]&quot;;
  parameter StateSelect v_rel_a_3_stateSelect=StateSelect.never 
    &quot;StateSelect of v_rel_a[3]&quot;;

  parameter Boolean use_a = false &quot;= true, if a_rel_a shall be used&quot;;
  SI.Acceleration a_rel_a_1(start=0) = der(v_rel_a_1) if use_r and use_v and use_a 
    &quot;Relative acceleration a_rel_a[1]&quot;;
  SI.Acceleration a_rel_a_2(start=0) = der(v_rel_a_2) if use_r and use_v and use_a 
    &quot;Relative acceleration a_rel_a[2]&quot;;
  SI.Acceleration a_rel_a_3(start=0) = der(v_rel_a_3) if use_r and use_v and use_a 
    &quot;Relative acceleration a_rel_a[3]&quot;;

  parameter Boolean use_angle = false &quot;= true, if angle shall be used&quot;;

  parameter Types.RotationSequence sequence_start={1,2,3} 
    &quot;Sequence of angle rotations&quot;;

  SI.Angle angle_1(start=0, stateSelect=angle_1_stateSelect) 
    &quot;First rotation angle or dummy&quot;;
  SI.Angle angle_2(start=0, stateSelect=angle_2_stateSelect) 
    &quot;Second rotation angle or dummy&quot;;
  SI.Angle angle_3(start=0, stateSelect=angle_3_stateSelect) 
    &quot;Third rotation angle or dummy&quot;;

  parameter StateSelect angle_1_stateSelect=StateSelect.never 
    &quot;StateSelect of angle_1&quot;;
  parameter StateSelect angle_2_stateSelect=StateSelect.never 
    &quot;StateSelect of angle_2&quot;;
  parameter StateSelect angle_3_stateSelect=StateSelect.never 
    &quot;StateSelect of angle_3&quot;;

  parameter Boolean use_angle_d= false &quot;= true, if angle_d shall be used&quot;;

  SI.AngularVelocity angle_d_1(start=0, final stateSelect=angle_d_1_stateSelect) = der(angle_1) if use_angle and use_angle_d 
    &quot;= der(angle_1)&quot;;
  SI.AngularVelocity angle_d_2(start=0, final stateSelect=angle_d_2_stateSelect) = der(angle_2) if use_angle and use_angle_d 
    &quot;= der(angle_2)&quot;;
  SI.AngularVelocity angle_d_3(start=0, final stateSelect=angle_d_3_stateSelect) = der(angle_3) if use_angle and use_angle_d 
    &quot;= der(angle_3)&quot;;

  parameter StateSelect angle_d_1_stateSelect=StateSelect.never 
    &quot;StateSelect of angle_d_1&quot;;
  parameter StateSelect angle_d_2_stateSelect=StateSelect.never 
    &quot;StateSelect of angle_d_2&quot;;
  parameter StateSelect angle_d_3_stateSelect=StateSelect.never 
    &quot;StateSelect of angle_d_3&quot;;

  parameter Boolean use_angle_dd = false &quot;= true, if angle_dd shall be used&quot;;
  SI.AngularAcceleration angle_dd_1(start=0) = der(angle_d_1) if use_angle and use_angle_d and use_angle_dd 
    &quot;= der(angle_d_1)&quot;;
  SI.AngularAcceleration angle_dd_2(start=0) = der(angle_d_2) if use_angle and use_angle_d and use_angle_dd 
    &quot;= der(angle_d_2)&quot;;
  SI.AngularAcceleration angle_dd_3(start=0) = der(angle_d_3) if use_angle and use_angle_d and use_angle_dd 
    &quot;= der(angle_d_3)&quot;;

  parameter Boolean use_w = false &quot;= true, if w_rel_b shall be used&quot;;

  SI.AngularVelocity w_rel_b_1(start=0, stateSelect=w_rel_b_1_stateSelect) = model_w.w_rel_b_1 if use_w 
    &quot;Relative angular velocity w_rel_b[1]&quot;;
  SI.AngularVelocity w_rel_b_2(start=0, stateSelect=w_rel_b_2_stateSelect) = model_w.w_rel_b_2 if use_w 
    &quot;Relative angular velocity w_rel_b[2]&quot;;
  SI.AngularVelocity w_rel_b_3(start=0, stateSelect=w_rel_b_3_stateSelect) = model_w.w_rel_b_3 if use_w 
    &quot;Relative angular velocity w_rel_b[3]&quot;;

  parameter StateSelect w_rel_b_1_stateSelect=StateSelect.never 
    &quot;StateSelect of w_rel_b[1]&quot;;
  parameter StateSelect w_rel_b_2_stateSelect=StateSelect.never 
    &quot;StateSelect of w_rel_b[2]&quot;;
  parameter StateSelect w_rel_b_3_stateSelect=StateSelect.never 
    &quot;StateSelect of w_rel_b[3]&quot;;

  parameter Boolean use_z = false &quot;= true, if z_rel_b shall be used&quot;;
  SI.AngularAcceleration z_rel_b_1(start=0) = der(w_rel_b_1) if use_w and use_z 
    &quot;Relative angular acceleration z_rel_b[1]&quot;;
  SI.AngularAcceleration z_rel_b_2(start=0) = der(w_rel_b_2) if use_w and use_z 
    &quot;Relative angular acceleration z_rel_b[2]&quot;;
  SI.AngularAcceleration z_rel_b_3(start=0) = der(w_rel_b_3) if use_w and use_z 
    &quot;Relative angular acceleration z_rel_b[3]&quot;;

  parameter SI.Length arrowDiameter=world.defaultArrowDiameter 
    &quot;Diameter of arrow from frame_a to frame_b&quot;;
  input Types.Color arrowColor=Modelica.Mechanics.MultiBody.Types.Defaults.SensorColor 
    &quot;Color of arrow&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  Visualizers.Advanced.Arrow arrow(
    r_head={r_rel_a_1, r_rel_a_2, r_rel_a_3},
    diameter=arrowDiameter,
    color=arrowColor,
    specularCoefficient=specularCoefficient,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation and use_r;

  encapsulated model Model_r
    import SI = Modelica.SIunits;
    import Modelica.Mechanics.MultiBody.Frames;
     input SI.Position r_a_0[3];
     input SI.Position r_b_0[3];
     input Frames.Orientation R_a;
     output SI.Position r_rel_a_1;
     output SI.Position r_rel_a_2;
     output SI.Position r_rel_a_3;
  equation 
     r_b_0 = r_a_0 + Frames.resolve1(R_a, {r_rel_a_1, r_rel_a_2, r_rel_a_3});
  end Model_r;

  encapsulated model Model_w
    import SI = Modelica.SIunits;
    import Modelica.Mechanics.MultiBody.Frames;
     input Frames.Orientation R_a;
     input Frames.Orientation R_b;
     output SI.AngularVelocity w_rel_b_1;
     output SI.AngularVelocity w_rel_b_2;
     output SI.AngularVelocity w_rel_b_3;
  equation 
     {w_rel_b_1, w_rel_b_2, w_rel_b_3} = Frames.angularVelocity2(R_b)
                                         - Frames.resolve2(R_b,Frames.angularVelocity1(R_a));
  end Model_w;

  Model_r model_r(r_a_0=frame_a.r_0, r_b_0=frame_b.r_0, R_a = frame_a.R) if use_r;
  Model_w model_w(R_a = frame_a.R, R_b = frame_b.R) if use_w;

  Frames.Orientation R_rel 
    &quot;Dummy or relative orientation object to rotate from frame_a to frame_b&quot;;
  Frames.Orientation R_rel_inv 
    &quot;Dummy or relative orientation object to rotate from frame_b to frame_a&quot;;

equation 
  if use_angle then
     Connections.branch(frame_a.R, frame_b.R);
     R_rel = Frames.axesRotations(sequence_start,
                                  {angle_1, angle_2, angle_3},
                                  {der(angle_1), der(angle_2), der(angle_3)});
     if rooted(frame_a.R) then
        R_rel_inv = Frames.nullRotation();
        frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
     else
        R_rel_inv = Frames.inverseRotation(R_rel);
        frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
     end if;
  else
     R_rel     = Frames.nullRotation();
     R_rel_inv = Frames.nullRotation();
     angle_1   = 0;
     angle_2   = 0;
     angle_3   = 0;
  end if;

  // Cut-forces and cut-torques are zero
  frame_a.f = zeros(3);
  frame_a.t = zeros(3);
  frame_b.f = zeros(3);
  frame_b.t = zeros(3);

end FreeMotionScalarInit;</code></pre>
<hr />
<h1 id="image50-modelica.mechanics.multibody.joints.sphericalspherical"><img src="Modelica.Mechanics.MultiBody.Joints.SphericalSphericalI.png" alt="image50" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.SphericalSpherical</h1>
<p><strong>Spherical - spherical joint aggregation (1 constraint, no potential states) with an optional point mass in the middle</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<p>Joint that has a spherical joint on each of its two ends. The rod connecting the two spherical joints is approximated by a point mass that is located in the middle of the rod. When the mass is set to zero (default), special code for a massless body is generated. In the following default animation figure, the two spherical joints are represented by two red spheres, the connecting rod by a grey cylinder and the point mass in the middle of the rod by a light blue sphere:</p>
<p>This joint introduces <strong>one constraint</strong> defining that the distance between the origin of frame_a and the origin of frame_b is constant (= rodLength). It is highly recommended to use this joint in loops whenever possible, because this enhances the efficiency considerably due to smaller systems of non-linear algebraic equations.</p>
<p>It is sometimes desirable to <strong>compute</strong> the <strong>rodLength</strong> of the connecting rod during initialization. For this, parameter <strong>computeLength</strong> has to be set to <strong>true</strong> and instead <strong>one</strong> other, easier to determine, position variable in the same loop needs to have a fixed attribute of <strong>true</strong>. For example, if a loop consists of one Revolute joint, one Prismatic joint and a SphericalSpherical joint, one may fix the start values of the revolute joint angle and of the relative distance of the prismatic joint in order to compute the rodLength of the rod.</p>
<p>It is not possible to connect other components, such as a body with mass properties or a special visual shape object to the rod connecting the two spherical joints. If this is needed, use instead joint Joints.<strong>UniversalSpherical</strong> that has this property.</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-9">Parameters</h2>
<table>
<col width="28%" />
<col width="5%" />
<col width="9%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">showMass</td>
<td align="left">true</td>
<td align="left">= true, if mass shall be shown (provided animation = true and m &gt; 0)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">computeRodLength</td>
<td align="left">false</td>
<td align="left">= true, if rodLength shall be computed during initialization (see info)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">rodLength</td>
<td align="left">
</td>
<td align="left">Distance between the origins of frame_a and frame_b (if computeRodLength=true, guess value) [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m</td>
<td align="left">0</td>
<td align="left">Mass of rod (= point mass located in middle of rod) [kg]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">sphereDiameter</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Diameter of spheres respresenting the spherical joints [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">sphereColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of spheres respresenting the spherical joints</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">rodDiameter</td>
<td align="left">sphereDiameter/Types.Default...</td>
<td align="left">Diameter of rod connecting the two spherical joint [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">rodColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of rod connecting the two spherical joints</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left">if animation = true and showMass = true and m &gt; 0</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">massDiameter</td>
<td align="left">sphereDiameter</td>
<td align="left">Diameter of sphere representing the mass point [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">massColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of sphere representing the mass point</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">kinematicConstraint</td>
<td align="left">true</td>
<td align="left">= false, if no constraint shall be defined, due to analytically solving a kinematic loop (&quot;false&quot; should not be used by user, but only by MultiBody.Joints.Assemblies joints)</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">constraintResidue</td>
<td align="left">rRod_0*rRod_0 - rodLength*ro...</td>
<td align="left">Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">checkTotalPower</td>
<td align="left">false</td>
<td align="left">= true, if total power flowing into this component shall be determined (must be zero)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-9">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>model SphericalSpherical 
  &quot;Spherical - spherical joint aggregation (1 constraint, no potential states) with an optional point mass in the middle&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;
  extends Interfaces.PartialTwoFrames;

  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Boolean showMass=true 
    &quot;= true, if mass shall be shown (provided animation = true and m &gt; 0)&quot;;
  parameter Boolean computeRodLength=false 
    &quot;= true, if rodLength shall be computed during initialization (see info)&quot;;
  parameter SI.Length rodLength(
    min=Modelica.Constants.eps,
    fixed=not computeRodLength, start = 1) 
    &quot;Distance between the origins of frame_a and frame_b (if computeRodLength=true, guess value)&quot;;
  parameter SI.Mass m(min=0)=0 
    &quot;Mass of rod (= point mass located in middle of rod)&quot;;
  parameter SI.Diameter sphereDiameter=world.defaultJointLength 
    &quot;Diameter of spheres respresenting the spherical joints&quot;;
  input Types.Color sphereColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of spheres respresenting the spherical joints&quot;;
  parameter SI.Diameter rodDiameter=sphereDiameter/Types.Defaults.JointRodDiameterFraction 
    &quot;Diameter of rod connecting the two spherical joint&quot;;
  input Types.Color rodColor=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
    &quot;Color of rod connecting the two spherical joints&quot;;
  parameter SI.Diameter massDiameter=sphereDiameter 
    &quot;Diameter of sphere representing the mass point&quot;;
  input Types.Color massColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot;Color of sphere representing the mass point&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  parameter Boolean kinematicConstraint=true 
    &quot;= false, if no constraint shall be defined, due to analytically solving a kinematic loop (\&quot;false\&quot; should not be used by user, but only by MultiBody.Joints.Assemblies joints)&quot;;
  Real constraintResidue = rRod_0*rRod_0 - rodLength*rodLength 
    &quot;Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)&quot;;
  parameter Boolean checkTotalPower=false 
    &quot;= true, if total power flowing into this component shall be determined (must be zero)&quot;;

  SI.Force f_rod 
    &quot;Constraint force in direction of the rod (positive on frame_a, when directed from frame_a to frame_b)&quot;;
  SI.Position rRod_0[3] 
    &quot;Position vector from frame_a to frame_b resolved in world frame&quot;;
  SI.Position rRod_a[3] 
    &quot;Position vector from frame_a to frame_b resolved in frame_a&quot;;
  Real eRod_a[3](each final unit=&quot;1&quot;) 
    &quot;Unit vector in direction from frame_a to frame_b, resolved in frame_a&quot;;
  SI.Position r_CM_0[3] 
    &quot;Dummy if m==0, or position vector from world frame to mid-point of rod, resolved in world frame&quot;;
  SI.Velocity v_CM_0[3] &quot;First derivative of r_CM_0&quot;;
  SI.Force f_CM_a[3] 
    &quot;Dummy if m==0, or inertial force acting at mid-point of rod due to mass oint acceleration, resolved in frame_a&quot;;
  SI.Force f_CM_e[3] 
    &quot;Dummy if m==0, or projection of f_CM_a onto eRod_a, resolved in frame_a&quot;;
  SI.Force f_b_a1[3] 
    &quot;Force acting at frame_b, but without force in rod, resolved in frame_a&quot;;
  SI.Power totalPower 
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;;

protected 
  Visualizers.Advanced.Shape shape_rod(
    shapeType=&quot;cylinder&quot;,
    color=rodColor,
    specularCoefficient=specularCoefficient,
    length=rodLength,
    width=rodDiameter,
    height=rodDiameter,
    lengthDirection=eRod_a,
    widthDirection={0,1,0},
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape shape_a(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection=eRod_a,
    widthDirection={0,1,0},
    r_shape=-eRod_a*(sphereDiameter/2),
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape shape_b(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection=eRod_a,
    widthDirection={0,1,0},
    r_shape=eRod_a*(rodLength - sphereDiameter/2),
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape shape_mass(
    shapeType=&quot;sphere&quot;,
    color=massColor,
    specularCoefficient=specularCoefficient,
    length=massDiameter,
    width=massDiameter,
    height=massDiameter,
    lengthDirection=eRod_a,
    widthDirection={0,1,0},
    r_shape=eRod_a*(rodLength/2 - sphereDiameter/2),
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation and showMass and m &gt; 0;
equation 
  // Determine relative position vector between the two frames
  if kinematicConstraint then
    rRod_0 = transpose(frame_b.R.T)*(frame_b.R.T*frame_b.r_0) - transpose(
      frame_a.R.T)*(frame_a.R.T*frame_a.r_0);
  else
    rRod_0 = frame_b.r_0 - frame_a.r_0;
  end if;

  //rRod_0 = frame_b.r_0 - frame_a.r_0;
  rRod_a = Frames.resolve2(frame_a.R, rRod_0);
  eRod_a = rRod_a/rodLength;

  // Constraint equation
  constraintResidue = 0;

  // Cut-torques at frame_a and frame_b
  frame_a.t = zeros(3);
  frame_b.t = zeros(3);

  /* Force and torque balance of rod
     - Kinematics for center of mass CM of mass point
       r_CM_0 = frame_a.r_0 + rRod_0/2;
       v_CM_0 = der(r_CM_0);
       a_CM_a = resolve2(frame_a.R, der(v_CM_0) - world.gravityAcceleration(r_CM_0));
     - Inertial and gravity force in direction (f_CM_e) and orthogonal (f_CM_n) to rod
       f_CM_a = m*a_CM_a
       f_CM_e = f_CM_a*eRod_a;           // in direction of rod
       f_CM_n = rodLength(f_CM_a - f_CM_e);  // orthogonal to rod
     - Force balance in direction of rod
       f_CM_e = fa_rod_e + fb_rod_e;
     - Force balance orthogonal to rod
       f_CM_n = fa_rod_n + fb_rod_n;
     - Torque balance with respect to frame_a
       0 = (-f_CM_n)*rodLength/2 + fb_rod_n*rodLength
     The result is:
     fb_rod_n = f_CM_n/2;
     fa_rod_n = fb_rod_n;
     fb_rod_e = f_CM_e - fa_rod_e;
     fa_rod_e is the unknown computed from loop
  */

    // f_b_a1 is needed in aggregation joints to solve kinematic loops analytically
  if m &gt; 0 then
    r_CM_0 = frame_a.r_0 + rRod_0/2;
    v_CM_0 = der(r_CM_0);
    f_CM_a = m*Frames.resolve2(frame_a.R, der(v_CM_0) -
      world.gravityAcceleration(r_CM_0));
    f_CM_e = (f_CM_a*eRod_a)*eRod_a;
    frame_a.f = (f_CM_a - f_CM_e)/2 + f_rod*eRod_a;
    f_b_a1 = (f_CM_a + f_CM_e)/2;
    frame_b.f = Frames.resolveRelative(f_b_a1 - f_rod*eRod_a, frame_a.R,
      frame_b.R);
  else
    r_CM_0 = zeros(3);
    v_CM_0 = zeros(3);
    f_CM_a = zeros(3);
    f_CM_e = zeros(3);
    f_b_a1 = zeros(3);
    frame_a.f = f_rod*eRod_a;
    frame_b.f = -Frames.resolveRelative(frame_a.f, frame_a.R, frame_b.R);
  end if;

  if checkTotalPower then
    totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
      frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + (-m)*(der(
      v_CM_0) - world.gravityAcceleration(r_CM_0))*v_CM_0 + frame_a.t*
      Frames.angularVelocity2(frame_a.R) + frame_b.t*Frames.angularVelocity2(
      frame_b.R);
  else
    totalPower = 0;
  end if;
end SphericalSpherical;</code></pre>
<hr />
<h1 id="image51-modelica.mechanics.multibody.joints.universalspherical"><img src="Modelica.Mechanics.MultiBody.Joints.UniversalSphericalI.png" alt="image51" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.UniversalSpherical</h1>
<p><strong>Universal - spherical joint aggregation (1 constraint, no potential states)</strong></p>
<h2 id="information-11">Information</h2>
<p>::</p>
<p>This component consists of a <strong>universal joint</strong> at frame_a and a <strong>spherical joint</strong> at frame_b that are connected together with a <strong>rigid rod</strong>, see default aimation figure (the arrows are not part of the default animation):</p>
<p>This joint aggregation has no mass and no inertia and introduces the constraint that the distance between the origin of frame_a and the origin of frame_b is constant (= Frames.length(rRod_ia)). The universal joint is defined in the following way:</p>
<ul>
<li>The rotation <strong>axis</strong> of revolute joint <strong>1</strong> is along parameter vector n1_a which is fixed in frame_a.</li>
<li></li>
<li>The rotation <strong>axis</strong> of revolute joint <strong>2</strong> is perpendicular to axis 1 and to the line connecting the universal and the spherical joint.</li>
</ul>
<p>The definition of axis 2 of the universal joint is performed according to the most often occuring case. In a future release, axis 2 might be explicitly definable via a parameter. However, the treatment is much more complicated and the number of operations is considerably higher, if axis 2 is not orthogonal to axis 1 and to the connecting rod.</p>
<p>Note, there is a <strong>singularity</strong> when axis 1 and the connecting rod are parallel to other. Therefore, if possible n1_a should be selected in such a way that it is perpendicular to rRod_ia in the initial configuration (i.e., the distance to the singularity is as large as possible).</p>
<p>An additional <strong>frame_ia</strong> is present. It is <strong>fixed</strong> in the connecting <strong>rod</strong> at the origin of <strong>frame_a</strong>. The placement of frame_ia on the rod is implicitly defined by the universal joint (frame_a and frame_ia coincide when the angles of the two revolute joints of the universal joint are zero) and by parameter vector <strong>rRod_ia</strong>, the position vector from the origin of frame_a to the origin of frame_b, resolved in frame_<strong>ia</strong>.</p>
<p>The easiest way to define the parameters of this joint is by moving the MultiBody system in a <strong>reference configuration</strong> where <strong>all frames</strong> of all components are <strong>parallel</strong> to other (alternatively, at least frame_a and frame_ia of the UniversalSpherical joint should be parallel to other when defining an instance of this component). Since frame_a and frame_ia are parallel to other, vector <strong>rRod_ia</strong> from frame_a to frame_b resolved in frame_<strong>ia</strong> can be resolved in frame_<strong>a</strong> (or the <strong>world frame</strong>, if all frames are parallel to other).</p>
<p>This joint aggregation can be used in cases where in reality a rod with spherical joints at end are present. Such a system has an additional degree of freedom to rotate the rod along its axis. In practice this rotation is usually of no interested and is mathematically removed by replacing one of the spherical joints by a universal joint. Still, in most cases the Joints.SphericalSpherical joint aggregation can be used instead of the UniversalSpherical joint since the rod is animated and its mass properties are approximated by a point mass in the middle of the rod. The SphericalSpherical joint has the advantage that it does not have a singular configuration.</p>
<p>In the public interface of the UniversalSpherical joint, the following (final) <strong>parameters</strong> are provided:</p>
<pre><code>parameter Real rodLength(unit=&quot;m&quot;)  &quot;Length of rod&quot;;
parameter Real eRod_ia[3] &quot;Unit vector along rod, resolved in frame_ia&quot;;
parameter Real e2_ia  [3] &quot;Unit vector along axis 2, resolved in frame_ia&quot;;</code></pre>
<p>This allows a more convenient definition of data which is related to the rod. For example, if a box shall be connected at frame_ia directing from the origin of frame_a to the middle of the rod, this might be defined as:</p>
<pre><code>Modelica.Mechanics.MultiBody.Joints.UniversalSpherical jointUS(rRod_ia={1.2, 1, 0.2});
Modelica.Mechanics.MultiBody.Visualizers.FixedShape    shape(shapeType       = &quot;box&quot;,
                                          lengthDirection = jointUS.eRod_ia,
                                          widthDirection  = jointUS.e2_ia,
                                          length          = jointUS.rodLength/2,
                                          width           = jointUS.rodLength/10);</code></pre>
<blockquote>
<dl>
<dt>equation</dt>
<dd><p>connect(jointUS.frame_ia, shape.frame_a);</p>
</dd>
</dl>
</blockquote>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-10">Parameters</h2>
<table>
<col width="28%" />
<col width="5%" />
<col width="9%" />
<col width="56%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">showUniversalAxes</td>
<td align="left">true</td>
<td align="left">= true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">computeRodLength</td>
<td align="left">false</td>
<td align="left">= true, if distance between frame_a and frame_b shall be computed during initialization (see info)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n1_a</td>
<td align="left">{0,0,1}</td>
<td align="left">Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod) [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">rRod_ia[3]</td>
<td align="left">{1,0,0}</td>
<td align="left">Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod) [m]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">sphereDiameter</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Diameter of spheres representing the universal and the spherical joint [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">sphereColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of spheres representing the universal and the spherical joint</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeType">ShapeType</a></td>
<td align="left">rodShapeType</td>
<td align="left">&quot;cylinder&quot;</td>
<td align="left">Shape type of rod connecting the universal and the spherical joint</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">rodWidth</td>
<td align="left">sphereDiameter/Types.Default...</td>
<td align="left">Width of rod shape in direction of axis 2 of universal joint. [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">rodHeight</td>
<td align="left">rodWidth</td>
<td align="left">Height of rod shape in direction that is orthogonal to rod and to axis 2 [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeExtra">ShapeExtra</a></td>
<td align="left">rodExtra</td>
<td align="left">0.0</td>
<td align="left">Additional parameter depending on rodShapeType</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">rodColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of rod shape connecting the universal and the spherical joints</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left">if animation = true and showUniversalAxes</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderLength</td>
<td align="left">world.defaultJointLength</td>
<td align="left">Length of cylinders representing the two universal joint axes [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">world.defaultJointWidth</td>
<td align="left">Diameter of cylinders representing the two universal joint axes [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinders representing the two universal joint axes</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">kinematicConstraint</td>
<td align="left">true</td>
<td align="left">= false, if no constraint shall be defined, due to analytically solving a kinematic loop</td>
</tr>
<tr class="even">
<td align="left">Real</td>
<td align="left">constraintResidue</td>
<td align="left">rRod_0*rRod_0 - rodLength*ro...</td>
<td align="left">Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">checkTotalPower</td>
<td align="left">false</td>
<td align="left">= true, if total power flowing into this component shall be determined (must be zero)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-10">Connectors</h2>
<table>
<col width="46%" />
<col width="5%" />
<col width="48%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_ia</td>
<td align="left">Coordinate system at the origin of frame_a, fixed at the rod connecting the universal with the spherical joint</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>model UniversalSpherical 
  &quot;Universal - spherical joint aggregation (1 constraint, no potential states)&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;

  extends Interfaces.PartialTwoFrames;
  Interfaces.Frame_a frame_ia 
    &quot;Coordinate system at the origin of frame_a, fixed at the rod connecting the universal with the spherical joint&quot;;

  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter Boolean showUniversalAxes=true 
    &quot; = true, if universal joint shall be visualized with two cylinders, otherwise with a sphere (provided animation=true)&quot;;
  parameter Boolean computeRodLength=false 
    &quot;= true, if distance between frame_a and frame_b shall be computed during initialization (see info)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n1_a={0,0,1} 
    &quot;Axis 1 of universal joint resolved in frame_a (axis 2 is orthogonal to axis 1 and to rod)&quot;;
  parameter SI.Position rRod_ia[3]={1,0,0} 
    &quot;Vector from origin of frame_a to origin of frame_b, resolved in frame_ia (if computeRodLength=true, rRod_ia is only an axis vector along the connecting rod)&quot;;
  parameter SI.Diameter sphereDiameter=world.defaultJointLength 
    &quot;Diameter of spheres representing the universal and the spherical joint&quot;;
  input Types.Color sphereColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of spheres representing the universal and the spherical joint&quot;;
  parameter Types.ShapeType rodShapeType=&quot;cylinder&quot; 
    &quot;Shape type of rod connecting the universal and the spherical joint&quot;;
  parameter SI.Distance rodWidth=sphereDiameter/Types.Defaults.JointRodDiameterFraction 
    &quot;Width of rod shape in direction of axis 2 of universal joint.&quot;;
  parameter SI.Distance rodHeight=rodWidth 
    &quot;Height of rod shape in direction that is orthogonal to rod and to axis 2&quot;;
  parameter Types.ShapeExtra rodExtra=0.0 
    &quot;Additional parameter depending on rodShapeType&quot;;
  input Types.Color rodColor=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
    &quot;Color of rod shape connecting the universal and the spherical joints&quot;;
  parameter SI.Distance cylinderLength=world.defaultJointLength 
    &quot;Length of cylinders representing the two universal joint axes&quot;;
  parameter SI.Distance cylinderDiameter=world.defaultJointWidth 
    &quot;Diameter of cylinders representing the two universal joint axes&quot;;
  input Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.JointColor 
    &quot;Color of cylinders representing the two universal joint axes&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  parameter Boolean kinematicConstraint=true 
    &quot;= false, if no constraint shall be defined, due to analytically solving a kinematic loop&quot;;
  Real constraintResidue = rRod_0*rRod_0 - rodLength*rodLength 
    &quot;Constraint equation of joint in residue form: Either length constraint (= default) or equation to compute rod force (for analytic solution of loops in combination with Internal.RevoluteWithLengthConstraint/PrismaticWithLengthConstraint)&quot;;
  parameter Boolean checkTotalPower=false 
    &quot;= true, if total power flowing into this component shall be determined (must be zero)&quot;;
  SI.Force f_rod 
    &quot;Constraint force in direction of the rod (positive, if rod is pressed)&quot;;
  final parameter SI.Distance rodLength(fixed=not computeRodLength)=
    Modelica.Math.Vectors.length(
                  rRod_ia) 
    &quot;Length of rod (distance between origin of frame_a and origin of frame_b)&quot;;
  final parameter Real eRod_ia[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                                   rRod_ia,0.0) 
    &quot;Unit vector from origin of frame_a to origin of frame_b, resolved in frame_ia&quot;;
  final parameter Real e2_ia[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                                 cross(n1_a, eRod_ia)) 
    &quot;Unit vector in direction of axis 2 of universal joint, resolved in frame_ia (orthogonal to n1_a and eRod_ia; note: frame_ia is parallel to frame_a when the universal joint angles are zero)&quot;;
  final parameter Real e3_ia[3](each final unit=&quot;1&quot;)=cross(eRod_ia, e2_ia) 
    &quot;Unit vector perpendicular to eRod_ia and e2_ia, resolved in frame_ia&quot;;
  SI.Power totalPower 
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;;
  SI.Force f_b_a1[3] 
    &quot;frame_b.f without f_rod part, resolved in frame_a (needed for analytic loop handling)&quot;;
  Real eRod_a[3](each final unit=&quot;1&quot;) 
    &quot;Unit vector in direction of rRod_a, resolved in frame_a (needed for analytic loop handling)&quot;;
  SI.Position rRod_0[3](start=rRod_ia) 
    &quot;Position vector from origin of frame_a to origin of frame_b resolved in world frame&quot;;
  SI.Position rRod_a[3](start=rRod_ia) 
    &quot;Position vector from origin of frame_a to origin of frame_b resolved in frame_a&quot;;

protected 
  SI.Force f_b_a[3] &quot;frame_b.f resolved in frame_a&quot;;
  SI.Force f_ia_a[3] &quot;frame_ia.f resolved in frame_a&quot;;
  SI.Torque t_ia_a[3] &quot;frame_ia.t resolved in frame_a&quot;;
  Real n2_a[3](each final unit=&quot;1&quot;) 
    &quot;Vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a&quot;;
  Real length2_n2_a(start=1, unit=&quot;m2&quot;) &quot;Square of length of vector n2_a&quot;;
  SI.Length length_n2_a &quot;Length of vector n2_a&quot;;
  Real e2_a[3](each final unit=&quot;1&quot;) 
    &quot;Unit vector in direction of axis 2 of the universal joint (e2_ia), resolved in frame_a&quot;;
  Real e3_a[3](each final unit=&quot;1&quot;) 
    &quot;Unit vector perpendicular to eRod_ia and e2_a, resolved in frame_a&quot;;
  Real der_rRod_a_L[3](each unit=&quot;1/s&quot;) &quot;= der(rRod_a)/rodLength&quot;;
  SI.AngularVelocity w_rel_ia1[3];
  Frames.Orientation R_rel_ia1;
  Frames.Orientation R_rel_ia2;
  // Real T_rel_ia[3, 3];
  Frames.Orientation R_rel_ia &quot;Rotation from frame_a to frame_ia&quot;;

  Visualizers.Advanced.Shape rodShape(
    shapeType=rodShapeType,
    color=rodColor,
    specularCoefficient=specularCoefficient,
    length=rodLength,
    width=rodWidth,
    height=rodHeight,
    lengthDirection=eRod_ia,
    widthDirection=e2_ia,
    r=frame_ia.r_0,
    R=frame_ia.R) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape sphericalShape_b(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection={1,0,0},
    widthDirection={0,1,0},
    r_shape={-0.5,0,0}*sphereDiameter,
    r=frame_b.r_0,
    R=frame_b.R) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape sphericalShape_a(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection={1,0,0},
    widthDirection={0,1,0},
    r_shape={-0.5,0,0}*sphereDiameter,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation and not showUniversalAxes;
  Visualizers.Advanced.Shape universalShape1(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=cylinderLength,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=n1_a,
    widthDirection={0,1,0},
    r_shape=-n1_a*(cylinderLength/2),
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation and showUniversalAxes;
  Visualizers.Advanced.Shape universalShape2(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=cylinderLength,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=e2_ia,
    widthDirection={0,1,0},
    r_shape=-e2_ia*(cylinderLength/2),
    r=frame_ia.r_0,
    R=frame_ia.R) if world.enableAnimation and animation and showUniversalAxes;

equation 
  Connections.branch(frame_a.R, frame_ia.R);
  if kinematicConstraint then
    rRod_0 = transpose(frame_b.R.T)*(frame_b.R.T*frame_b.r_0) - transpose(
      frame_a.R.T)*(frame_a.R.T*frame_a.r_0);
  else
    rRod_0 = frame_b.r_0 - frame_a.r_0;
  end if;
  //rRod_0 = frame_b.r_0 - frame_a.r_0;
  rRod_a = Frames.resolve2(frame_a.R, rRod_0);

  // Constraint equation
  constraintResidue = 0;

  /* Determine relative Rotation R_rel_ia from frame_a to frame_ia
     and absolute rotation of frame_a.R.
  */
  eRod_a = rRod_a/rodLength;
  n2_a = cross(n1_a, eRod_a);
  length2_n2_a = n2_a*n2_a;

  assert(length2_n2_a &gt; 1.e-10, &quot;
A Modelica.Mechanics.MultiBody.Joints.UniversalSpherical joint (consisting of
a universal joint and a spherical joint connected together
by a rigid rod) is in the singular configuration of the
universal joint. This means that axis 1 of the universal
joint defined via parameter \&quot;n1_a\&quot; is parallel to vector
\&quot;rRod_ia\&quot; that is directed from the origin of frame_a to the
origin of frame_b.
   You may try to use another \&quot;n1_a\&quot; vector. If this fails,
use instead Modelica.Mechanics.MultiBody.Joints.SphericalSpherical, if this is
possible, because this joint aggregation does not have a
singular configuration.
&quot;);

  length_n2_a = sqrt(length2_n2_a);
  e2_a = n2_a/length_n2_a;
  e3_a = cross(eRod_a, e2_a);

  /* The statements below are an efficient implementation of the
   original equations:
     T_rel_ia = [eRod_ia, e2_ia, e3_ia]*transpose([eRod_a, e2_a, e3_a]);
     R_rel_ia = Frames.from_T(T_rel_ia,
                   Frames.TransformationMatrices.angularVelocity2(T_rel_ia, der(T_rel_ia)));
   To perform this, the rotation is split into two parts:
     R_rel_ia : Rotation object from frame_a to frame_ia
     R_rel_ia1: Rotation object from frame_a to frame_ia1
                (frame that is fixed in frame_ia such that x-axis
                is along the rod axis)
                T = transpose([eRod_a, e2_a, e3_a]; w = w_rel_ia1
     R_rel_ia2: Fixed rotation object from frame_ia1 to frame_ia
                T = [eRod_ia, e2_ia, e3_ia]; w = zeros(3)

   The difficult part is to compute w_rel_ia1:
      w_rel_ia1 = [  e3_a*der(e2_a);
                    -e3_a*der(eRod_a);
                     e2_a*der(eRod_a)]
   der(eRod_a) is directly given, since eRod_a is a function
   of translational quantities only.
      der(eRod_a) = (der(rRod_a) - eRod_a*(eRod_a*der(rRod_a)))/rodLength
      der(n2_a)   = cross(n1_a, der(eRod_a))
      der(e2_a)   = (der(n2_a) - e2_a*(e2_a*der(n2_a)))/length_n2_a
   Inserting these equations in w_rel_ia1 results in:
      e3_a*der(eRod_a) = e3_a*der(rRod_a)/rodLength       // e3_a*eRod_a = 0
      e2_a*der(eRod_a) = e2_a*der(rRod_a)/rodLength       // e2_a*eRod_a = 0
      e3_a*der(e2_a)   = e3_a*der(n2_a)/lenght_n2_a       // e3_a*e2_a = 0
                       = e3_a*cross(n1_a, der(eRod_a))/length_n2_a
                       = e3_a*cross(n1_a, der(rRod_a) - eRod_a*(eRod_a*der(rRod_a)))/(length_n2_a*rodLength)
                       = e3_a*cross(n1_a, der(rRod_a))/(length_n2_a*rodLength)
   Furthermore, we have:
     rRod_a            = resolve2(frame_a.R, rRod_0);
     der(rRod_a)       = resolve2(frame_a.R, der(rRod_0)) - cross(frame_a.R.w, rRod_a));
*/
  der_rRod_a_L = (Frames.resolve2(frame_a.R, der(rRod_0)) - cross(frame_a.R.w,
     rRod_a))/rodLength;
  w_rel_ia1 = {e3_a*cross(n1_a, der_rRod_a_L)/length_n2_a,-e3_a*der_rRod_a_L,
    e2_a*der_rRod_a_L};
  R_rel_ia1 = Frames.from_T(transpose([eRod_a, e2_a, e3_a]), w_rel_ia1);
  R_rel_ia2 = Frames.from_T([eRod_ia, e2_ia, e3_ia], zeros(3));
  R_rel_ia = Frames.absoluteRotation(R_rel_ia1, R_rel_ia2);
  /*
  T_rel_ia = [eRod_ia, e2_ia, e3_ia]*transpose([eRod_a, e2_a, e3_a]);
  R_rel_ia = Frames.from_T(T_rel_ia,
    Frames.TransformationMatrices.angularVelocity2(T_rel_ia, der(T_rel_ia)));
*/

  // Compute kinematic quantities of frame_ia
  frame_ia.r_0 = frame_a.r_0;
  frame_ia.R = Frames.absoluteRotation(frame_a.R, R_rel_ia);

  /* In the following formulas f_a, f_b, f_ia, t_a, t_b, t_ia are
     the forces and torques at frame_a, frame_b, frame_ia, respectively,
     resolved in frame_a. e_x, e_y, e_z are the unit vectors resolved in frame_a.
     Torque balance at the rod around the origin of frame_a:
       0 = t_a + t_ia + cross(rRod_a, f_b)
     with
         rRod_a = rodLength*e_x
         f_b     = -f_rod*e_x + f_b[2]*e_y + f_b[3]*e_z
     follows:
       0 = t_a + t_ia + rodLength*(f_b[2]*e_z - f_b[3]*e_y)
     The projection of t_a with respect to universal joint axes vanishes:
       n1_a*t_a = 0
       e_y*t_a = 0
     Therefore:
        0 = n1_a*t_ia + rodLength*f_b[2]*(n1_a*e_z)
        0 = e_y*t_ia - rodLength*f_b[3]
     or
        f_b = -f_rod*e_x - e_y*(n1_a*t_ia)/(rodLength*(n1_a*e_z)) + e_z*(e_y*t_ia)/rodLength
     Force balance:
        0 = f_a + f_b + f_ia
  */
  f_ia_a = Frames.resolve1(R_rel_ia, frame_ia.f);
  t_ia_a = Frames.resolve1(R_rel_ia, frame_ia.t);

    // f_b_a1 is needed in aggregation joints to solve kinematic loops analytically
  f_b_a1 = -e2_a*((n1_a*t_ia_a)/(rodLength*(n1_a*e3_a))) + e3_a*((e2_a*t_ia_a)
    /rodLength);
  f_b_a = -f_rod*eRod_a + f_b_a1;
  frame_b.f = Frames.resolveRelative(f_b_a, frame_a.R, frame_b.R);
  frame_b.t = zeros(3);
  zeros(3) = frame_a.f + f_b_a + f_ia_a;
  zeros(3) = frame_a.t + t_ia_a + cross(rRod_a, f_b_a);

  // Measure power for test purposes
  if checkTotalPower then
    totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
      frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) + frame_ia.f*
      Frames.resolve2(frame_ia.R, der(frame_ia.r_0)) + frame_a.t*
      Frames.angularVelocity2(frame_a.R) + frame_b.t*Frames.angularVelocity2(
      frame_b.R) + frame_ia.t*Frames.angularVelocity2(frame_ia.R);
  else
    totalPower = 0;
  end if;
end UniversalSpherical;</code></pre>
<hr />
<h1 id="image52-modelica.mechanics.multibody.joints.gearconstraint"><img src="Modelica.Mechanics.MultiBody.Joints.GearConstraintI.png" alt="image52" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.GearConstraint</h1>
<p><strong>Ideal 3-dim. gearbox (arbitrary shaft directions)</strong></p>
<h2 id="information-12">Information</h2>
<p>::</p>
<p>This ideal massless joint provides a gear constraint between frames <code>frame_a</code> and <code>frame_b</code>. The axes of rotation of <code>frame_a</code> and <code>frame_b</code> may be arbitrary.</p>
<dl>
<dt><strong>Reference</strong></dt>
<dd><p>Schweiger, Christian ; Otter, Martin: `Modelling 3D Mechanical Effects</p>
</dd>
</dl>
<p>of 1-dim. Powertrains &lt;<a href="http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf">http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf</a>&gt;`_. In: <em>Proceedings of the 3rd International Modelica Conference</em>. Linköping : The Modelica Association and Linköping University, November 3-4, 2003, pp. 149-158</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames">Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames</a> (Base model for components providing two frame connectors + outer world + assert to guarantee that the component is connected).</p>
<h2 id="parameters-11">Parameters</h2>
<table>
<col width="46%" />
<col width="5%" />
<col width="5%" />
<col width="42%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">ratio</td>
<td align="left">
</td>
<td align="left">Gear speed ratio</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_a</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation of shaft a (same coordinates in frame_a, frame_b, bearing) [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_b</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation of shaft b (same coordinates in frame_a, frame_b, bearing) [1]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_a[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame bearing to frame_a resolved in bearing [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_b[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame bearing to frame_b resolved in bearing [m]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-11">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">bearing</td>
<td align="left">Coordinate system fixed in the bearing</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>model GearConstraint 
  &quot;Ideal 3-dim. gearbox (arbitrary shaft directions)&quot;
  extends Modelica.Mechanics.MultiBody.Interfaces.PartialTwoFrames;
  Interfaces.Frame_a bearing &quot;Coordinate system fixed in the bearing&quot;;

  parameter Real ratio(start=2) &quot;Gear speed ratio&quot;;

  parameter Modelica.Mechanics.MultiBody.Types.Axis n_a={1,0,0} 
    &quot;Axis of rotation of shaft a (same coordinates in frame_a, frame_b, bearing)&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n_b={1,0,0} 
    &quot;Axis of rotation of shaft b (same coordinates in frame_a, frame_b, bearing)&quot;;

  parameter Modelica.SIunits.Position r_a[3]={0,0,0} 
    &quot;Vector from frame bearing to frame_a resolved in bearing&quot;;
  parameter Modelica.SIunits.Position r_b[3]={0,0,0} 
    &quot;Vector from frame bearing to frame_b resolved in bearing&quot;;

  Modelica.Mechanics.MultiBody.Joints.Revolute actuatedRevolute_a(useAxisFlange=true, n=n_a, animation=false);
  Modelica.Mechanics.MultiBody.Joints.Revolute actuatedRevolute_b(useAxisFlange=true,n=n_b, animation=false);
  Modelica.Mechanics.Rotational.Components.IdealGear idealGear(
                                                    ratio=ratio);
  Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation1(animation=false, r=r_b);
  Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation2(animation=false, r=r_a);
equation 
  assert(cardinality(bearing) &gt; 0,
    &quot;Connector bearing of component is not connected&quot;);

  connect(actuatedRevolute_a.axis, idealGear.flange_a);
  connect(idealGear.flange_b, actuatedRevolute_b.axis);
  connect(actuatedRevolute_a.frame_a,fixedTranslation2. frame_b);
  connect(fixedTranslation2.frame_a, bearing);
  connect(fixedTranslation1.frame_a, bearing);
  connect(fixedTranslation1.frame_b, actuatedRevolute_b.frame_a);
  connect(frame_a, actuatedRevolute_a.frame_b);
  connect(actuatedRevolute_b.frame_b, frame_b);
end GearConstraint;</code></pre>
<hr />
<h1 id="image53-modelica.mechanics.multibody.joints.rollingwheel"><img src="Modelica.Mechanics.MultiBody.Joints.RollingWheelI.png" alt="image53" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.RollingWheel</h1>
<p><strong>Joint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane z=0)</strong></p>
<h2 id="parameters-12">Parameters</h2>
<table>
<col width="39%" />
<col width="12%" />
<col width="11%" />
<col width="37%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Radius">Radius</a></td>
<td align="left">wheelRadius</td>
<td align="left">
</td>
<td align="left">Wheel radius [m]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.always</td>
<td align="left">Priority to use generalized coordinates as states</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Angles to rotate world-frame in to frame_a around z-, y-, x-axis [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">der_angles.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Derivative of angles [rad/s]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-12">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Frame fixed in wheel center point. x-Axis: upwards, y-axis: along wheel axis</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-12">Modelica definition</h2>
<pre><code>model RollingWheel 
  &quot;Joint (no mass, no inertia) that describes an ideal rolling wheel (rolling on the plane z=0)&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Frames;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
    &quot;Frame fixed in wheel center point. x-Axis: upwards, y-axis: along wheel axis&quot;;

  parameter SI.Radius wheelRadius &quot;Wheel radius&quot;;
  parameter StateSelect stateSelect=StateSelect.always 
    &quot;Priority to use generalized coordinates as states&quot;;

  SI.Position x(start=0, stateSelect=stateSelect) &quot;x-coordinate of wheel axis&quot;;

  SI.Position y(start=0, stateSelect=stateSelect) &quot;y-coordinate of wheel axis&quot;;
  SI.Position z;

  SI.Angle angles[3](start={0,0,0}, each stateSelect=stateSelect) 
    &quot;Angles to rotate world-frame in to frame_a around z-, y-, x-axis&quot;;

  SI.AngularVelocity der_angles[3](start={0,0,0}, each stateSelect=stateSelect) 
    &quot;Derivative of angles&quot;;

   SI.Position r_road_0[3] 
    &quot;Position vector from world frame to contact point on road, resolved in world frame&quot;;

  // Contact force
  SI.Force f_wheel_0[3] 
    &quot;Contact force acting on wheel, resolved in world frame&quot;;
  SI.Force f_n &quot;Contact force acting on wheel in normal direction&quot;;
  SI.Force f_lat &quot;Contact force acting on wheel in lateral direction&quot;;
  SI.Force f_long &quot;Contact force acting on wheel in longitudinal direction&quot;;
  SI.Position err 
    &quot;|r_road_0 - frame_a.r_0| - wheelRadius (must be zero; used for checking)&quot;;
protected 
   Real e_axis_0[3] &quot;Unit vector along wheel axis, resolved in world frame&quot;;
   SI.Position delta_0[3](start={0,0,-wheelRadius}) 
    &quot;Distance vector from wheel center to contact point&quot;;

   // Coordinate system at contact point
   Real e_n_0[3] 
    &quot;Unit vector in normal direction of road at contact point, resolved in world frame&quot;;
   Real e_lat_0[3] 
    &quot;Unit vector in lateral direction of wheel at contact point, resolved in world frame&quot;;
   Real e_long_0[3] 
    &quot;Unit vector in longitudinal direction of wheel at contact point, resolved in world frame&quot;;

   // Road description
   SI.Position s &quot;Road surface parameter 1&quot;;
   SI.Position w &quot;Road surface parameter 2&quot;;
   Real e_s_0[3] &quot;Road heading at (s,w), resolved in world frame (unit vector)&quot;;

   // Slip velocities
   SI.Velocity v_0[3] &quot;Velocity of wheel center, resolved in world frame&quot;;
   SI.AngularVelocity w_0[3] 
    &quot;Angular velocity of wheel, resolved in world frame&quot;;

   SI.Velocity vContact_0[3] 
    &quot;Velocity of wheel contact point, resolved in world frame&quot;;

   // Utility vectors
   Real aux[3];

equation 
   // frame_a.R is computed from generalized coordinates
   Connections.root(frame_a.R);
   frame_a.r_0 = {x,y,z};
   der_angles  = der(angles);
   frame_a.R = Frames.axesRotations({3,2,1}, angles, der_angles);

   // Road description
   r_road_0 = {s,w,0};
   e_n_0    = {0,0,1};
   e_s_0    = {1,0,0};

   // Coordinate system at contact point (e_long_0, e_lat_0, e_n_0)
   e_axis_0  = Frames.resolve1(frame_a.R, {0,1,0});
   aux       = cross(e_n_0, e_axis_0);
   e_long_0 = aux / Modelica.Math.Vectors.length(aux);
   e_lat_0  = cross(e_long_0, e_n_0);

   // Determine point on road where the wheel is in contact with the road
   delta_0 = r_road_0 - frame_a.r_0;
   0 = delta_0*e_axis_0;
   0 = delta_0*e_long_0;

   // One holonomic positional constraint equation (no penetration in to the ground)
   0 = wheelRadius - delta_0*cross(e_long_0, e_axis_0);

   // only for testing
   err = Modelica.Math.Vectors.length(delta_0) - wheelRadius;

   // Slip velocities
   v_0 = der(frame_a.r_0);
   w_0 = Frames.angularVelocity1(frame_a.R);
   vContact_0 = v_0 + cross(w_0, delta_0);

   // Two non-holonomic constraint equations on velocity level (ideal rolling, no slippage)
   0 = vContact_0*e_long_0;
   0 = vContact_0*e_lat_0;

   // Contact force
   f_wheel_0 = f_n*e_n_0 + f_lat*e_lat_0 + f_long*e_long_0;

   // Force and torque balance at the wheel center
   zeros(3) = frame_a.f + Frames.resolve2(frame_a.R, f_wheel_0);
   zeros(3) = frame_a.t + Frames.resolve2(frame_a.R, cross(delta_0, f_wheel_0));

   // Guard against singularity
   assert(abs(e_n_0*e_axis_0) &lt; 0.99, &quot;Wheel lays nearly on the ground (which is a singularity)&quot;);
end RollingWheel;</code></pre>
<hr />
<h1 id="image54-modelica.mechanics.multibody.joints.rollingwheelset"><img src="Modelica.Mechanics.MultiBody.Joints.RollingWheelSetI.png" alt="image54" /> <a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints">Modelica.Mechanics.MultiBody.Joints</a>.RollingWheelSet</h1>
<p><strong>Joint (no mass, no inertia) that describes an ideal rolling wheel set (two ideal rolling wheels connected together by an axis)</strong></p>
<h2 id="parameters-13">Parameters</h2>
<table>
<col width="39%" />
<col width="10%" />
<col width="14%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation of wheel set shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Radius">Radius</a></td>
<td align="left">wheelRadius</td>
<td align="left">
</td>
<td align="left">Radius of one wheel [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">wheelDistance</td>
<td align="left">
</td>
<td align="left">Distance between the two wheels [m]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.default</td>
<td align="left">Priority to use the generalized coordinates as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-13">Connectors</h2>
<table>
<col width="49%" />
<col width="6%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frameMiddle</td>
<td align="left">Frame fixed in middle of axis connecting both wheels (y-axis: along wheel axis, z-Axis: upwards)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame1</td>
<td align="left">Frame fixed in center point of left wheel (y-axis: along wheel axis, z-Axis: upwards)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame2</td>
<td align="left">Frame fixed in center point of right wheel (y-axis: along wheel axis, z-Axis: upwards)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">axis1</td>
<td align="left">1-dim. rotational flange that drives the joint</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">axis2</td>
<td align="left">1-dim. rotational flange that drives the joint</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">support</td>
<td align="left">Support of 1D axes</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-13">Modelica definition</h2>
<pre><code>model RollingWheelSet 
  &quot;Joint (no mass, no inertia) that describes an ideal rolling wheel set (two ideal rolling wheels connected together by an axis)&quot;
  import SI = Modelica.SIunits;
 Modelica.Mechanics.MultiBody.Interfaces.Frame_a frameMiddle 
    &quot;Frame fixed in middle of axis connecting both wheels (y-axis: along wheel axis, z-Axis: upwards)&quot;;


  parameter Boolean animation=true 
    &quot;= true, if animation of wheel set shall be enabled&quot;;

  parameter SI.Radius wheelRadius &quot;Radius of one wheel&quot;;
  parameter SI.Distance wheelDistance &quot;Distance between the two wheels&quot;;

  parameter StateSelect stateSelect = StateSelect.default 
    &quot;Priority to use the generalized coordinates as states&quot;;

  Modelica.SIunits.Position x(start=0, stateSelect=stateSelect) 
    &quot;x coordinate for center between wheels&quot;;
  Modelica.SIunits.Position y(start=0, stateSelect=stateSelect) 
    &quot;y coordinate for center between wheels&quot;;
  Modelica.SIunits.Angle phi(start=0, stateSelect=stateSelect) 
    &quot;Orientation angle of wheel axis along z-axis&quot;;
  Modelica.SIunits.Angle theta1(start=0, stateSelect=stateSelect) 
    &quot;Angle of wheel 1&quot;;
  Modelica.SIunits.Angle theta2(start=0, stateSelect=stateSelect) 
    &quot;Angle of wheel 2&quot;;
  Modelica.SIunits.AngularVelocity der_theta1(start=0, stateSelect=stateSelect) 
    &quot;Derivative of theta 1&quot;;
  Modelica.SIunits.AngularVelocity der_theta2(start=0, stateSelect=stateSelect) 
    &quot;Derivative of theta 2&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame1 
    &quot;Frame fixed in center point of left wheel (y-axis: along wheel axis, z-Axis: upwards)&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame2 
    &quot;Frame fixed in center point of right wheel (y-axis: along wheel axis, z-Axis: upwards)&quot;;
  Modelica.Mechanics.MultiBody.Parts.Fixed fixed(                 r={0,0,
        wheelRadius}, animation=animation);
  Modelica.Mechanics.MultiBody.Parts.FixedTranslation rod1(                 r={
        0,wheelDistance/2,0}, animation=animation);
  Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic1(animation=
        animation);
  Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic2(
    n={0,1,0}, animation=animation);
  Modelica.Mechanics.MultiBody.Joints.Revolute revolute(animation=animation);
  Modelica.Mechanics.MultiBody.Parts.FixedTranslation rod2(                 r={
        0,-wheelDistance/2,0}, animation=animation);
  Modelica.Mechanics.MultiBody.Joints.Revolute revolute1(
    n={0,1,0},
    useAxisFlange=true,
    animation=animation);
  Modelica.Mechanics.MultiBody.Joints.Revolute revolute2(
    n={0,1,0},
    useAxisFlange=true,
    animation=animation);
  Modelica.Mechanics.MultiBody.Joints.Internal.RollingConstraintVerticalWheel
  rolling1(                             radius=wheelRadius);
  Modelica.Mechanics.MultiBody.Joints.Internal.RollingConstraintVerticalWheel
  rolling2(                             radius=wheelRadius,
      lateralSlidingConstraint=false);
  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis1 
    &quot;1-dim. rotational flange that drives the joint&quot;;
  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis2 
    &quot;1-dim. rotational flange that drives the joint&quot;;
  Modelica.Mechanics.MultiBody.Parts.Mounting1D mounting1D;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b support 
    &quot;Support of 1D axes&quot;;
equation 
  prismatic1.s  = x;
  prismatic2.s  = y;
  revolute.phi  = phi;
  revolute1.phi = theta1;
  revolute2.phi = theta2;
  der_theta1 = der(theta1);
  der_theta2 = der(theta2);

  connect(revolute.frame_b, frameMiddle);
  connect(rod1.frame_a, frameMiddle);
  connect(rod2.frame_a, frameMiddle);
  connect(rod1.frame_b, revolute1.frame_a);
  connect(revolute1.frame_b, frame1);
  connect(revolute2.frame_a, rod2.frame_b);
  connect(revolute2.frame_b, frame2);
  connect(prismatic1.frame_a, fixed.frame_b);
  connect(prismatic1.frame_b, prismatic2.frame_a);
  connect(prismatic2.frame_b, revolute.frame_a);
  connect(rolling1.frame_a, revolute1.frame_b);
  connect(rolling2.frame_a, revolute2.frame_b);
  connect(revolute1.axis, axis1);
  connect(revolute2.axis, axis2);
  connect(frameMiddle, mounting1D.frame_a);
  connect(mounting1D.flange_b, support);
end RollingWheelSet;</code></pre>
<hr />
<h1 id="modelica.mechanics.multibody.joints.freemotionscalarinit.model_r"><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.FreeMotionScalarInit">Modelica.Mechanics.MultiBody.Joints.FreeMotionScalarInit</a>.Model_r</h1>
<h2 id="modelica-definition-14">Modelica definition</h2>
<pre><code>encapsulated model Model_r
  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Frames;
   input SI.Position r_a_0[3];
   input SI.Position r_b_0[3];
   input Frames.Orientation R_a;
   output SI.Position r_rel_a_1;
   output SI.Position r_rel_a_2;
   output SI.Position r_rel_a_3;
equation 
   r_b_0 = r_a_0 + Frames.resolve1(R_a, {r_rel_a_1, r_rel_a_2, r_rel_a_3});
end Model_r;</code></pre>
<hr />
<h1 id="modelica.mechanics.multibody.joints.freemotionscalarinit.model_w"><a href="Modelica_Mechanics_MultiBody_Joints.html#Modelica.Mechanics.MultiBody.Joints.FreeMotionScalarInit">Modelica.Mechanics.MultiBody.Joints.FreeMotionScalarInit</a>.Model_w</h1>
<h2 id="modelica-definition-15">Modelica definition</h2>
<pre><code>encapsulated model Model_w
  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Frames;
   input Frames.Orientation R_a;
   input Frames.Orientation R_b;
   output SI.AngularVelocity w_rel_b_1;
   output SI.AngularVelocity w_rel_b_2;
   output SI.AngularVelocity w_rel_b_3;
equation 
   {w_rel_b_1, w_rel_b_2, w_rel_b_3} = Frames.angularVelocity2(R_b)
                                       - Frames.resolve2(R_b,Frames.angularVelocity1(R_a));
end Model_w;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:30:30 2010.</p>
</body>
</html>
