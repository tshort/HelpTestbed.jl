<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Modelica.Mechanics.MultiBody.Parts</title>
</head>
<body>
<div id="header">
<h1 class="title">Modelica.Mechanics.MultiBody.Parts</h1>
</div>
<h1 id="modelica.mechanics.multibody.parts"><a href="Modelica_Mechanics_MultiBody.html#Modelica.Mechanics.MultiBody">Modelica.Mechanics.MultiBody</a>.Parts</h1>
<p><strong>Rigid components such as bodies with mass and inertia and massless rods</strong></p>
<h2 id="information">Information</h2>
<p>::</p>
<p>Package <strong>Parts</strong> contains <strong>rigid components</strong> of a multi-body system. These components may be used to build up more complicated structures. For example, a part may be built up of a &quot;Body&quot; and of several &quot;FixedTranslation&quot; components.</p>
<h3 id="content">Content</h3>
<table>
<col width="37%" />
<col width="62%" />
<thead>
<tr class="header">
<th align="left"><strong><em>Model</em></strong></th>
<th align="left"><strong><em>Description</em></strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Fixed">Fixed</a></td>
<td align="left"><dl>
<dt>Frame fixed in world frame at a given position. It is visualized with a shape, see <strong>shapeType</strong> below (the frames on the two sides do not belong to the component):</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Fixed.png" alt="image9" /><p class="caption">image9</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.FixedTranslation">FixedTranslation</a></td>
<td align="left"><dl>
<dt>Fixed translation of frame_b with respect to frame_a. It is visualized with a shape, see <strong>shapeType</strong> below (the frames on the two sides do not belong to the component):</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/FixedTranslation.png" alt="image10" /><p class="caption">image10</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.FixedRotation">FixedRotation</a></td>
<td align="left"><dl>
<dt>Fixed translation and fixed rotation of frame_b with respect to frame_a It is visualized with a shape, see <strong>shapeType</strong> below (the frames on the two sides do not belong to the component):</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/FixedRotation.png" alt="image11" /><p class="caption">image11</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Body">Body</a></td>
<td align="left"><dl>
<dt>Rigid body with mass, inertia tensor and one frame connector. It is visualized with a cylinder and a sphere at the center of mass:</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Body.png" alt="image12" /><p class="caption">image12</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BodyShape">BodyShape</a></td>
<td align="left"><dl>
<dt>Rigid body with mass, inertia tensor, different shapes (see <strong>shapeType</strong> below) for animation, and two frame connectors:</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/BodyShape.png" alt="image13" /><p class="caption">image13</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Fixed">Fixed BodyBox</a></td>
<td align="left"><dl>
<dt>Rigid body with box shape (mass and animation properties are computed from box data and from density):</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/BodyBox.png" alt="image14" /><p class="caption">image14</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BodyCylinder">BodyCylinder</a></td>
<td align="left"><dl>
<dt>Rigid body with cylinder shape (mass and animation properties are computed from cylinder data and from density):</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/BodyCylinder.png" alt="image15" /><p class="caption">image15</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.PointMass">PointMass</a></td>
<td align="left"><dl>
<dt>Rigid body where inertia tensor and rotation is neglected:</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Parts/PointMass.png" alt="image16" /><p class="caption">image16</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Mounting1D">Mounting1D</a></td>
<td align="left">Propagate 1-dim. support torque to 3-dim. system</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Rotor1D">Rotor1D</a></td>
<td align="left"><dl>
<dt>1D inertia attachable on 3-dim. bodies (without neglecting dynamic effects)</dt>
<dd><div class="figure">
<img src="../Resources/Images/MultiBody/Parts/Rotor1D.png" alt="image17" /><p class="caption">image17</p>
</div>
</dd>
</dl></td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BevelGear1D">BevelGear1D</a></td>
<td align="left">1D gearbox with arbitrary shaft directions (3D bearing frame)</td>
</tr>
</tbody>
</table>
<p>Components <strong>Fixed</strong>, <strong>FixedTranslation</strong>, <strong>FixedRotation</strong> and <strong>BodyShape</strong> are visualized according to parameter <strong>shapeType</strong>, that may have the following values (e.g., shapeType = &quot;box&quot;):</p>
<p>All the details of the visualization shape parameters are given in <a href="Modelica_Mechanics_MultiBody_Visualizers.html#Modelica.Mechanics.MultiBody.Visualizers.FixedShape">Visualizers.FixedShape</a></p>
<p>Colors in all animation parts are defined via parameter <strong>color</strong>. This is an Integer vector with 3 elements, {r, g, b}, and specifies the color of the shape. {r,g,b} are the &quot;red&quot;, &quot;green&quot; and &quot;blue&quot; color parts, given in the ranges 0 .. 255, respectively. The predefined type <strong>MultiBody.Types.Color</strong> contains a menu definition of the colors used in the MultiBody library (this will be replaced by a color editor).</p>
<p>::</p>
<p>Extends from <a href="Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).</p>
<h2 id="package-content">Package Content</h2>
<table>
<col width="52%" />
<col width="47%" />
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.FixedS.png" alt="image31" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Fixed">Fixed</a></td>
<td align="left">Frame fixed in the world frame at a given position</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.FixedTranslationS.png" alt="image32" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.FixedTranslation">FixedTranslation</a></td>
<td align="left">Fixed translation of frame_b with respect to frame_a</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.FixedRotationS.png" alt="image33" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.FixedRotation">FixedRotation</a></td>
<td align="left">Fixed translation followed by a fixed rotation of frame_b with respect to frame_a</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.BodyS.png" alt="image34" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Body">Body</a></td>
<td align="left">Rigid body with mass, inertia tensor and one frame connector (12 potential states)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.BodyShapeS.png" alt="image35" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BodyShape">BodyShape</a></td>
<td align="left">Rigid body with mass, inertia tensor, different shapes for animation, and two frame connectors (12 potential states)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.BodyBoxS.png" alt="image36" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BodyBox">BodyBox</a></td>
<td align="left">Rigid body with box shape. Mass and animation properties are computed from box data and density (12 potential states)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.BodyCylinderS.png" alt="image37" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BodyCylinder">BodyCylinder</a></td>
<td align="left">Rigid body with cylinder shape. Mass and animation properties are computed from cylinder data and density (12 potential states)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.PointMassS.png" alt="image38" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.PointMass">PointMass</a></td>
<td align="left">Rigid body where body rotation and inertia tensor is neglected (6 potential states)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.Mounting1DS.png" alt="image39" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Mounting1D">Mounting1D</a></td>
<td align="left">Propagate 1-dim. support torque to 3-dim. system (provided world.driveTrainMechanics3D=true)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.Rotor1DS.png" alt="image40" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Rotor1D">Rotor1D</a></td>
<td align="left">1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account if world.driveTrainMechanics3D=true)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.BevelGear1DS.png" alt="image41" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BevelGear1D">BevelGear1D</a></td>
<td align="left">1D gearbox with arbitrary shaft directions and 3-dim. bearing frame (3D dynamic effects are taken into account provided world.driveTrainMechanics3D=true)</td>
</tr>
<tr class="even">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.RollingWheelS.png" alt="image42" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.RollingWheel">RollingWheel</a></td>
<td align="left">Ideal rolling wheel on flat surface z=0 (5 positional, 3 velocity degrees of freedom)</td>
</tr>
<tr class="odd">
<td align="left"><img src="Modelica.Mechanics.MultiBody.Parts.RollingWheelSetS.png" alt="image43" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.RollingWheelSet">RollingWheelSet</a></td>
<td align="left">Ideal rolling wheel set consisting of two ideal rolling wheels connected together by an axis</td>
</tr>
</tbody>
</table>
<hr />
<h1 id="image44-modelica.mechanics.multibody.parts.fixed"><img src="Modelica.Mechanics.MultiBody.Parts.FixedI.png" alt="image44" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.Fixed</h1>
<p><strong>Frame fixed in the world frame at a given position</strong></p>
<h2 id="information-1">Information</h2>
<p>::</p>
<p>Element consisting of a frame (frame_b) that is fixed in the world frame at a given position defined by parameter vector <strong>r</strong> (vector from origin of world frame to frame_b, resolved in the world frame).</p>
<p>By default, this component is visualized by a cylinder connecting the world frame and frame_b of this components, as shown in the figure below. Note, that the visualized world frame on the left side and Fixed.frame_b on the right side are not part of the component animation and that the animation may be switched off via parameter animation = <strong>false</strong>.</p>
<p>::</p>
<h2 id="parameters">Parameters</h2>
<table>
<col width="45%" />
<col width="8%" />
<col width="13%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Position vector from world frame to frame_b, resolved in world frame [m]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeType">ShapeType</a></td>
<td align="left">shapeType</td>
<td align="left">&quot;cylinder&quot;</td>
<td align="left">Type of shape</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_shape[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from world frame to shape origin, resolved in world frame [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">lengthDirection[3]</td>
<td align="left">r - r_shape</td>
<td align="left">Vector in length direction of shape, resolved in world frame [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">widthDirection[3]</td>
<td align="left">{0,1,0}</td>
<td align="left">Vector in width direction of shape, resolved in world frame [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">length</td>
<td align="left">Modelica.Math.Vectors.length...</td>
<td align="left">Length of shape [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">length/world.defaultWidthFra...</td>
<td align="left">Width of shape [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">height</td>
<td align="left">width</td>
<td align="left">Height of shape [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeExtra">ShapeExtra</a></td>
<td align="left">extra</td>
<td align="left">0.0</td>
<td align="left">Additional parameter for cone, pipe etc. (see docu of Visualizers.Advanced.Shape)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of shape</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors">Connectors</h2>
<table>
<col width="64%" />
<col width="7%" />
<col width="27%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed in the world frame</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition">Modelica definition</h2>
<pre><code>model Fixed &quot;Frame fixed in the world frame at a given position&quot;
  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;

  Interfaces.Frame_b frame_b &quot;Coordinate system fixed in the world frame&quot;;

  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter SI.Position r[3]={0,0,0} 
    &quot;Position vector from world frame to frame_b, resolved in world frame&quot;;
  parameter Types.ShapeType shapeType=&quot;cylinder&quot; &quot; Type of shape&quot;;
  parameter SI.Position r_shape[3]={0,0,0} 
    &quot; Vector from world frame to shape origin, resolved in world frame&quot;;
  parameter SI.Position lengthDirection[3]=r - r_shape 
    &quot; Vector in length direction of shape, resolved in world frame&quot;;
  parameter SI.Position widthDirection[3]={0,1,0} 
    &quot; Vector in width direction of shape, resolved in world frame&quot;;
  parameter SI.Length length=Modelica.Math.Vectors.length(
                                           r - r_shape) &quot; Length of shape&quot;;
  parameter SI.Distance width=length/world.defaultWidthFraction 
    &quot; Width of shape&quot;;
  parameter SI.Distance height=width &quot; Height of shape&quot;;
  parameter Types.ShapeExtra extra=0.0 
    &quot; Additional parameter for cone, pipe etc. (see docu of Visualizers.Advanced.Shape)&quot;;
  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
    &quot; Color of shape&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  outer Modelica.Mechanics.MultiBody.World world;
  Visualizers.Advanced.Shape shape(
    shapeType=shapeType,
    color=color,
    specularCoefficient=specularCoefficient,
    length=length,
    width=width,
    height=height,
    lengthDirection=lengthDirection,
    widthDirection=widthDirection,
    extra=extra,
    r_shape=r_shape,
    r=zeros(3),
    R=Frames.nullRotation()) if world.enableAnimation and animation;
equation 
  Connections.root(frame_b.R);
  frame_b.r_0 = r;
  frame_b.R = Frames.nullRotation();
end Fixed;</code></pre>
<hr />
<h1 id="image45-modelica.mechanics.multibody.parts.fixedtranslation"><img src="Modelica.Mechanics.MultiBody.Parts.FixedTranslationI.png" alt="image45" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.FixedTranslation</h1>
<p><strong>Fixed translation of frame_b with respect to frame_a</strong></p>
<h2 id="information-2">Information</h2>
<p>::</p>
<p>Component for a <strong>fixed translation</strong> of frame_b with respect to frame_a, i.e., the relationship between connectors frame_a and frame_b remains constant and frame_a is always <strong>parallel</strong> to frame_b.</p>
<p>By default, this component is visualized by a cylinder connecting frame_a and frame_b, as shown in the figure below. Note, that the two visualized frames are not part of the component animation and that the animation may be switched off via parameter animation = <strong>false</strong>.</p>
<p>::</p>
<h2 id="parameters-1">Parameters</h2>
<table>
<col width="45%" />
<col width="8%" />
<col width="13%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r[3]</td>
<td align="left">
</td>
<td align="left">Vector from frame_a to frame_b resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeType">ShapeType</a></td>
<td align="left">shapeType</td>
<td align="left">&quot;cylinder&quot;</td>
<td align="left">Type of shape</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_shape[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame_a to shape origin, resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">lengthDirection</td>
<td align="left">r - r_shape</td>
<td align="left">Vector in length direction of shape, resolved in frame_a [1]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">widthDirection</td>
<td align="left">{0,1,0}</td>
<td align="left">Vector in width direction of shape, resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">length</td>
<td align="left">Modelica.Math.Vectors.length...</td>
<td align="left">Length of shape [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">length/world.defaultWidthFra...</td>
<td align="left">Width of shape [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">height</td>
<td align="left">width</td>
<td align="left">Height of shape. [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeExtra">ShapeExtra</a></td>
<td align="left">extra</td>
<td align="left">0.0</td>
<td align="left">Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of shape</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-1">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-1">Modelica definition</h2>
<pre><code>model FixedTranslation 
  &quot;Fixed translation of frame_b with respect to frame_a&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;
  Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;
  Interfaces.Frame_b frame_b 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;

  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter SI.Position r[3](start={0,0,0}) 
    &quot;Vector from frame_a to frame_b resolved in frame_a&quot;;
  parameter Types.ShapeType shapeType=&quot;cylinder&quot; &quot; Type of shape&quot;;
  parameter SI.Position r_shape[3]={0,0,0} 
    &quot; Vector from frame_a to shape origin, resolved in frame_a&quot;;
  parameter Types.Axis lengthDirection=r - r_shape 
    &quot; Vector in length direction of shape, resolved in frame_a&quot;;
  parameter Types.Axis widthDirection={0,1,0} 
    &quot; Vector in width direction of shape, resolved in frame_a&quot;;
  parameter SI.Length length=Modelica.Math.Vectors.length(
                                           r - r_shape) &quot; Length of shape&quot;;
  parameter SI.Distance width=length/world.defaultWidthFraction 
    &quot; Width of shape&quot;;
  parameter SI.Distance height=width &quot; Height of shape.&quot;;
  parameter Types.ShapeExtra extra=0.0 
    &quot; Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).&quot;;
  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
    &quot; Color of shape&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

protected 
  outer Modelica.Mechanics.MultiBody.World world;
  Visualizers.Advanced.Shape shape(
    shapeType=shapeType,
    color=color,
    specularCoefficient=specularCoefficient,
    r_shape=r_shape,
    lengthDirection=lengthDirection,
    widthDirection=widthDirection,
    length=length,
    width=width,
    height=height,
    extra=extra,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
equation 
  Connections.branch(frame_a.R, frame_b.R);
  assert(cardinality(frame_a) &gt; 0 or cardinality(frame_b) &gt; 0,
    &quot;Neither connector frame_a nor frame_b of FixedTranslation object is connected&quot;);

  frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r);
  frame_b.R = frame_a.R;

  /* Force and torque balance */
  zeros(3) = frame_a.f + frame_b.f;
  zeros(3) = frame_a.t + frame_b.t + cross(r, frame_b.f);
end FixedTranslation;</code></pre>
<hr />
<h1 id="image46-modelica.mechanics.multibody.parts.fixedrotation"><img src="Modelica.Mechanics.MultiBody.Parts.FixedRotationI.png" alt="image46" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.FixedRotation</h1>
<p><strong>Fixed translation followed by a fixed rotation of frame_b with respect to frame_a</strong></p>
<h2 id="information-3">Information</h2>
<p>::</p>
<p>Component for a <strong>fixed translation</strong> and <strong>fixed rotation</strong> of frame_b with respect to frame_a, i.e., the relationship between connectors frame_a and frame_b remains constant. There are several possibilities to define the orientation of frame_b with respect to frame_a:</p>
<ul>
<li><strong>Planar rotation</strong> along axis 'n' (that is fixed and resolved in frame_a) with a fixed angle 'angle'.</li>
<li><strong>Vectors n_x</strong> and <strong>n_y</strong> that are directed along the corresponding axes direction of frame_b and are resolved in frame_a (if n_y is not orthogonal to n_x, the y-axis of frame_b is selected such that it is orthogonal to n_x and in the plane of n_x and n_y).</li>
<li><strong>Sequence</strong> of <strong>three planar axes rotations</strong>. For example, &quot;sequence = {1,2,3}&quot; and &quot;angles = {90, 45, -90}&quot; means to rotate frame_a around the x axis with 90 degrees, around the new y axis with 45 degrees and around the new z axis around -90 degrees to arrive at frame_b. Note, that sequence={1,2,3} is the Cardan angle sequence and sequence = {3,1,3} is the Euler angle sequence.</li>
</ul>
<p>By default, this component is visualized by a cylinder connecting frame_a and frame_b, as shown in the figure below. In this figure frame_b is rotated along the z-axis of frame_a with 60 degree. Note, that the two visualized frames are not part of the component animation and that the animation may be switched off via parameter animation = <strong>false</strong>.</p>
<p>::</p>
<h2 id="parameters-2">Parameters</h2>
<table>
<col width="45%" />
<col width="8%" />
<col width="13%" />
<col width="32%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame_a to frame_b resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationTypes">RotationTypes</a></td>
<td align="left">rotationType</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Type of rotation description</td>
</tr>
<tr class="even">
<td align="left">if rotationType = RotationAxis</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation in frame_a (= same as in frame_b) [1]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits_Conversions_NonSIunits.html#Modelica.SIunits.Conversions.NonSIunits.Angle_deg">Angle_deg</a></td>
<td align="left">angle</td>
<td align="left">0</td>
<td align="left">Angle to rotate frame_a around axis n into frame_b [deg]</td>
</tr>
<tr class="odd">
<td align="left">if rotationType = TwoAxesVectors</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_x</td>
<td align="left">{1,0,0}</td>
<td align="left">Vector along x-axis of frame_b resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_y</td>
<td align="left">{0,1,0}</td>
<td align="left">Vector along y-axis of frame_b resolved in frame_a [1]</td>
</tr>
<tr class="even">
<td align="left">if rotationType = PlanarRotationSequence</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits_Conversions_NonSIunits.html#Modelica.SIunits.Conversions.NonSIunits.Angle_deg">Angle_deg</a></td>
<td align="left">angles[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Rotation angles around the axes defined in 'sequence' [deg]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeType">ShapeType</a></td>
<td align="left">shapeType</td>
<td align="left">&quot;cylinder&quot;</td>
<td align="left">Type of shape</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_shape[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame_a to shape origin, resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">lengthDirection</td>
<td align="left">r - r_shape</td>
<td align="left">Vector in length direction of shape, resolved in frame_a [1]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">widthDirection</td>
<td align="left">{0,1,0}</td>
<td align="left">Vector in width direction of shape, resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">length</td>
<td align="left">Modelica.Math.Vectors.length...</td>
<td align="left">Length of shape [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">length/world.defaultWidthFra...</td>
<td align="left">Width of shape [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">height</td>
<td align="left">width</td>
<td align="left">Height of shape. [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeExtra">ShapeExtra</a></td>
<td align="left">extra</td>
<td align="left">0.0</td>
<td align="left">Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of shape</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
</tbody>
</table>
<h2 id="connectors-2">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-2">Modelica definition</h2>
<pre><code>model FixedRotation 
  &quot;Fixed translation followed by a fixed rotation of frame_b with respect to frame_a&quot;

  import Modelica.Mechanics.MultiBody.Frames;
  import Modelica.Mechanics.MultiBody.Types;
  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;
  Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;
  Interfaces.Frame_b frame_b 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;

  parameter Boolean animation=true &quot;= true, if animation shall be enabled&quot;;
  parameter SI.Position r[3]={0,0,0} 
    &quot;Vector from frame_a to frame_b resolved in frame_a&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.RotationTypes rotationType=
            Modelica.Mechanics.MultiBody.Types.RotationTypes.RotationAxis 
    &quot;Type of rotation description&quot;;
  parameter Types.Axis n={1,0,0} 
    &quot; Axis of rotation in frame_a (= same as in frame_b)&quot;;
  parameter Cv.NonSIunits.Angle_deg angle=0 
    &quot; Angle to rotate frame_a around axis n into frame_b&quot;;

  parameter Types.Axis n_x={1,0,0} 
    &quot; Vector along x-axis of frame_b resolved in frame_a&quot;;
  parameter Types.Axis n_y={0,1,0} 
    &quot; Vector along y-axis of frame_b resolved in frame_a&quot;;

  parameter Types.RotationSequence sequence(
    min={1,1,1},
    max={3,3,3}) = {1,2,3} &quot; Sequence of rotations&quot;;
  parameter Cv.NonSIunits.Angle_deg angles[3]={0,0,0} 
    &quot; Rotation angles around the axes defined in &#39;sequence&#39;&quot;;
  parameter Types.ShapeType shapeType=&quot;cylinder&quot; &quot; Type of shape&quot;;
  parameter SI.Position r_shape[3]={0,0,0} 
    &quot; Vector from frame_a to shape origin, resolved in frame_a&quot;;
  parameter Types.Axis lengthDirection=r - r_shape 
    &quot; Vector in length direction of shape, resolved in frame_a&quot;;
  parameter Types.Axis widthDirection={0,1,0} 
    &quot; Vector in width direction of shape, resolved in frame_a&quot;;
  parameter SI.Length length=Modelica.Math.Vectors.length(
                                           r - r_shape) &quot; Length of shape&quot;;
  parameter SI.Distance width=length/world.defaultWidthFraction 
    &quot; Width of shape&quot;;
  parameter SI.Distance height=width &quot; Height of shape.&quot;;
  parameter Types.ShapeExtra extra=0.0 
    &quot; Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).&quot;;
/*
  parameter Boolean checkTotalPower=false
    &quot;= true, if total power flowing into this component shall be determined (must be zero)&quot;
    annotation (Dialog(tab=&quot;Advanced&quot;));
*/

  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
    &quot; Color of shape&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  final parameter Frames.Orientation R_rel=if rotationType == 1 then 
      Frames.planarRotation(Modelica.Math.Vectors.normalize(
                                             n,0.0), Cv.from_deg(angle), 0) else 
      if rotationType == 2 then Frames.from_nxy(n_x, n_y) else 
      Frames.axesRotations(sequence, Cv.from_deg(angles), zeros(3)) 
    &quot;Fixed rotation object from frame_a to frame_b&quot;;
/*
  SI.Power totalPower
    &quot;Total power flowing into this element, if checkTotalPower=true (otherwise dummy)&quot;;
*/
protected 
  outer Modelica.Mechanics.MultiBody.World world;

  /*
  parameter Frames.Orientation R_rel_inv=
      Frames.inverseRotation(R_rel)
*/
  parameter Frames.Orientation R_rel_inv=Frames.from_T(transpose(R_rel.T),
      zeros(3)) &quot;Inverse of R_rel (rotate from frame_b to frame_a)&quot;;
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape shape(
    shapeType=shapeType,
    color=color,
    specularCoefficient=specularCoefficient,
    r_shape=r_shape,
    lengthDirection=lengthDirection,
    widthDirection=widthDirection,
    length=length,
    width=width,
    height=height,
    extra=extra,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;

equation 
  Connections.branch(frame_a.R, frame_b.R);
  assert(cardinality(frame_a) &gt; 0 or cardinality(frame_b) &gt; 0,
    &quot;Neither connector frame_a nor frame_b of FixedRotation object is connected&quot;);

  /* Relationships between quantities of frame_a and frame_b */
  frame_b.r_0 = frame_a.r_0 + Frames.resolve1(frame_a.R, r);
  if rooted(frame_a.R) then
    frame_b.R = Frames.absoluteRotation(frame_a.R, R_rel);
    zeros(3) = frame_a.f + Frames.resolve1(R_rel, frame_b.f);
    zeros(3) = frame_a.t + Frames.resolve1(R_rel, frame_b.t) - cross(r, frame_a.f);
  else
    frame_a.R = Frames.absoluteRotation(frame_b.R, R_rel_inv);
    zeros(3) = frame_b.f + Frames.resolve1(R_rel_inv, frame_a.f);
    zeros(3) = frame_b.t + Frames.resolve1(R_rel_inv, frame_a.t) + cross(Frames.resolve1(R_rel_inv,r), frame_b.f);
  end if;

/*
  if checkTotalPower then
    totalPower = frame_a.f*Frames.resolve2(frame_a.R, der(frame_a.r_0)) +
                 frame_b.f*Frames.resolve2(frame_b.R, der(frame_b.r_0)) +
                 frame_a.t*Frames.angularVelocity2(frame_a.R) +
                 frame_b.t*Frames.angularVelocity2(frame_b.R);
  else
    totalPower = 0;
  end if;
*/
end FixedRotation;</code></pre>
<hr />
<h1 id="image47-modelica.mechanics.multibody.parts.body"><img src="Modelica.Mechanics.MultiBody.Parts.BodyI.png" alt="image47" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.Body</h1>
<p><strong>Rigid body with mass, inertia tensor and one frame connector (12 potential states)</strong></p>
<h2 id="information-4">Information</h2>
<p>::</p>
<p><strong>Rigid body</strong> with mass and inertia tensor. All parameter vectors have to be resolved in frame_a. The <strong>inertia tensor</strong> has to be defined with respect to a coordinate system that is parallel to frame_a with the origin at the center of mass of the body.</p>
<p>By default, this component is visualized by a <strong>cylinder</strong> located between frame_a and the center of mass and by a <strong>sphere</strong> that has its center at the center of mass. If the cylinder length is smaller as the radius of the sphere, e.g., since frame_a is located at the center of mass, the cylinder is not displayed. Note, that the animation may be switched off via parameter animation = <strong>false</strong>.</p>
<p><strong>States of Body Components</strong></p>
<p>Every body has potential states. If possible a tool will select the states of joints and not the states of bodies because this is usually the most efficient choice. In this case the position, orientation, velocity and angular velocity of frame_a of the body will be computed by the component that is connected to frame_a. However, if a body is moving freely in space, variables of the body have to be used as states. The potential states of the body are:</p>
<ul>
<li>The <strong>position vector</strong> frame_a.r_0 from the origin of the world frame to the origin of frame_a of the body, resolved in the world frame and the <strong>absolute velocity</strong> v_0 of the origin of frame_a, resolved in the world frame (= der(frame_a.r_0)).</li>
<li>If parameter <strong>useQuaternions</strong> in the &quot;Advanced&quot; menu is <strong>true</strong> (this is the default), then <strong>4 quaternions</strong> are potential states. Additionally, the coordinates of the absolute angular velocity vector of the body are 3 potential states. If <strong>useQuaternions</strong> in the &quot;Advanced&quot; menu is <strong>false</strong>, then <strong>3 angles</strong> and the derivatives of these angles are potential states. The orientation of frame_a is computed by rotating the world frame along the axes defined in parameter vector &quot;sequence_angleStates&quot; (default = {1,2,3}, i.e., the Cardan angle sequence) around the angles used as potential states. For example, the default is to rotate the x-axis of the world frame around angles[1], the new y-axis around angles[2] and the new z-axis around angles[3], arriving at frame_a.</li>
</ul>
<p>The quaternions have the slight disadvantage that there is a non-linear constraint equation between the 4 quaternions. Therefore, at least one non-linear equation has to be solved during simulation. A tool might, however, analytically solve this simple constraint equation. Using the 3 angles as states has the disadvantage that there is a singular configuration in which a division by zero will occur. If it is possible to determine in advance for an application class that this singular configuration is outside of the operating region, the 3 angles might be used as potential states by setting <strong>useQuaternions</strong> = <strong>false</strong>.</p>
<p>In text books about 3-dimensional mechanics often 3 angles and the angular velocity are used as states. This is not the case here, since 3 angles and their derivatives are used as potential states (if useQuaternions = false). The reason is that for real-time simulation the discretization formula of the integrator might be &quot;inlined&quot; and solved together with the body equations. By appropriate symbolic transformation the performance is drastically increased if angles and their derivatives are used as states, instead of angles and the angular velocity.</p>
<p>Whether or not variables of the body are used as states is usually automatically selected by the Modelica translator. If parameter <strong>enforceStates</strong> is set to <strong>true</strong> in the &quot;Advanced&quot; menu, then body variables are forced to be used as states according to the setting of parameters &quot;useQuaternions&quot; and &quot;sequence_angleStates&quot;.</p>
<p>::</p>
<h2 id="parameters-3">Parameters</h2>
<table>
<col width="42%" />
<col width="8%" />
<col width="12%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show cylinder and sphere)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_CM[3]</td>
<td align="left">
</td>
<td align="left">Vector from frame_a to center of mass, resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m</td>
<td align="left">
</td>
<td align="left">Mass of rigid body [kg]</td>
</tr>
<tr class="even">
<td align="left">Inertia tensor (resolved in center of mass, parallel to frame_a)</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_11</td>
<td align="left">0.001</td>
<td align="left">(1,1) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_22</td>
<td align="left">0.001</td>
<td align="left">(2,2) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_33</td>
<td align="left">0.001</td>
<td align="left">(3,3) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_21</td>
<td align="left">0</td>
<td align="left">(2,1) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_31</td>
<td align="left">0</td>
<td align="left">(3,1) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_32</td>
<td align="left">0</td>
<td align="left">(3,2) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Position vector from origin of world frame to origin of frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute velocity of frame_a, resolved in world frame (= der(r_0)) [m/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute acceleration of frame_a resolved in world frame (= der(v_0)) [m/s2]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">angles_fixed</td>
<td align="left">false</td>
<td align="left">= true, if angles_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_start</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b at initial time</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">w_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if w_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial or guess values of angular velocity of frame_a resolved in world frame [rad/s]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">z_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if z_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular acceleration z_0 = der(w_0) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">sphereDiameter</td>
<td align="left">world.defaultBodyDiameter</td>
<td align="left">Diameter of sphere [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">sphereColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of sphere</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">sphereDiameter/Types.Default...</td>
<td align="left">Diameter of cylinder [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">sphereColor</td>
<td align="left">Color of cylinder</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">enforceStates</td>
<td align="left">false</td>
<td align="left">= true, if absolute variables of body object shall be used as states (StateSelect.always)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useQuaternions</td>
<td align="left">true</td>
<td align="left">= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_angleStates</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-3">Connectors</h2>
<table>
<col width="69%" />
<col width="8%" />
<col width="22%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed at body</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-3">Modelica definition</h2>
<pre><code>model Body 
  &quot;Rigid body with mass, inertia tensor and one frame connector (12 potential states)&quot;

  import SI = Modelica.SIunits;
  import C = Modelica.Constants;
  import Modelica.Math.*;
  import Modelica.Mechanics.MultiBody.Types;
  import Modelica.Mechanics.MultiBody.Frames;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed at body&quot;;
  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show cylinder and sphere)&quot;;
  parameter SI.Position r_CM[3](start={0,0,0}) 
    &quot;Vector from frame_a to center of mass, resolved in frame_a&quot;;
  parameter SI.Mass m(min=0, start = 1) &quot;Mass of rigid body&quot;;
  parameter SI.Inertia I_11(min=0) = 0.001 &quot; (1,1) element of inertia tensor&quot;;
  parameter SI.Inertia I_22(min=0) = 0.001 &quot; (2,2) element of inertia tensor&quot;;
  parameter SI.Inertia I_33(min=0) = 0.001 &quot; (3,3) element of inertia tensor&quot;;
  parameter SI.Inertia I_21(min=-C.inf)=0 &quot; (2,1) element of inertia tensor&quot;;
  parameter SI.Inertia I_31(min=-C.inf)=0 &quot; (3,1) element of inertia tensor&quot;;
  parameter SI.Inertia I_32(min=-C.inf)=0 &quot; (3,2) element of inertia tensor&quot;;

  SI.Position r_0[3](start={0,0,0}, each stateSelect=if enforceStates then 
              StateSelect.always else StateSelect.avoid) 
    &quot;Position vector from origin of world frame to origin of frame_a&quot;;
  SI.Velocity v_0[3](start={0,0,0}, each stateSelect=if enforceStates then StateSelect.always else 
              StateSelect.avoid) 
    &quot;Absolute velocity of frame_a, resolved in world frame (= der(r_0))&quot;;
  SI.Acceleration a_0[3](start={0,0,0}) 
    &quot;Absolute acceleration of frame_a resolved in world frame (= der(v_0))&quot;;

  parameter Boolean angles_fixed = false 
    &quot;= true, if angles_start are used as initial values, else as guess values&quot;;
  parameter SI.Angle angles_start[3]={0,0,0} 
    &quot;Initial values of angles to rotate frame_a around &#39;sequence_start&#39; axes into frame_b&quot;;
  parameter Types.RotationSequence sequence_start={1,2,3} 
    &quot;Sequence of rotations to rotate frame_a into frame_b at initial time&quot;;

  parameter Boolean w_0_fixed = false 
    &quot;= true, if w_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularVelocity w_0_start[3]={0,0,0} 
    &quot;Initial or guess values of angular velocity of frame_a resolved in world frame&quot;;

  parameter Boolean z_0_fixed = false 
    &quot;= true, if z_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularAcceleration z_0_start[3]={0,0,0} 
    &quot;Initial values of angular acceleration z_0 = der(w_0)&quot;;

  parameter SI.Diameter sphereDiameter=world.defaultBodyDiameter 
    &quot;Diameter of sphere&quot;;
  input Types.Color sphereColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot;Color of sphere&quot;;
  parameter SI.Diameter cylinderDiameter=sphereDiameter/Types.Defaults.
      BodyCylinderDiameterFraction &quot;Diameter of cylinder&quot;;
  input Types.Color cylinderColor=sphereColor &quot;Color of cylinder&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter Boolean enforceStates=false 
    &quot; = true, if absolute variables of body object shall be used as states (StateSelect.always)&quot;;
  parameter Boolean useQuaternions=true 
    &quot; = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states&quot;;
  parameter Types.RotationSequence sequence_angleStates={1,2,3} 
    &quot; Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states&quot;;

  final parameter SI.Inertia I[3, 3]=[I_11, I_21, I_31; I_21, I_22, I_32;
      I_31, I_32, I_33] &quot;inertia tensor&quot;;
  final parameter Frames.Orientation R_start=Modelica.Mechanics.MultiBody.Frames.axesRotations(
      sequence_start, angles_start, zeros(3)) 
    &quot;Orientation object from world frame to frame_a at initial time&quot;;
  final parameter SI.AngularAcceleration z_a_start[3]=Frames.resolve2(R_start, z_0_start) 
    &quot;Initial values of angular acceleration z_a = der(w_a), i.e., time derivative of angular velocity resolved in frame_a&quot;;

  SI.AngularVelocity w_a[3](start=Frames.resolve2(R_start, w_0_start),
                            fixed=fill(w_0_fixed,3),
                            each stateSelect=if enforceStates then (if useQuaternions then 
                            StateSelect.always else StateSelect.never) else StateSelect.avoid) 
    &quot;Absolute angular velocity of frame_a resolved in frame_a&quot;;
  SI.AngularAcceleration z_a[3](start=Frames.resolve2(R_start, z_0_start),fixed=fill(z_0_fixed,3)) 
    &quot;Absolute angular acceleration of frame_a resolved in frame_a&quot;;
  SI.Acceleration g_0[3] &quot;Gravity acceleration resolved in world frame&quot;;

protected 
  outer Modelica.Mechanics.MultiBody.World world;

  // Declarations for quaternions (dummies, if quaternions are not used)
  parameter Frames.Quaternions.Orientation Q_start=Frames.to_Q(R_start) 
    &quot;Quaternion orientation object from world frame to frame_a at initial time&quot;;
  Frames.Quaternions.Orientation Q(start=Q_start, each stateSelect=if 
        enforceStates then (if useQuaternions then StateSelect.prefer else 
        StateSelect.never) else StateSelect.avoid) 
    &quot;Quaternion orientation object from world frame to frame_a (dummy value, if quaternions are not used as states)&quot;;

  // Declaration for 3 angles
  parameter SI.Angle phi_start[3]=if sequence_start[1] ==
      sequence_angleStates[1] and sequence_start[2] == sequence_angleStates[2]
       and sequence_start[3] == sequence_angleStates[3] then angles_start else 
       Frames.axesRotationsAngles(R_start, sequence_angleStates) 
    &quot;Potential angle states at initial time&quot;;
  SI.Angle phi[3](start=phi_start, each stateSelect=if enforceStates then (if 
        useQuaternions then StateSelect.never else StateSelect.always) else 
        StateSelect.avoid) 
    &quot;Dummy or 3 angles to rotate world frame into frame_a of body&quot;;
  SI.AngularVelocity phi_d[3](each stateSelect=if enforceStates then (if 
        useQuaternions then StateSelect.never else StateSelect.always) else 
        StateSelect.avoid) &quot;= der(phi)&quot;;
  SI.AngularAcceleration phi_dd[3] &quot;= der(phi_d)&quot;;

  // Declarations for animation
  Visualizers.Advanced.Shape cylinder(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=if Modelica.Math.Vectors.length(r_CM) &gt; sphereDiameter/2 then 
              Modelica.Math.Vectors.length(r_CM) - (if cylinderDiameter &gt; 1.1*
        sphereDiameter then sphereDiameter/2 else 0) else 0,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=r_CM,
    widthDirection={0,1,0},
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape sphere(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection={1,0,0},
    widthDirection={0,1,0},
    r_shape=r_CM - {1,0,0}*sphereDiameter/2,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation and sphereDiameter &gt; 0;
initial equation 
  if angles_fixed then
    // Initialize positional variables
    if not Connections.isRoot(frame_a.R) then
      // frame_a.R is computed somewhere else
      zeros(3) = Frames.Orientation.equalityConstraint(frame_a.R, R_start);
    elseif useQuaternions then
      // frame_a.R is computed from quaternions Q
      zeros(3) = Frames.Quaternions.Orientation.equalityConstraint(Q, Q_start);
    else
      // frame_a.R is computed from the 3 angles &#39;phi&#39;
      phi = phi_start;
    end if;
  end if;

equation 
  if enforceStates then
    Connections.root(frame_a.R);
  else
    Connections.potentialRoot(frame_a.R);
  end if;
  r_0 = frame_a.r_0;

  if not Connections.isRoot(frame_a.R) then
    // Body does not have states
    // Dummies
    Q = {0,0,0,1};
    phi = zeros(3);
    phi_d = zeros(3);
    phi_dd = zeros(3);
  elseif useQuaternions then
    // Use Quaternions as states (with dynamic state selection)
    frame_a.R = Frames.from_Q(Q, Frames.Quaternions.angularVelocity2(Q, der(Q)));
    {0} = Frames.Quaternions.orientationConstraint(Q);

    // Dummies
    phi = zeros(3);
    phi_d = zeros(3);
    phi_dd = zeros(3);
  else
    // Use Cardan angles as states
    phi_d = der(phi);
    phi_dd = der(phi_d);
    frame_a.R = Frames.axesRotations(sequence_angleStates, phi, phi_d);

    // Dummies
    Q = {0,0,0,1};
  end if;

  // gravity acceleration at center of mass resolved in world frame
  g_0 = world.gravityAcceleration(frame_a.r_0 + Frames.resolve1(frame_a.R,
    r_CM));

  // translational kinematic differential equations
  v_0 = der(frame_a.r_0);
  a_0 = der(v_0);

  // rotational kinematic differential equations
  w_a = Frames.angularVelocity2(frame_a.R);
  z_a = der(w_a);

  /* Newton/Euler equations with respect to center of mass
            a_CM = a_a + cross(z_a, r_CM) + cross(w_a, cross(w_a, r_CM));
            f_CM = m*(a_CM - g_a);
            t_CM = I*z_a + cross(w_a, I*w_a);
       frame_a.f = f_CM
       frame_a.t = t_CM + cross(r_CM, f_CM);
    Inserting the first three equations in the last two results in:
  */
  frame_a.f = m*(Frames.resolve2(frame_a.R, a_0 - g_0) + cross(z_a, r_CM) +
    cross(w_a, cross(w_a, r_CM)));
  frame_a.t = I*z_a + cross(w_a, I*w_a) + cross(r_CM, frame_a.f);
end Body;</code></pre>
<hr />
<h1 id="image48-modelica.mechanics.multibody.parts.bodyshape"><img src="Modelica.Mechanics.MultiBody.Parts.BodyShapeI.png" alt="image48" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.BodyShape</h1>
<p><strong>Rigid body with mass, inertia tensor, different shapes for animation, and two frame connectors (12 potential states)</strong></p>
<h2 id="information-5">Information</h2>
<p>::</p>
<p><strong>Rigid body</strong> with mass and inertia tensor and <strong>two frame connectors</strong>. All parameter vectors have to be resolved in frame_a. The <strong>inertia tensor</strong> has to be defined with respect to a coordinate system that is parallel to frame_a with the origin at the center of mass of the body. The coordinate system <strong>frame_b</strong> is always parallel to <strong>frame_a</strong>.</p>
<p>By default, this component is visualized by any <strong>shape</strong> that can be defined with Modelica.Mechanics.MultiBody.Visualizers.FixedShape. This shape is placed between frame_a and frame_b (default: length(shape) = Frames.length(r)). Additionally a <strong>sphere</strong> may be visualized that has its center at the center of mass. Note, that the animation may be switched off via parameter animation = <strong>false</strong>.</p>
<p>The following shapes can be defined via parameter <strong>shapeType</strong>, e.g., shapeType=&quot;cone&quot;:</p>
<p>A BodyShape component has potential states. For details of these states and of the &quot;Advanced&quot; menu parameters, see model <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Body">MultiBody.Parts.Body</a>.</p>
<p>::</p>
<h2 id="parameters-4">Parameters</h2>
<table>
<col width="39%" />
<col width="8%" />
<col width="11%" />
<col width="41%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">animateSphere</td>
<td align="left">true</td>
<td align="left">= true, if mass shall be animated as sphere provided animation=true</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r[3]</td>
<td align="left">
</td>
<td align="left">Vector from frame_a to frame_b resolved in frame_a [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_CM[3]</td>
<td align="left">
</td>
<td align="left">Vector from frame_a to center of mass, resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m</td>
<td align="left">
</td>
<td align="left">Mass of rigid body [kg]</td>
</tr>
<tr class="even">
<td align="left">Inertia tensor (resolved in center of mass, parallel to frame_a)</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_11</td>
<td align="left">0.001</td>
<td align="left">(1,1) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_22</td>
<td align="left">0.001</td>
<td align="left">(2,2) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_33</td>
<td align="left">0.001</td>
<td align="left">(3,3) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_21</td>
<td align="left">0</td>
<td align="left">(2,1) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_31</td>
<td align="left">0</td>
<td align="left">(3,1) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">I_32</td>
<td align="left">0</td>
<td align="left">(3,2) element of inertia tensor [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Position vector from origin of world frame to origin of frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute velocity of frame_a, resolved in world frame (= der(r_0)) [m/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute acceleration of frame_a resolved in world frame (= der(v_0)) [m/s2]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">angles_fixed</td>
<td align="left">false</td>
<td align="left">= true, if angles_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_start</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b at initial time</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">w_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if w_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial or guess values of angular velocity of frame_a resolved in world frame [rad/s]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">z_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if z_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular acceleration z_0 = der(w_0) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeType">ShapeType</a></td>
<td align="left">shapeType</td>
<td align="left">&quot;cylinder&quot;</td>
<td align="left">Type of shape</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_shape[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame_a to shape origin, resolved in frame_a [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">lengthDirection</td>
<td align="left">r - r_shape</td>
<td align="left">Vector in length direction of shape, resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">widthDirection</td>
<td align="left">{0,1,0}</td>
<td align="left">Vector in width direction of shape, resolved in frame_a [1]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">length</td>
<td align="left">Modelica.Math.Vectors.length...</td>
<td align="left">Length of shape [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">length/world.defaultWidthFra...</td>
<td align="left">Width of shape [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">height</td>
<td align="left">width</td>
<td align="left">Height of shape. [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.ShapeExtra">ShapeExtra</a></td>
<td align="left">extra</td>
<td align="left">0.0</td>
<td align="left">Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of shape</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left">if animation = true and animateSphere = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">sphereDiameter</td>
<td align="left">2*width</td>
<td align="left">Diameter of sphere [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">sphereColor</td>
<td align="left">color</td>
<td align="left">Color of sphere of mass</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">enforceStates</td>
<td align="left">false</td>
<td align="left">= true, if absolute variables of body object shall be used as states (StateSelect.always)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useQuaternions</td>
<td align="left">true</td>
<td align="left">= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_angleStates</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-4">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-4">Modelica definition</h2>
<pre><code>model BodyShape 
  &quot;Rigid body with mass, inertia tensor, different shapes for animation, and two frame connectors (12 potential states)&quot;

  import SI = Modelica.SIunits;
  import C = Modelica.Constants;
  import Modelica.Mechanics.MultiBody.Types;

  Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;
  Interfaces.Frame_b frame_b 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show shape between frame_a and frame_b and optionally a sphere at the center of mass)&quot;;
  parameter Boolean animateSphere=true 
    &quot;= true, if mass shall be animated as sphere provided animation=true&quot;;
  parameter SI.Position r[3](start={0,0,0}) 
    &quot;Vector from frame_a to frame_b resolved in frame_a&quot;;
  parameter SI.Position r_CM[3](start={0,0,0}) 
    &quot;Vector from frame_a to center of mass, resolved in frame_a&quot;;
  parameter SI.Mass m(min=0, start = 1) &quot;Mass of rigid body&quot;;
  parameter SI.Inertia I_11(min=0) = 0.001 &quot; (1,1) element of inertia tensor&quot;;
  parameter SI.Inertia I_22(min=0) = 0.001 &quot; (2,2) element of inertia tensor&quot;;
  parameter SI.Inertia I_33(min=0) = 0.001 &quot; (3,3) element of inertia tensor&quot;;
  parameter SI.Inertia I_21(min=-C.inf) = 0 &quot; (2,1) element of inertia tensor&quot;;
  parameter SI.Inertia I_31(min=-C.inf) = 0 &quot; (3,1) element of inertia tensor&quot;;
  parameter SI.Inertia I_32(min=-C.inf) = 0 &quot; (3,2) element of inertia tensor&quot;;

  SI.Position r_0[3](start={0,0,0}, each stateSelect=if enforceStates then 
              StateSelect.always else StateSelect.avoid) 
    &quot;Position vector from origin of world frame to origin of frame_a&quot;;
  SI.Velocity v_0[3](start={0,0,0}, each stateSelect=if enforceStates then StateSelect.always else 
              StateSelect.avoid) 
    &quot;Absolute velocity of frame_a, resolved in world frame (= der(r_0))&quot;;
  SI.Acceleration a_0[3](start={0,0,0}) 
    &quot;Absolute acceleration of frame_a resolved in world frame (= der(v_0))&quot;;

  parameter Boolean angles_fixed = false 
    &quot;= true, if angles_start are used as initial values, else as guess values&quot;;
  parameter SI.Angle angles_start[3]={0,0,0} 
    &quot;Initial values of angles to rotate frame_a around &#39;sequence_start&#39; axes into frame_b&quot;;
  parameter Types.RotationSequence sequence_start={1,2,3} 
    &quot;Sequence of rotations to rotate frame_a into frame_b at initial time&quot;;

  parameter Boolean w_0_fixed = false 
    &quot;= true, if w_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularVelocity w_0_start[3]={0,0,0} 
    &quot;Initial or guess values of angular velocity of frame_a resolved in world frame&quot;;

  parameter Boolean z_0_fixed = false 
    &quot;= true, if z_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularAcceleration z_0_start[3]={0,0,0} 
    &quot;Initial values of angular acceleration z_0 = der(w_0)&quot;;

  parameter Types.ShapeType shapeType=&quot;cylinder&quot; &quot; Type of shape&quot;;
  parameter SI.Position r_shape[3]={0,0,0} 
    &quot; Vector from frame_a to shape origin, resolved in frame_a&quot;;
  parameter Types.Axis lengthDirection=r - r_shape 
    &quot; Vector in length direction of shape, resolved in frame_a&quot;;
  parameter Types.Axis widthDirection={0,1,0} 
    &quot; Vector in width direction of shape, resolved in frame_a&quot;;
  parameter SI.Length length=Modelica.Math.Vectors.length(
                                           r - r_shape) &quot; Length of shape&quot;;
  parameter SI.Distance width=length/world.defaultWidthFraction 
    &quot; Width of shape&quot;;
  parameter SI.Distance height=width &quot; Height of shape.&quot;;
  parameter Types.ShapeExtra extra=0.0 
    &quot; Additional parameter depending on shapeType (see docu of Visualizers.Advanced.Shape).&quot;;
  input Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot; Color of shape&quot;;
  parameter SI.Diameter sphereDiameter=2*width &quot; Diameter of sphere&quot;;
  input Types.Color sphereColor=color &quot; Color of sphere of mass&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter Boolean enforceStates=false 
    &quot; = true, if absolute variables of body object shall be used as states (StateSelect.always)&quot;;
  parameter Boolean useQuaternions=true 
    &quot; = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states&quot;;
  parameter Types.RotationSequence sequence_angleStates={1,2,3} 
    &quot; Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states&quot;;

  FixedTranslation frameTranslation(r=r, animation=false);
  Body body(
    r_CM=r_CM,
    m=m,
    I_11=I_11,
    I_22=I_22,
    I_33=I_33,
    I_21=I_21,
    I_31=I_31,
    I_32=I_32,
    animation=false,
    sequence_start=sequence_start,
    angles_fixed=angles_fixed,
    angles_start=angles_start,
    w_0_fixed=w_0_fixed,
    w_0_start=w_0_start,
    z_0_fixed=z_0_fixed,
    z_0_start=z_0_start,
    useQuaternions=useQuaternions,
    sequence_angleStates=sequence_angleStates,
    enforceStates=false);
protected 
  outer Modelica.Mechanics.MultiBody.World world;
  Visualizers.Advanced.Shape shape1(
    shapeType=shapeType,
    color=color,
    specularCoefficient=specularCoefficient,
    length=length,
    width=width,
    height=height,
    lengthDirection=lengthDirection,
    widthDirection=widthDirection,
    r_shape=r_shape,
    extra=extra,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
  Visualizers.Advanced.Shape shape2(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection={1,0,0},
    widthDirection={0,1,0},
    r_shape=r_CM - {1,0,0}*sphereDiameter/2,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation and animateSphere;
equation 
  r_0 = frame_a.r_0;
  v_0 = der(r_0);
  a_0 = der(v_0);
  connect(frame_a, frameTranslation.frame_a);
  connect(frame_b, frameTranslation.frame_b);
  connect(frame_a, body.frame_a);
end BodyShape;</code></pre>
<hr />
<h1 id="image49-modelica.mechanics.multibody.parts.bodybox"><img src="Modelica.Mechanics.MultiBody.Parts.BodyBoxI.png" alt="image49" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.BodyBox</h1>
<p><strong>Rigid body with box shape. Mass and animation properties are computed from box data and density (12 potential states)</strong></p>
<h2 id="information-6">Information</h2>
<p>::</p>
<p><strong>Rigid body</strong> with <strong>box</strong> shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the box data. Optionally, the box may be hollow. The (outer) box shape is by default used in the animation. The hollow part is not shown in the animation. The two connector frames <strong>frame_a</strong> and <strong>frame_b</strong> are always parallel to each other. Example of component animation (note, that the animation may be switched off via parameter animation = <strong>false</strong>):</p>
<p>A BodyBox component has potential states. For details of these states and of the &quot;Advanced&quot; menu parameters, see model <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Body">MultiBody.Parts.Body</a>.</p>
<p>::</p>
<h2 id="parameters-5">Parameters</h2>
<table>
<col width="42%" />
<col width="8%" />
<col width="12%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show box between frame_a and frame_b)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r[3]</td>
<td align="left">
</td>
<td align="left">Vector from frame_a to frame_b resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_shape[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame_a to box origin, resolved in frame_a [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">lengthDirection</td>
<td align="left">r - r_shape</td>
<td align="left">Vector in length direction of box, resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">widthDirection</td>
<td align="left">{0,1,0}</td>
<td align="left">Vector in width direction of box, resolved in frame_a [1]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">length</td>
<td align="left">Modelica.Math.Vectors.length...</td>
<td align="left">Length of box [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">length/world.defaultWidthFra...</td>
<td align="left">Width of box [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">height</td>
<td align="left">width</td>
<td align="left">Height of box [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">innerWidth</td>
<td align="left">0</td>
<td align="left">Width of inner box surface (0 &lt;= innerWidth &lt;= width) [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">innerHeight</td>
<td align="left">innerWidth</td>
<td align="left">Height of inner box surface (0 &lt;= innerHeight &lt;= height) [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Density">Density</a></td>
<td align="left">density</td>
<td align="left">7700</td>
<td align="left">Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800) [kg/m3]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of box</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Position vector from origin of world frame to origin of frame_a [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute velocity of frame_a, resolved in world frame (= der(r_0)) [m/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute acceleration of frame_a resolved in world frame (= der(v_0)) [m/s2]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">angles_fixed</td>
<td align="left">false</td>
<td align="left">= true, if angles_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_start</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b at initial time</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">w_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if w_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial or guess values of angular velocity of frame_a resolved in world frame [rad/s]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">z_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if z_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular acceleration z_0 = der(w_0) [rad/s2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">enforceStates</td>
<td align="left">false</td>
<td align="left">= true, if absolute variables of body object shall be used as states (StateSelect.always)</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">useQuaternions</td>
<td align="left">true</td>
<td align="left">= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_angleStates</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-5">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-5">Modelica definition</h2>
<pre><code>model BodyBox 
  &quot;Rigid body with box shape. Mass and animation properties are computed from box data and density (12 potential states)&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;

  Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;
  Interfaces.Frame_b frame_b 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;
  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show box between frame_a and frame_b)&quot;;
  parameter SI.Position r[3](start={0.1,0,0}) 
    &quot;Vector from frame_a to frame_b resolved in frame_a&quot;;
  parameter SI.Position r_shape[3]={0,0,0} 
    &quot;Vector from frame_a to box origin, resolved in frame_a&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis lengthDirection=r - r_shape 
    &quot;Vector in length direction of box, resolved in frame_a&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis widthDirection={0,1,0} 
    &quot;Vector in width direction of box, resolved in frame_a&quot;;
  parameter SI.Length length=Modelica.Math.Vectors.length(
                                           r - r_shape) &quot;Length of box&quot;;
  parameter SI.Distance width=length/world.defaultWidthFraction &quot;Width of box&quot;;
  parameter SI.Distance height=width &quot;Height of box&quot;;
  parameter SI.Distance innerWidth=0 
    &quot;Width of inner box surface (0 &lt;= innerWidth &lt;= width)&quot;;
  parameter SI.Distance innerHeight=innerWidth 
    &quot;Height of inner box surface (0 &lt;= innerHeight &lt;= height)&quot;;
  parameter SI.Density density = 7700 
    &quot;Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)&quot;;
  input Modelica.Mechanics.MultiBody.Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot;Color of box&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  SI.Position r_0[3](start={0,0,0}, each stateSelect=if enforceStates then 
              StateSelect.always else StateSelect.avoid) 
    &quot;Position vector from origin of world frame to origin of frame_a&quot;;
  SI.Velocity v_0[3](start={0,0,0}, each stateSelect=if enforceStates then StateSelect.always else 
              StateSelect.avoid) 
    &quot;Absolute velocity of frame_a, resolved in world frame (= der(r_0))&quot;;
  SI.Acceleration a_0[3](start={0,0,0}) 
    &quot;Absolute acceleration of frame_a resolved in world frame (= der(v_0))&quot;;

  parameter Boolean angles_fixed = false 
    &quot;= true, if angles_start are used as initial values, else as guess values&quot;;
  parameter SI.Angle angles_start[3]={0,0,0} 
    &quot;Initial values of angles to rotate frame_a around &#39;sequence_start&#39; axes into frame_b&quot;;
  parameter Types.RotationSequence sequence_start={1,2,3} 
    &quot;Sequence of rotations to rotate frame_a into frame_b at initial time&quot;;

  parameter Boolean w_0_fixed = false 
    &quot;= true, if w_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularVelocity w_0_start[3]={0,0,0} 
    &quot;Initial or guess values of angular velocity of frame_a resolved in world frame&quot;;

  parameter Boolean z_0_fixed = false 
    &quot;= true, if z_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularAcceleration z_0_start[3]={0,0,0} 
    &quot;Initial values of angular acceleration z_0 = der(w_0)&quot;;

  parameter Boolean enforceStates=false 
    &quot; = true, if absolute variables of body object shall be used as states (StateSelect.always)&quot;;
  parameter Boolean useQuaternions=true 
    &quot; = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states&quot;;
  parameter Types.RotationSequence sequence_angleStates={1,2,3} 
    &quot; Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states&quot;;

  final parameter SI.Mass mo(min=0)=density*length*width*height 
    &quot;Mass of box without hole&quot;;
  final parameter SI.Mass mi(min=0)=density*length*innerWidth*innerHeight 
    &quot;Mass of hole of box&quot;;
  final parameter SI.Mass m(min=0)=mo - mi &quot;Mass of box&quot;;
  final parameter Frames.Orientation R=Frames.from_nxy(r, widthDirection) 
    &quot;Orientation object from frame_a to coordinates system spanned by r and widthDirection&quot;;
  final parameter SI.Position r_CM[3]=r_shape + Modelica.Math.Vectors.normalize(lengthDirection)*length/2 
    &quot;Position vector from origin of frame_a to center of mass, resolved in frame_a&quot;;
  final parameter SI.Inertia I[3, 3]=Frames.resolveDyade1(R, diagonal({mo*(
      width*width + height*height) - mi*(innerWidth*innerWidth + innerHeight*
      innerHeight),mo*(length*length + height*height) - mi*(length*length +
      innerHeight*innerHeight),mo*(length*length + width*width) - mi*(length*
      length + innerWidth*innerWidth)}/12)) 
    &quot;Inertia tensor of body box with respect to center of mass, parallel to frame_a&quot;;
  Body body(
    animation=false,
    r_CM=r_CM,
    m=m,
    I_11=I[1, 1],
    I_22=I[2, 2],
    I_33=I[3, 3],
    I_21=I[2, 1],
    I_31=I[3, 1],
    I_32=I[3, 2],
    sequence_start=sequence_start,
    angles_fixed=angles_fixed,
    angles_start=angles_start,
    w_0_fixed=w_0_fixed,
    w_0_start=w_0_start,
    z_0_fixed=z_0_fixed,
    z_0_start=z_0_start,
    useQuaternions=useQuaternions,
    sequence_angleStates=sequence_angleStates,
    enforceStates=false);
  FixedTranslation frameTranslation(
    r=r,
    animation=animation,
    shapeType=&quot;box&quot;,
    r_shape=r_shape,
    lengthDirection=lengthDirection,
    widthDirection=widthDirection,
    length=length,
    width=width,
    height=height,
    color=color,
   specularCoefficient=specularCoefficient);

protected 
  outer Modelica.Mechanics.MultiBody.World world;
equation 
  r_0 = frame_a.r_0;
  v_0 = der(r_0);
  a_0 = der(v_0);

  assert(innerWidth &lt;= width,
    &quot;parameter innerWidth is greater as parameter width&quot;);
  assert(innerHeight &lt;= height,
    &quot;parameter innerHeight is greater as paraemter height&quot;);
  connect(frameTranslation.frame_a, frame_a);
  connect(frameTranslation.frame_b, frame_b);
  connect(frame_a, body.frame_a);
end BodyBox;</code></pre>
<hr />
<h1 id="image50-modelica.mechanics.multibody.parts.bodycylinder"><img src="Modelica.Mechanics.MultiBody.Parts.BodyCylinderI.png" alt="image50" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.BodyCylinder</h1>
<p><strong>Rigid body with cylinder shape. Mass and animation properties are computed from cylinder data and density (12 potential states)</strong></p>
<h2 id="information-7">Information</h2>
<p>::</p>
<p><strong>Rigid body</strong> with <strong>cylinder</strong> shape. The mass properties of the body (mass, center of mass, inertia tensor) are computed from the cylinder data. Optionally, the cylinder may be hollow. The cylinder shape is by default used in the animation. The two connector frames <strong>frame_a</strong> and <strong>frame_b</strong> are always parallel to each other. Example of component animation (note, that the animation may be switched off via parameter animation = <strong>false</strong>):</p>
<p>A BodyCylinder component has potential states. For details of these states and of the &quot;Advanced&quot; menu parameters, see model <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Body">MultiBody.Parts.Body</a>.</p>
<p>::</p>
<h2 id="parameters-6">Parameters</h2>
<table>
<col width="42%" />
<col width="8%" />
<col width="12%" />
<col width="36%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show cylinder between frame_a and frame_b)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r[3]</td>
<td align="left">
</td>
<td align="left">Vector from frame_a to frame_b, resolved in frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_shape[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Vector from frame_a to cylinder origin, resolved in frame_a [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">lengthDirection</td>
<td align="left">r - r_shape</td>
<td align="left">Vector in length direction of cylinder, resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Length">Length</a></td>
<td align="left">length</td>
<td align="left">Modelica.Math.Vectors.length...</td>
<td align="left">Length of cylinder [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">diameter</td>
<td align="left">length/world.defaultWidthFra...</td>
<td align="left">Diameter of cylinder [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">innerDiameter</td>
<td align="left">0</td>
<td align="left">Inner diameter of cylinder (0 &lt;= innerDiameter &lt;= Diameter) [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Density">Density</a></td>
<td align="left">density</td>
<td align="left">7700</td>
<td align="left">Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800) [kg/m3]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">color</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinder</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Initialization</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Position vector from origin of world frame to origin of frame_a [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute velocity of frame_a, resolved in world frame (= der(r_0)) [m/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute acceleration of frame_a resolved in world frame (= der(v_0)) [m/s2]</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">angles_fixed</td>
<td align="left">false</td>
<td align="left">= true, if angles_start are used as initial values, else as guess values</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angles to rotate frame_a around 'sequence_start' axes into frame_b [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_start</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate frame_a into frame_b at initial time</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">w_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if w_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial or guess values of angular velocity of frame_a resolved in world frame [rad/s]</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">z_0_fixed</td>
<td align="left">false</td>
<td align="left">= true, if z_0_start are used as initial values, else as guess values</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">z_0_start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Initial values of angular acceleration z_0 = der(w_0) [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">enforceStates</td>
<td align="left">false</td>
<td align="left">= true, if absolute variables of body object shall be used as states (StateSelect.always)</td>
</tr>
<tr class="even">
<td align="left">Boolean</td>
<td align="left">useQuaternions</td>
<td align="left">true</td>
<td align="left">= true, if quaternions shall be used as potential states otherwise use 3 angles as potential states</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.RotationSequence">RotationSequence</a></td>
<td align="left">sequence_angleStates</td>
<td align="left">{1,2,3}</td>
<td align="left">Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-6">Connectors</h2>
<table>
<col width="54%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame_b</td>
<td align="left">Coordinate system fixed to the component with one cut-force and cut-torque</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-6">Modelica definition</h2>
<pre><code>model BodyCylinder 
  &quot;Rigid body with cylinder shape. Mass and animation properties are computed from cylinder data and density (12 potential states)&quot;

  import SI = Modelica.SIunits;
  import NonSI = Modelica.SIunits.Conversions.NonSIunits;
  import Modelica.Mechanics.MultiBody.Types;
  Interfaces.Frame_a frame_a 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;
  Interfaces.Frame_b frame_b 
    &quot;Coordinate system fixed to the component with one cut-force and cut-torque&quot;;
  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show cylinder between frame_a and frame_b)&quot;;
  parameter SI.Position r[3](start={0.1,0,0}) 
    &quot;Vector from frame_a to frame_b, resolved in frame_a&quot;;
  parameter SI.Position r_shape[3]={0,0,0} 
    &quot;Vector from frame_a to cylinder origin, resolved in frame_a&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis lengthDirection=r - r_shape 
    &quot;Vector in length direction of cylinder, resolved in frame_a&quot;;
  parameter SI.Length length=Modelica.Math.Vectors.length(
                                           r - r_shape) &quot;Length of cylinder&quot;;
  parameter SI.Distance diameter=length/world.defaultWidthFraction 
    &quot;Diameter of cylinder&quot;;
  parameter SI.Distance innerDiameter=0 
    &quot;Inner diameter of cylinder (0 &lt;= innerDiameter &lt;= Diameter)&quot;;
  parameter SI.Density density = 7700 
    &quot;Density of cylinder (e.g., steel: 7700 .. 7900, wood : 400 .. 800)&quot;;
  input Modelica.Mechanics.MultiBody.Types.Color color=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot;Color of cylinder&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;

  SI.Position r_0[3](start={0,0,0}, each stateSelect=if enforceStates then 
              StateSelect.always else StateSelect.avoid) 
    &quot;Position vector from origin of world frame to origin of frame_a&quot;;
  SI.Velocity v_0[3](start={0,0,0}, each stateSelect=if enforceStates then StateSelect.always else 
              StateSelect.avoid) 
    &quot;Absolute velocity of frame_a, resolved in world frame (= der(r_0))&quot;;
  SI.Acceleration a_0[3](start={0,0,0}) 
    &quot;Absolute acceleration of frame_a resolved in world frame (= der(v_0))&quot;;

  parameter Boolean angles_fixed = false 
    &quot;= true, if angles_start are used as initial values, else as guess values&quot;;
  parameter SI.Angle angles_start[3]={0,0,0} 
    &quot;Initial values of angles to rotate frame_a around &#39;sequence_start&#39; axes into frame_b&quot;;
  parameter Types.RotationSequence sequence_start={1,2,3} 
    &quot;Sequence of rotations to rotate frame_a into frame_b at initial time&quot;;

  parameter Boolean w_0_fixed = false 
    &quot;= true, if w_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularVelocity w_0_start[3]={0,0,0} 
    &quot;Initial or guess values of angular velocity of frame_a resolved in world frame&quot;;

  parameter Boolean z_0_fixed = false 
    &quot;= true, if z_0_start are used as initial values, else as guess values&quot;;
  parameter SI.AngularAcceleration z_0_start[3]={0,0,0} 
    &quot;Initial values of angular acceleration z_0 = der(w_0)&quot;;

  parameter Boolean enforceStates=false 
    &quot; = true, if absolute variables of body object shall be used as states (StateSelect.always)&quot;;
  parameter Boolean useQuaternions=true 
    &quot; = true, if quaternions shall be used as potential states otherwise use 3 angles as potential states&quot;;
  parameter Types.RotationSequence sequence_angleStates={1,2,3} 
    &quot; Sequence of rotations to rotate world frame into frame_a around the 3 angles used as potential states&quot;;

  constant Real pi=Modelica.Constants.pi;
  final parameter SI.Distance radius=diameter/2 &quot;Radius of cylinder&quot;;
  final parameter SI.Distance innerRadius=innerDiameter/2 
    &quot;Inner-Radius of cylinder&quot;;
  final parameter SI.Mass mo(min=0)=density*pi*length*radius*radius 
    &quot;Mass of cylinder without hole&quot;;
  final parameter SI.Mass mi(min=0)=density*pi*length*innerRadius*innerRadius 
    &quot;Mass of hole of cylinder&quot;;
  final parameter SI.Inertia I22=(mo*(length*length + 3*radius*radius) - mi*(
      length*length + 3*innerRadius*innerRadius))/12 
    &quot;Inertia with respect to axis through center of mass, perpendicular to cylinder axis&quot;;
  final parameter SI.Mass m(min=0)=mo - mi &quot;Mass of cylinder&quot;;
  final parameter Frames.Orientation R=Frames.from_nxy(r, {0,1,0}) 
    &quot;Orientation object from frame_a to frame spanned by cylinder axis and axis perpendicular to cylinder axis&quot;;
  final parameter SI.Position r_CM[3]=r_shape + Modelica.Math.Vectors.normalize(lengthDirection)*length/2 
    &quot;Position vector from frame_a to center of mass, resolved in frame_a&quot;;
  final parameter SI.Inertia I[3, 3]=Frames.resolveDyade1(R, diagonal({(mo*
      radius*radius - mi*innerRadius*innerRadius)/2,I22,I22})) 
    &quot;Inertia tensor of cylinder with respect to center of mass, resolved in frame parallel to frame_a&quot;;

  Body body(
    r_CM=r_CM,
    m=m,
    I_11=I[1, 1],
    I_22=I[2, 2],
    I_33=I[3, 3],
    I_21=I[2, 1],
    I_31=I[3, 1],
    I_32=I[3, 2],
    animation=false,
    sequence_start=sequence_start,
    angles_fixed=angles_fixed,
    angles_start=angles_start,
    w_0_fixed=w_0_fixed,
    w_0_start=w_0_start,
    z_0_fixed=z_0_fixed,
    z_0_start=z_0_start,
    useQuaternions=useQuaternions,
    sequence_angleStates=sequence_angleStates,
    enforceStates=false);
  FixedTranslation frameTranslation(
    r=r,
    animation=animation,
    shapeType=&quot;pipecylinder&quot;,
    r_shape=r_shape,
    lengthDirection=lengthDirection,
    length=length,
    width=diameter,
    height=diameter,
    extra=innerDiameter/diameter,
    color=color,
    specularCoefficient=specularCoefficient,
    widthDirection={0,1,0});

protected 
  outer Modelica.Mechanics.MultiBody.World world;
equation 
  r_0 = frame_a.r_0;
  v_0 = der(r_0);
  a_0 = der(v_0);

  assert(innerDiameter &lt; diameter,
    &quot;parameter innerDiameter is greater as parameter diameter.&quot;);
  connect(frameTranslation.frame_a, frame_a);
  connect(frameTranslation.frame_b, frame_b);
  connect(frame_a, body.frame_a);
end BodyCylinder;</code></pre>
<hr />
<h1 id="image51-modelica.mechanics.multibody.parts.pointmass"><img src="Modelica.Mechanics.MultiBody.Parts.PointMassI.png" alt="image51" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.PointMass</h1>
<p><strong>Rigid body where body rotation and inertia tensor is neglected (6 potential states)</strong></p>
<h2 id="information-8">Information</h2>
<p>::</p>
<p><strong>Rigid body</strong> where the inertia tensor is neglected. This body is solely defined by its mass. By default, this component is visualized by a <strong>sphere</strong> that has its center at frame_a. Note, that the animation may be switched off via parameter animation = <strong>false</strong>.</p>
<p>Every PointMass has potential states. If possible a tool will select the states of joints and not the states of PointMasss because this is usually the most efficient choice. In this case the position and velocity of frame_a of the body will be computed by the component that is connected to frame_a. However, if a PointMass is moving freely in space, variables of the PointMass have to be used as states. The potential states are: The <strong>position vector</strong> frame_a.r_0 from the origin of the world frame to the origin of frame_a of the body, resolved in the world frame and the <strong>absolute velocity</strong> v_0 of the origin of frame_a, resolved in the world frame (= der(frame_a.r_0)).</p>
<p>Whether or not variables of the body are used as states is usually automatically selected by the Modelica translator. If parameter <strong>enforceStates</strong> is set to <strong>true</strong> in the &quot;Advanced&quot; menu, then PointMass variables frame_a.r_0 and der(frame_a.r_0) are forced to be used as states.</p>
<p>::</p>
<h2 id="parameters-7">Parameters</h2>
<table>
<col width="43%" />
<col width="8%" />
<col width="12%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show sphere)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">m</td>
<td align="left">
</td>
<td align="left">Mass of mass point [kg]</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Position vector from origin of world frame to origin of frame_a, resolved in world frame [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Velocity">Velocity</a></td>
<td align="left">v_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute velocity of frame_a, resolved in world frame (= der(r_0)) [m/s]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Acceleration">Acceleration</a></td>
<td align="left">a_0.start[3]</td>
<td align="left">{0,0,0}</td>
<td align="left">Absolute acceleration of frame_a resolved in world frame (= der(v_0)) [m/s2]</td>
</tr>
<tr class="odd">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Diameter">Diameter</a></td>
<td align="left">sphereDiameter</td>
<td align="left">world.defaultBodyDiameter</td>
<td align="left">Diameter of sphere [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">sphereColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of sphere</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="even">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.avoid</td>
<td align="left">Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states</td>
</tr>
</tbody>
</table>
<h2 id="connectors-7">Connectors</h2>
<table>
<col width="63%" />
<col width="7%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Coordinate system fixed at center of mass point</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-7">Modelica definition</h2>
<pre><code>model PointMass 
  &quot;Rigid body where body rotation and inertia tensor is neglected (6 potential states)&quot;

  import SI = Modelica.SIunits;
  import Modelica.Mechanics.MultiBody.Types;
  Interfaces.Frame_a frame_a &quot;Coordinate system fixed at center of mass point&quot;;
  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show sphere)&quot;;
  parameter SI.Mass m(min=0) &quot;Mass of mass point&quot;;
  input SI.Diameter sphereDiameter=world.defaultBodyDiameter 
    &quot;Diameter of sphere&quot;;
  input Types.Color sphereColor=Modelica.Mechanics.MultiBody.Types.Defaults.BodyColor 
    &quot;Color of sphere&quot;;
  input Types.SpecularCoefficient specularCoefficient = world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.avoid 
    &quot;Priority to use frame_a.r_0, v_0 (= der(frame_a.r_0)) as states&quot;;

  SI.Position r_0[3](start={0,0,0}, each stateSelect=stateSelect) 
    &quot;Position vector from origin of world frame to origin of frame_a, resolved in world frame&quot;;
  SI.Velocity v_0[3](start={0,0,0}, each stateSelect=stateSelect) 
    &quot;Absolute velocity of frame_a, resolved in world frame (= der(r_0))&quot;;
  SI.Acceleration a_0[3](start={0,0,0}) 
    &quot;Absolute acceleration of frame_a resolved in world frame (= der(v_0))&quot;;

protected 
  outer Modelica.Mechanics.MultiBody.World world;

  // Declarations for animation
  Visualizers.Advanced.Shape sphere(
    shapeType=&quot;sphere&quot;,
    color=sphereColor,
    specularCoefficient=specularCoefficient,
    length=sphereDiameter,
    width=sphereDiameter,
    height=sphereDiameter,
    lengthDirection={1,0,0},
    widthDirection={0,1,0},
    r_shape= - {1,0,0}*sphereDiameter/2,
    r=frame_a.r_0,
    R=frame_a.R) if world.enableAnimation and animation;
equation 
  // If any possible, do not use the connector as root
  Connections.potentialRoot(frame_a.R, 10000);

  if Connections.isRoot(frame_a.R) then
     assert(cardinality(frame_a)==0, &quot;
A Modelica.Mechanics.MultiBody.Parts.PointMass model is connected in
a way, so that no equations are present to compute frame_a.R
(the orientation object in the connector). Setting frame_a.R to
an arbitrary value in the PointMass model, might lead to a wrong
overall model, depending on how the PointMass model is used.
   You can avoid this message, by providing equations that
compute the orientation object, e.g., by using the
Modelica.Mechanics.MultiBody.Joints.FreeMotion joint.
   If a PointMass model is not connected at all, the
orientation object is set to a unit rotation. But this is
the only case where this is done.
&quot;);
     frame_a.R = Frames.nullRotation();
  else
     frame_a.t = zeros(3);
  end if;

  // Newton equation: f = m*(a-g)
  r_0 = frame_a.r_0;
  v_0 = der(r_0);
  a_0 = der(v_0);
  frame_a.f = m*Frames.resolve2(frame_a.R, a_0 - world.gravityAcceleration(r_0));
end PointMass;</code></pre>
<hr />
<h1 id="image52-modelica.mechanics.multibody.parts.mounting1d"><img src="Modelica.Mechanics.MultiBody.Parts.Mounting1DI.png" alt="image52" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.Mounting1D</h1>
<p><strong>Propagate 1-dim. support torque to 3-dim. system (provided world.driveTrainMechanics3D=true)</strong></p>
<h2 id="information-9">Information</h2>
<p>::</p>
<p>This component is used to acquire support torques from a 1-dim.-rotational mechanical system (e.g., components from Modelica.Mechanics.Rotational) and to propagate them to a carrier body.</p>
<p>The 1-dim. support torque at <code>flange_b</code> is transformed into 3-dim. space under consideration of the rotation axis, parameter <code>n</code>, which has to be given in the local coordinate system of <code>frame_a</code>.</p>
<p>All components of a 1-dim.-rotational mechanical system that are connected to <strong>a</strong> common <strong>Mounting1D</strong> element need to have the same axis of rotation along parameter vector <code>n</code>. This means that, e.g., bevel gears where the axis of rotation of <code>flange_a</code> and <code>flange_b</code> are different cannot be described properly by connecting to the <strong>Mounting1D</strong> component. In this case, a combination of several <strong>Mounting1D</strong> components or the component <strong>BevelGear1D</strong> should be used.</p>
<dl>
<dt><strong>Reference</strong></dt>
<dd><p>Schweiger, Christian ; Otter, Martin: `Modelling 3D Mechanical Effects</p>
</dd>
</dl>
<p>of 1-dim. Powertrains &lt;<a href="http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf">http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf</a>&gt;`_. In: <em>Proceedings of the 3rd International Modelica Conference</em>. Linkping : The Modelica Association and Linkping University, November 3-4, 2003, pp. 149-158</p>
<p>::</p>
<h2 id="parameters-8">Parameters</h2>
<table>
<col width="50%" />
<col width="4%" />
<col width="6%" />
<col width="38%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi0</td>
<td align="left">0</td>
<td align="left">Fixed offset angle of housing [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation = axis of support torque (resolved in frame_a) [1]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-8">Connectors</h2>
<table>
<col width="50%" />
<col width="6%" />
<col width="42%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">(right) flange fixed in housing</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Frame in which housing is fixed (connector is removed, if world.driveTrainMechanics3D=false)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-8">Modelica definition</h2>
<pre><code>model Mounting1D 
  &quot;Propagate 1-dim. support torque to 3-dim. system (provided world.driveTrainMechanics3D=true)&quot;
  parameter Modelica.SIunits.Angle phi0=0 &quot;Fixed offset angle of housing&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n={1,0,0} 
    &quot;Axis of rotation = axis of support torque (resolved in frame_a)&quot;;

  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b 
    &quot;(right) flange fixed in housing&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a if world.driveTrainMechanics3D 
    &quot;Frame in which housing is fixed (connector is removed, if world.driveTrainMechanics3D=false)&quot;;

protected 
  outer Modelica.Mechanics.MultiBody.World world;

  encapsulated model Housing
    import Modelica;
    input Modelica.SIunits.Torque t[3];
    Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a;
  equation 
    frame_a.f=zeros(3);
    frame_a.t=t;
  end Housing;
  Housing housing(t=-n*flange_b.tau) if world.driveTrainMechanics3D;
equation 
  flange_b.phi = phi0;
  connect(housing.frame_a, frame_a);
end Mounting1D;</code></pre>
<hr />
<h1 id="image53-modelica.mechanics.multibody.parts.rotor1d"><img src="Modelica.Mechanics.MultiBody.Parts.Rotor1DI.png" alt="image53" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.Rotor1D</h1>
<p><strong>1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account if world.driveTrainMechanics3D=true)</strong></p>
<h2 id="information-10">Information</h2>
<p>::</p>
<p>This component is used to model the gyroscopic torques exerted by a 1-dim. inertia (so called <em>rotor</em>) on its 3-dim. carrier body. Gyroscopic torques appear, if the vector of the carrier body's angular velocity is not parallel to the vector of the rotor's axis. The axis of rotation of the rotor is defined by the parameter <code>n</code>, which has to be given in the local coordinate system of <code>frame_a</code>. The default animation of this component is shown in the figure below.</p>
<p>This component is a replacement for <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Inertia">Modelica.Mechanics.Rotational.Components.Inertia</a> for the case, that a 1-dim.-rotational mechanical system should be attached with a 3-dim. carrier body.</p>
<p>The Boolean parameter <code>exact</code> was introduced due to performance reasons. If <code>exact</code> is set to <strong>false</strong>, the influence of the carrier body motion on the angular velocity of the rotor is neglected. This influence is usually negligible if the 1-dim.-rotational mechanical system accelerates much faster as the base body (this is, e.g., the case in vehicle powertrains). The essential advantage is that an algebraic loop is removed since then there is only an action on acceleration level from the powertrain to the base body but not vice versa.</p>
<dl>
<dt><strong>Reference</strong></dt>
<dd><p>Schweiger, Christian ; Otter, Martin: `Modelling 3D Mechanical Effects</p>
</dd>
</dl>
<p>of 1-dim. Powertrains &lt;<a href="http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf">http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf</a>&gt;`_. In: <em>Proceedings of the 3rd International Modelica Conference</em>. Linkping : The Modelica Association and Linkping University, November 3-4, 2003, pp. 149-158</p>
<p>::</p>
<h2 id="parameters-9">Parameters</h2>
<table>
<col width="39%" />
<col width="7%" />
<col width="11%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show rotor as cylinder)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">J</td>
<td align="left">
</td>
<td align="left">Moment of inertia of rotor around its axis of rotation [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation resolved in frame_a [1]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_center[3]</td>
<td align="left">zeros(3)</td>
<td align="left">Position vector from origin of frame_a to center of cylinder [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderLength</td>
<td align="left">2*world.defaultJointLength</td>
<td align="left">Length of cylinder representing the rotor [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">2*world.defaultJointWidth</td>
<td align="left">Diameter of cylinder representing the rotor [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinder representing the rotor</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.default</td>
<td align="left">Priority to use rotor angle (phi) and rotor speed (w) as states</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">exact</td>
<td align="left">true</td>
<td align="left">= true, if exact calculations; false if influence of bearing on rotor acceleration is neglected to avoid an algebraic loop</td>
</tr>
</tbody>
</table>
<h2 id="connectors-9">Connectors</h2>
<table>
<col width="49%" />
<col width="6%" />
<col width="44%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">(left) driving flange (flange axis directed INTO cut plane)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">(right) driven flange (flange axis directed OUT OF cut plane)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Frame in which rotor housing is fixed (connector is removed, if world.driveTrainMechanics3D=false)</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-9">Modelica definition</h2>
<pre><code>model Rotor1D 
  &quot;1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account if world.driveTrainMechanics3D=true)&quot;

  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show rotor as cylinder)&quot;;
  parameter SI.Inertia J(min=0,start=1) 
    &quot;Moment of inertia of rotor around its axis of rotation&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n={1,0,0} 
    &quot;Axis of rotation resolved in frame_a&quot;;
  parameter SI.Position r_center[3]=zeros(3) 
    &quot;Position vector from origin of frame_a to center of cylinder&quot;;
  parameter SI.Distance cylinderLength=2*world.defaultJointLength 
    &quot;Length of cylinder representing the rotor&quot;;
  parameter SI.Distance cylinderDiameter=2*world.defaultJointWidth 
    &quot;Diameter of cylinder representing the rotor&quot;;
  input Modelica.Mechanics.MultiBody.Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
    &quot;Color of cylinder representing the rotor&quot;;
  input Modelica.Mechanics.MultiBody.Types.SpecularCoefficient
    specularCoefficient=world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.default 
    &quot;Priority to use rotor angle (phi) and rotor speed (w) as states&quot;;
  parameter Boolean exact=true 
    &quot;= true, if exact calculations; false if influence of bearing on rotor acceleration is neglected to avoid an algebraic loop&quot;;

  SI.Angle phi(start=0, stateSelect=stateSelect) 
    &quot;Rotation angle of rotor with respect to frame_a (= flange_a.phi = flange_b.phi)&quot;;
  SI.AngularVelocity w(start=0, stateSelect=stateSelect) 
    &quot;Angular velocity of rotor with respect to frame_a&quot;;
  SI.AngularAcceleration a(start=0) 
    &quot;Angular acceleration of rotor with respect to frame_a&quot;;

  Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a 
    &quot;(left) driving flange (flange axis directed INTO cut plane)&quot;;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b 
    &quot;(right) driven flange (flange axis directed OUT OF cut plane)&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a if world.driveTrainMechanics3D 
    &quot;Frame in which rotor housing is fixed (connector is removed, if world.driveTrainMechanics3D=false)&quot;;


encapsulated model RotorWith3DEffects 
    &quot;1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account)&quot;

    import Modelica;
    import Modelica.Mechanics.MultiBody.Frames;
    import Modelica.Mechanics.MultiBody.Types;
    import SI = Modelica.SIunits;
    import Cv = Modelica.SIunits.Conversions;

  parameter Boolean animation=true 
      &quot;= true, if animation shall be enabled (show rotor as cylinder)&quot;;
  parameter SI.Inertia J(min=0)=1 
      &quot;Moment of inertia of rotor around its axis of rotation&quot;;
  parameter Types.Axis n={1,0,0} &quot;Axis of rotation resolved in frame_a&quot;;
  parameter SI.Position r_center[3]=zeros(3) 
      &quot;Position vector from origin of frame_a to center of cylinder&quot;;
  parameter SI.Distance cylinderLength=2*world.defaultJointLength 
      &quot;Length of cylinder representing the rotor&quot;;
  parameter SI.Distance cylinderDiameter=2*world.defaultJointWidth 
      &quot;Diameter of cylinder representing the rotor&quot;;
  input Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
      &quot;Color of cylinder representing the rotor&quot;;
  input Types.SpecularCoefficient specularCoefficient =                              world.defaultSpecularCoefficient 
      &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.default 
      &quot;Priority to use rotor angle (phi) and rotor speed (w) as states&quot;;
  parameter Boolean exact=true 
      &quot;= true, if exact calculations; false if influence of bearing on rotor acceleration is neglected to avoid an algebraic loop&quot;;

  SI.AngularVelocity w_a[3] &quot;Angular velocity of frame_a, resolved in frame_a&quot;;
  SI.Angle phi(start=0, final stateSelect=stateSelect) 
      &quot;Rotation angle of rotor with respect to frame_a (= flange_a.phi = flange_b.phi)&quot;;

  SI.AngularVelocity w(start=0, stateSelect=stateSelect) 
      &quot;Angular velocity of rotor with respect to frame_a&quot;;
  SI.AngularAcceleration a(start=0) 
      &quot;Angular acceleration of rotor with respect to frame_a&quot;;

  Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a 
      &quot;(left) driving flange (flange axis directed INTO cut plane)&quot;;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b 
      &quot;(right) driven flange (flange axis directed OUT OF cut plane)&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
      &quot;Frame in which rotor housing is fixed&quot;;

  protected 
  outer Modelica.Mechanics.MultiBody.World world;
  parameter Real e[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                       n,0.0) 
      &quot;Unit vector in direction of rotor axis, resolved in frame_a&quot;;
  parameter SI.Inertia nJ[3]=J*e;
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape cylinder(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=cylinderLength,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=n,
    widthDirection={0,1,0},
    extra=1,
    r_shape=r_center - e*(cylinderLength/2),
    r=frame_a.r_0,
    R=Frames.absoluteRotation(frame_a.R, Frames.planarRotation(e, phi, 0))) if 
       world.enableAnimation and animation;
equation 
  phi = flange_a.phi;
  phi = flange_b.phi;
  w = der(phi);
  a = der(w);

  w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(frame_a.R);
  if exact then
    J*a = flange_a.tau + flange_b.tau - nJ*der(w_a);
  else
    J*a = flange_a.tau + flange_b.tau;
  end if;

 /* Reaction torque:
        t = n*(J*a - flange_a.tau - flange_b.tau) + cross(w_a, nJ*w)

     Since
        J*a = flange_a.tau + flange_b.tau - nJ*der(w_a);

     the reaction torque can be simplified to
        t = n*(- nJ*der(w_a)) + cross(w_a, nJ*w)

  */
  frame_a.f = zeros(3);
  frame_a.t = cross(w_a, nJ*w)-e*(nJ*der(w_a));
end RotorWith3DEffects;

protected 
  outer Modelica.Mechanics.MultiBody.World world;
  parameter Real e[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                       n,0.0) 
    &quot;Unit vector in direction of rotor axis, resolved in frame_a&quot;;
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape cylinder(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=cylinderLength,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=n,
    widthDirection={0,1,0},
    extra=1,
    r_shape=r_center - e*(cylinderLength/2),
    r=zeros(3),
    R=Modelica.Mechanics.MultiBody.Frames.planarRotation(
        e,
        phi,
        0)) if world.enableAnimation and animation and not world.driveTrainMechanics3D;

  Modelica.Mechanics.Rotational.Components.Inertia inertia(
    J=J) if 
        not world.driveTrainMechanics3D;
  RotorWith3DEffects rotorWith3DEffects(
    animation=animation,
    J=J,
    n=n,
    r_center=r_center,
    cylinderLength=cylinderLength,
    cylinderDiameter=cylinderDiameter,
    cylinderColor=cylinderColor,
    specularCoefficient=specularCoefficient,
    exact=exact) if world.driveTrainMechanics3D;
equation 
  phi = flange_a.phi;
  w = der(phi);
  a = der(w);

  connect(inertia.flange_a, flange_a);
  connect(inertia.flange_b, flange_b);
  connect(rotorWith3DEffects.flange_b, flange_b);
  connect(rotorWith3DEffects.flange_a, flange_a);
  connect(rotorWith3DEffects.frame_a, frame_a);
end Rotor1D;</code></pre>
<hr />
<h1 id="image54-modelica.mechanics.multibody.parts.bevelgear1d"><img src="Modelica.Mechanics.MultiBody.Parts.BevelGear1DI.png" alt="image54" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.BevelGear1D</h1>
<p><strong>1D gearbox with arbitrary shaft directions and 3-dim. bearing frame (3D dynamic effects are taken into account provided world.driveTrainMechanics3D=true)</strong></p>
<h2 id="information-11">Information</h2>
<p>::</p>
<p>This component is used to model a 1-dim. gearbox with non-parallel axes (defined by parameters <code>n_a</code>, <code>n_b</code>). A 3-dim. <code>bearing</code> frame is necessary to reflect the correct support torque, as the axes of rotation of <code>flange_a</code> and <code>flange_b</code> and the direction of the support torque vector are different in general.</p>
<p>Note: The name BevelGear1D is kept only for simplicity. Regardless, this component could be used to model any kind of gearbox with non-parallel axes.</p>
<dl>
<dt><strong>Reference</strong></dt>
<dd><p>Schweiger, Christian ; Otter, Martin: `Modelling 3D Mechanical Effects</p>
</dd>
</dl>
<p>of 1-dim. Powertrains &lt;<a href="http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf">http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf</a>&gt;`_. In: <em>Proceedings of the 3rd International Modelica Conference</em>. Linkping : The Modelica Association and Linkping University, November 3-4, 2003, pp. 149-158</p>
<p>::</p>
<p>Extends from <a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges">Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges</a> (Partial model for a component with two rotational 1-dim. shaft flanges).</p>
<h2 id="parameters-10">Parameters</h2>
<table>
<col width="53%" />
<col width="5%" />
<col width="6%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Real</td>
<td align="left">ratio</td>
<td align="left">
</td>
<td align="left">Gear speed ratio</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_a</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation of flange_a, resolved in frame_a [1]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n_b</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation of flange_b, resolved in frame_a [1]</td>
</tr>
</tbody>
</table>
<h2 id="connectors-10">Connectors</h2>
<table>
<col width="74%" />
<col width="9%" />
<col width="16%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">Flange of left shaft</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">Flange of right shaft</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Bearing frame</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-10">Modelica definition</h2>
<pre><code>model BevelGear1D 
  &quot;1D gearbox with arbitrary shaft directions and 3-dim. bearing frame (3D dynamic effects are taken into account provided world.driveTrainMechanics3D=true)&quot;
  extends Modelica.Mechanics.Rotational.Interfaces.PartialTwoFlanges;

  parameter Real ratio(start=1) &quot;Gear speed ratio&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n_a={1,0,0} 
    &quot;Axis of rotation of flange_a, resolved in frame_a&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Axis n_b={1,0,0} 
    &quot;Axis of rotation of flange_b, resolved in frame_a&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a if world.driveTrainMechanics3D 
    &quot;Bearing frame&quot;;

protected 
  outer World world;
  parameter Real e_a[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(n_a,0.0) 
    &quot;Unit vector in direction of flange_a rotation axis&quot;;
  parameter Real e_b[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(n_b,0.0) 
    &quot;Unit vector in direction of flange_b rotation axis&quot;;
  encapsulated model Housing
    import Modelica;
    input Modelica.SIunits.Torque t[3];
    Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a;
  equation 
    frame_a.f=zeros(3);
    frame_a.t=t;
  end Housing;
  Housing housing(t=-flange_a.tau*e_a - flange_b.tau*e_b) if world.driveTrainMechanics3D;

equation 
  flange_a.phi = ratio*flange_b.phi;
  0 = ratio*flange_a.tau + flange_b.tau;
  connect(housing.frame_a, frame_a);
end BevelGear1D;</code></pre>
<hr />
<h1 id="image55-modelica.mechanics.multibody.parts.rollingwheel"><img src="Modelica.Mechanics.MultiBody.Parts.RollingWheelI.png" alt="image55" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.RollingWheel</h1>
<p><strong>Ideal rolling wheel on flat surface z=0 (5 positional, 3 velocity degrees of freedom)</strong></p>
<h2 id="parameters-11">Parameters</h2>
<table>
<col width="43%" />
<col width="11%" />
<col width="10%" />
<col width="34%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation of wheel shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Radius">Radius</a></td>
<td align="left">wheelRadius</td>
<td align="left">
</td>
<td align="left">Radius of wheel [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">wheelMass</td>
<td align="left">
</td>
<td align="left">Mass of wheel [kg]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">wheel_I_axis</td>
<td align="left">
</td>
<td align="left">Inertia along the wheel axis [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">wheel_I_long</td>
<td align="left">
</td>
<td align="left">Inertia perpendicular to the wheel axis [kg.m2]</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.always</td>
<td align="left">Priority to use generalized coordinates as states</td>
</tr>
<tr class="odd">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">angles.start[3]</td>
<td align="left"><strong>{0,0,0}</strong></td>
<td align="left">Angles to rotate world-frame in to frame_a around z-, y-, x-axis [rad]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">der_angles.start[3]</td>
<td align="left"><strong>{0,0,0}</strong></td>
<td align="left">Derivative of angles [rad/s]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">width</td>
<td align="left">0.035</td>
<td align="left">Width of wheel [m]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">hollowFraction</td>
<td align="left">0.8</td>
<td align="left">1.0: Completely hollow, 0.0: rigid cylinder</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">wheelColor</td>
<td align="left">{30,30,30}</td>
<td align="left">Color of wheel</td>
</tr>
</tbody>
</table>
<h2 id="connectors-11">Connectors</h2>
<table>
<col width="53%" />
<col width="6%" />
<col width="39%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Frame fixed in wheel center point. y-axis: along wheel axis, z-Axis: upwards,</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-11">Modelica definition</h2>
<pre><code>model RollingWheel 
  &quot;Ideal rolling wheel on flat surface z=0 (5 positional, 3 velocity degrees of freedom)&quot;
  import SI = Modelica.SIunits;

  parameter Boolean animation=true 
    &quot;= true, if animation of wheel shall be enabled&quot;;

  parameter SI.Radius wheelRadius &quot;Radius of wheel&quot;;
  parameter SI.Mass wheelMass &quot;Mass of wheel&quot;;
  parameter SI.Inertia wheel_I_axis &quot;Inertia along the wheel axis&quot;;
  parameter SI.Inertia wheel_I_long &quot;Inertia perpendicular to the wheel axis&quot;;
  parameter StateSelect stateSelect=StateSelect.always 
    &quot;Priority to use generalized coordinates as states&quot;;

  SI.Position x(start=0, fixed = true, stateSelect=stateSelect) 
    &quot;x-coordinate of wheel axis&quot;;

  SI.Position y(start=0, fixed = true, stateSelect=stateSelect) 
    &quot;y-coordinate of wheel axis&quot;;

  SI.Angle angles[3](start={0,0,0}, fixed = true, each stateSelect=stateSelect) 
    &quot;Angles to rotate world-frame in to frame_a around z-, y-, x-axis&quot;;

  SI.AngularVelocity der_angles[3](start={0,0,0}, fixed = true, each 
    stateSelect =                                                                stateSelect) 
    &quot;Derivative of angles&quot;;

  parameter SI.Distance width = 0.035 &quot;Width of wheel&quot;;
  parameter Real hollowFraction = 0.8 
    &quot;1.0: Completely hollow, 0.0: rigid cylinder&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Color wheelColor={30,30,30} 
    &quot;Color of wheel&quot;;

  Modelica.Mechanics.MultiBody.Parts.Body body(
    final r_CM={0,0,0},
    final m=wheelMass,
    final I_11=wheel_I_long,
    final I_22=wheel_I_axis,
    final I_33=wheel_I_long,
    final I_21=0,
    final I_31=0,
    final I_32=0,
    animation=false);

  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
    &quot;Frame fixed in wheel center point. y-axis: along wheel axis, z-Axis: upwards, &quot;;
  Modelica.Mechanics.MultiBody.Joints.RollingWheel rollingWheel(wheelRadius=wheelRadius,
      stateSelect=StateSelect.avoid);
  Modelica.Mechanics.MultiBody.Visualizers.FixedShape fixedShape(
    final animation=animation,
    final r_shape={0,-width,0},
    final lengthDirection={0,1,0},
    final widthDirection={1,0,0},
    final length=2*width,
    final width=2*wheelRadius,
    final height=2*wheelRadius,
    final color=wheelColor,
    final extra=hollowFraction,
    final shapeType=&quot;pipe&quot;) if 
                  animation;

equation 
  rollingWheel.x = x;
  rollingWheel.y = y;
  rollingWheel.angles = angles;
  rollingWheel.der_angles = der_angles;

  connect(body.frame_a, frame_a);
  connect(rollingWheel.frame_a, frame_a);
  connect(fixedShape.frame_a, frame_a);
end RollingWheel;</code></pre>
<hr />
<h1 id="image56-modelica.mechanics.multibody.parts.rollingwheelset"><img src="Modelica.Mechanics.MultiBody.Parts.RollingWheelSetI.png" alt="image56" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts">Modelica.Mechanics.MultiBody.Parts</a>.RollingWheelSet</h1>
<p><strong>Ideal rolling wheel set consisting of two ideal rolling wheels connected together by an axis</strong></p>
<h2 id="information-12">Information</h2>
<p>::</p>
<p>Two wheels are connected by an axis and can rotate around this axis. The wheels are rolling on the x-y plane. The coordinate system attached to the center of the wheel axis (frameMiddle) is constrained so that it is always parallel to the x-y plane. If all generalized coordinates are zero, frameMiddle is parallel to the world frame.</p>
<p>::</p>
<h2 id="parameters-12">Parameters</h2>
<table>
<col width="48%" />
<col width="9%" />
<col width="11%" />
<col width="29%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation of wheel set shall be enabled</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Radius">Radius</a></td>
<td align="left">wheelRadius</td>
<td align="left">
</td>
<td align="left">Radius of one wheel [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Mass">Mass</a></td>
<td align="left">wheelMass</td>
<td align="left">
</td>
<td align="left">Mass of one wheel [kg]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">wheel_I_axis</td>
<td align="left">
</td>
<td align="left">Inertia along one wheel axis [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">wheel_I_long</td>
<td align="left">
</td>
<td align="left">Inertia perpendicular to one wheel axis [kg.m2]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">wheelDistance</td>
<td align="left">
</td>
<td align="left">Distance between the two wheels [m]</td>
</tr>
<tr class="odd">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.always</td>
<td align="left">Priority to use the generalized coordinates as states</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">wheelWidth</td>
<td align="left">0.01</td>
<td align="left">Width of one wheel [m]</td>
</tr>
<tr class="odd">
<td align="left">Real</td>
<td align="left">hollowFraction</td>
<td align="left">0.8</td>
<td align="left">1.0: Completely hollow, 0.0: rigid cylinder</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">wheelColor</td>
<td align="left">{30,30,30}</td>
<td align="left">Color of wheels</td>
</tr>
</tbody>
</table>
<h2 id="connectors-12">Connectors</h2>
<table>
<col width="49%" />
<col width="6%" />
<col width="43%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frameMiddle</td>
<td align="left">Frame fixed in middle of axis connecting both wheels (y-axis: along wheel axis, z-Axis: upwards)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame1</td>
<td align="left">Frame fixed in center point of left wheel (y-axis: along wheel axis, z-Axis: upwards)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_b">Frame_b</a></td>
<td align="left">frame2</td>
<td align="left">Frame fixed in center point of right wheel (y-axis: along wheel axis, z-Axis: upwards)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">axis1</td>
<td align="left">1-dim. rotational flange that drives the left wheel</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">axis2</td>
<td align="left">1-dim. rotational flange that drives the right wheel</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">support</td>
<td align="left">Support of 1D axes</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-12">Modelica definition</h2>
<pre><code>model RollingWheelSet 
  &quot;Ideal rolling wheel set consisting of two ideal rolling wheels connected together by an axis&quot;
  import SI = Modelica.SIunits;
 Modelica.Mechanics.MultiBody.Interfaces.Frame_a frameMiddle 
    &quot;Frame fixed in middle of axis connecting both wheels (y-axis: along wheel axis, z-Axis: upwards)&quot;;


  parameter Boolean animation=true 
    &quot;= true, if animation of wheel set shall be enabled&quot;;

  parameter SI.Radius wheelRadius &quot;Radius of one wheel&quot;;
  parameter SI.Mass wheelMass &quot;Mass of one wheel&quot;;
  parameter SI.Inertia wheel_I_axis &quot;Inertia along one wheel axis&quot;;
  parameter SI.Inertia wheel_I_long &quot;Inertia perpendicular to one wheel axis&quot;;
  parameter SI.Distance wheelDistance &quot;Distance between the two wheels&quot;;
   parameter StateSelect stateSelect = StateSelect.always 
    &quot;Priority to use the generalized coordinates as states&quot;;

  Modelica.SIunits.Position x(start=0, fixed=true, stateSelect=stateSelect) 
    &quot;x coordinate of center between wheels&quot;;
  Modelica.SIunits.Position y(start=0, fixed=true, stateSelect=stateSelect) 
    &quot;y coordinate of center between wheels&quot;;
  Modelica.SIunits.Angle phi(start=0, fixed=true, stateSelect=stateSelect) 
    &quot;Orientation angle of wheel axis along z-axis&quot;;
  Modelica.SIunits.Angle theta1(start=0, fixed=true, stateSelect=stateSelect) 
    &quot;Angle of wheel 1&quot;;
  Modelica.SIunits.Angle theta2(start=0, fixed=true, stateSelect=stateSelect) 
    &quot;Angle of wheel 2&quot;;
  Modelica.SIunits.AngularVelocity der_theta1(start=0, fixed=true, stateSelect=stateSelect) 
    &quot;Derivative of theta 1&quot;;
  Modelica.SIunits.AngularVelocity der_theta2(start=0, fixed=true, stateSelect=stateSelect) 
    &quot;Derivative of theta 2&quot;;

  parameter SI.Distance wheelWidth = 0.01 &quot;Width of one wheel&quot;;
  parameter Real hollowFraction = 0.8 
    &quot;1.0: Completely hollow, 0.0: rigid cylinder&quot;;
  parameter Modelica.Mechanics.MultiBody.Types.Color wheelColor={30,30,30} 
    &quot;Color of wheels&quot;;

  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame1 
    &quot;Frame fixed in center point of left wheel (y-axis: along wheel axis, z-Axis: upwards)&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame2 
    &quot;Frame fixed in center point of right wheel (y-axis: along wheel axis, z-Axis: upwards)&quot;;
  Modelica.Mechanics.MultiBody.Parts.Body body2(
    final r_CM={0,0,0},
    final I_21=0,
    final I_31=0,
    final I_32=0,
    animation=false,
    final m=wheelMass,
    final I_11=wheel_I_long,
    final I_22=wheel_I_axis,
    final I_33=wheel_I_long);
  Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape2(
    final animation=animation,
    final lengthDirection={0,1,0},
    final widthDirection={1,0,0},
    final color=wheelColor,
    final extra=hollowFraction,
    final shapeType=&quot;pipe&quot;,
    final r_shape={0,-wheelWidth,0},
    final length=2*wheelWidth,
    final width=2*wheelRadius,
    final height=2*wheelRadius) if 
                  animation;
  Modelica.Mechanics.MultiBody.Parts.Body body1(
    final r_CM={0,0,0},
    final I_21=0,
    final I_31=0,
    final I_32=0,
    animation=false,
    final m=wheelMass,
    final I_11=wheel_I_long,
    final I_22=wheel_I_axis,
    final I_33=wheel_I_long);
  Modelica.Mechanics.MultiBody.Visualizers.FixedShape shape1(
    final animation=animation,
    final lengthDirection={0,1,0},
    final widthDirection={1,0,0},
    final color=wheelColor,
    final extra=hollowFraction,
    final shapeType=&quot;pipe&quot;,
    final r_shape={0,-wheelWidth,0},
    final length=2*wheelWidth,
    final width=2*wheelRadius,
    final height=2*wheelRadius) if 
                  animation;
  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis1 
    &quot;1-dim. rotational flange that drives the left wheel&quot;;
  Modelica.Mechanics.Rotational.Interfaces.Flange_a axis2 
    &quot;1-dim. rotational flange that drives the right wheel&quot;;
  Modelica.Mechanics.MultiBody.Joints.RollingWheelSet wheelSetJoint(
    animation=false,
    wheelRadius=wheelRadius,
    wheelDistance=wheelDistance,
    stateSelect=StateSelect.default,
    x(fixed=false),
    y(fixed=false),
    phi(fixed=false),
    theta1(fixed=false),
    theta2(fixed=false),
    der_theta1(fixed=false),
    der_theta2(fixed=false));
  Modelica.Mechanics.Rotational.Interfaces.Flange_b support 
    &quot;Support of 1D axes&quot;;
equation 
  wheelSetJoint.x      = x;
  wheelSetJoint.y      = y;
  wheelSetJoint.phi    = phi;
  wheelSetJoint.theta1 = theta1;
  wheelSetJoint.theta2 = theta2;
  der_theta1 = der(theta1);
  der_theta2 = der(theta2);

  connect(body2.frame_a,frame2);
  connect(body1.frame_a, frame1);
  connect(shape1.frame_a, frame1);
  connect(shape2.frame_a, frame2);
  connect(wheelSetJoint.frame2, frame2);
  connect(wheelSetJoint.frame1, frame1);
  connect(wheelSetJoint.axis1, axis1);
  connect(wheelSetJoint.axis2, axis2);
  connect(wheelSetJoint.support, support);
  connect(wheelSetJoint.frameMiddle, frameMiddle);
end RollingWheelSet;</code></pre>
<hr />
<h1 id="modelica.mechanics.multibody.parts.mounting1d.housing-modelica.mechanics.multibody.parts.mounting1d.housing"><img src="Modelica.Mechanics.MultiBody.Parts.Mounting1D.HousingI.png" alt="Modelica.Mechanics.MultiBody.Parts.Mounting1D.Housing" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Mounting1D">Modelica.Mechanics.MultiBody.Parts.Mounting1D</a>.Housing</h1>
<h2 id="connectors-13">Connectors</h2>
<table>
<col width="79%" />
<col width="9%" />
<col width="11%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-13">Modelica definition</h2>
<pre><code>encapsulated model Housing
  import Modelica;
  input Modelica.SIunits.Torque t[3];
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a;
equation 
  frame_a.f=zeros(3);
  frame_a.t=t;
end Housing;</code></pre>
<hr />
<h1 id="modelica.mechanics.multibody.parts.rotor1d.rotorwith3deffects-modelica.mechanics.multibody.parts.rotor1d.rotorwith3deffects"><img src="Modelica.Mechanics.MultiBody.Parts.Rotor1D.RotorWith3DEffectsI.png" alt="Modelica.Mechanics.MultiBody.Parts.Rotor1D.RotorWith3DEffects" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.Rotor1D">Modelica.Mechanics.MultiBody.Parts.Rotor1D</a>.RotorWith3DEffects</h1>
<p><strong>1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account)</strong></p>
<h2 id="information-13">Information</h2>
<p>::</p>
<p>This component is used to model the gyroscopic torques exerted by a 1-dim. inertia (so called <em>rotor</em>) on its 3-dim. carrier body. Gyroscopic torques appear, if the vector of the carrier body's angular velocity is not parallel to the vector of the rotor's axis. The axis of rotation of the rotor is defined by the parameter <code>n</code>, which has to be given in the local coordinate system of <code>frame_a</code>. The default animation of this component is shown in the figure below.</p>
<p>This component is a replacement for <a href="Modelica_Mechanics_Rotational_Components.html#Modelica.Mechanics.Rotational.Components.Inertia">Modelica.Mechanics.Rotational.Components.Inertia</a> for the case, that a 1-dim.-rotational mechanical system should be attached with a 3-dim. carrier body.</p>
<p>The Boolean parameter <code>exact</code> was introduced due to performance reasons. If <code>exact</code> is set to <strong>false</strong>, the influence of the carrier body motion on the angular velocity of the rotor is neglected. This influence is usually negligible if the 1-dim.-rotational mechanical system accelerates much faster as the base body (this is, e.g., the case in vehicle powertrains). The essential advantage is that an algebraic loop is removed since then there is only an action on acceleration level from the powertrain to the base body but not vice versa.</p>
<dl>
<dt><strong>Reference</strong></dt>
<dd><p>Schweiger, Christian ; Otter, Martin: `Modelling 3D Mechanical Effects</p>
</dd>
</dl>
<p>of 1-dim. Powertrains &lt;<a href="http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf">http://www.modelica.org/Conference2003/papers/h06_Schweiger_powertrains_v5.pdf</a>&gt;`_. In: <em>Proceedings of the 3rd International Modelica Conference</em>. Linkping : The Modelica Association and Linkping University, November 3-4, 2003, pp. 149-158</p>
<p>::</p>
<h2 id="parameters-13">Parameters</h2>
<table>
<col width="39%" />
<col width="7%" />
<col width="11%" />
<col width="40%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">animation</td>
<td align="left">true</td>
<td align="left">= true, if animation shall be enabled (show rotor as cylinder)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Inertia">Inertia</a></td>
<td align="left">J</td>
<td align="left">1</td>
<td align="left">Moment of inertia of rotor around its axis of rotation [kg.m2]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Axis">Axis</a></td>
<td align="left">n</td>
<td align="left">{1,0,0}</td>
<td align="left">Axis of rotation resolved in frame_a [1]</td>
</tr>
<tr class="even">
<td align="left">Initialization</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Angle">Angle</a></td>
<td align="left">phi.start</td>
<td align="left">0</td>
<td align="left">Rotation angle of rotor with respect to frame_a (= flange_a.phi = flange_b.phi) [rad]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity">AngularVelocity</a></td>
<td align="left">w.start</td>
<td align="left">0</td>
<td align="left">Angular velocity of rotor with respect to frame_a [rad/s]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration">AngularAcceleration</a></td>
<td align="left">a.start</td>
<td align="left">0</td>
<td align="left">Angular acceleration of rotor with respect to frame_a [rad/s2]</td>
</tr>
<tr class="even">
<td align="left"><strong>Animation</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="odd">
<td align="left">if animation = true</td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Position">Position</a></td>
<td align="left">r_center[3]</td>
<td align="left">zeros(3)</td>
<td align="left">Position vector from origin of frame_a to center of cylinder [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderLength</td>
<td align="left">2*world.defaultJointLength</td>
<td align="left">Length of cylinder representing the rotor [m]</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_SIunits.html#Modelica.SIunits.Distance">Distance</a></td>
<td align="left">cylinderDiameter</td>
<td align="left">2*world.defaultJointWidth</td>
<td align="left">Diameter of cylinder representing the rotor [m]</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.Color">Color</a></td>
<td align="left">cylinderColor</td>
<td align="left">Modelica.Mechanics.MultiBody...</td>
<td align="left">Color of cylinder representing the rotor</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Types.html#Modelica.Mechanics.MultiBody.Types.SpecularCoefficient">SpecularCoefficient</a></td>
<td align="left">specularCoefficient</td>
<td align="left">world.defaultSpecularCoeffic...</td>
<td align="left">Reflection of ambient light (= 0: light is completely absorbed)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Advanced</strong></td>
<td align="left">
</td>
<td align="left">
</td>
<td align="left">
</td>
</tr>
<tr class="even">
<td align="left">StateSelect</td>
<td align="left">stateSelect</td>
<td align="left">StateSelect.default</td>
<td align="left">Priority to use rotor angle (phi) and rotor speed (w) as states</td>
</tr>
<tr class="odd">
<td align="left">Boolean</td>
<td align="left">exact</td>
<td align="left">true</td>
<td align="left">= true, if exact calculations; false if influence of bearing on rotor acceleration is neglected to avoid an algebraic loop</td>
</tr>
</tbody>
</table>
<h2 id="connectors-14">Connectors</h2>
<table>
<col width="58%" />
<col width="7%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_a">Flange_a</a></td>
<td align="left">flange_a</td>
<td align="left">(left) driving flange (flange axis directed INTO cut plane)</td>
</tr>
<tr class="even">
<td align="left"><a href="Modelica_Mechanics_Rotational_Interfaces.html#Modelica.Mechanics.Rotational.Interfaces.Flange_b">Flange_b</a></td>
<td align="left">flange_b</td>
<td align="left">(right) driven flange (flange axis directed OUT OF cut plane)</td>
</tr>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">Frame in which rotor housing is fixed</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-14">Modelica definition</h2>
<pre><code>encapsulated model RotorWith3DEffects 
  &quot;1D inertia attachable on 3-dim. bodies (3D dynamic effects are taken into account)&quot;

    import Modelica;
    import Modelica.Mechanics.MultiBody.Frames;
    import Modelica.Mechanics.MultiBody.Types;
    import SI = Modelica.SIunits;
    import Cv = Modelica.SIunits.Conversions;

  parameter Boolean animation=true 
    &quot;= true, if animation shall be enabled (show rotor as cylinder)&quot;;
  parameter SI.Inertia J(min=0)=1 
    &quot;Moment of inertia of rotor around its axis of rotation&quot;;
  parameter Types.Axis n={1,0,0} &quot;Axis of rotation resolved in frame_a&quot;;
  parameter SI.Position r_center[3]=zeros(3) 
    &quot;Position vector from origin of frame_a to center of cylinder&quot;;
  parameter SI.Distance cylinderLength=2*world.defaultJointLength 
    &quot;Length of cylinder representing the rotor&quot;;
  parameter SI.Distance cylinderDiameter=2*world.defaultJointWidth 
    &quot;Diameter of cylinder representing the rotor&quot;;
  input Types.Color cylinderColor=Modelica.Mechanics.MultiBody.Types.Defaults.RodColor 
    &quot;Color of cylinder representing the rotor&quot;;
  input Types.SpecularCoefficient specularCoefficient =                              world.defaultSpecularCoefficient 
    &quot;Reflection of ambient light (= 0: light is completely absorbed)&quot;;
  parameter StateSelect stateSelect=StateSelect.default 
    &quot;Priority to use rotor angle (phi) and rotor speed (w) as states&quot;;
  parameter Boolean exact=true 
    &quot;= true, if exact calculations; false if influence of bearing on rotor acceleration is neglected to avoid an algebraic loop&quot;;

  SI.AngularVelocity w_a[3] &quot;Angular velocity of frame_a, resolved in frame_a&quot;;
  SI.Angle phi(start=0, final stateSelect=stateSelect) 
    &quot;Rotation angle of rotor with respect to frame_a (= flange_a.phi = flange_b.phi)&quot;;

  SI.AngularVelocity w(start=0, stateSelect=stateSelect) 
    &quot;Angular velocity of rotor with respect to frame_a&quot;;
  SI.AngularAcceleration a(start=0) 
    &quot;Angular acceleration of rotor with respect to frame_a&quot;;

  Modelica.Mechanics.Rotational.Interfaces.Flange_a flange_a 
    &quot;(left) driving flange (flange axis directed INTO cut plane)&quot;;
  Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b 
    &quot;(right) driven flange (flange axis directed OUT OF cut plane)&quot;;
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a 
    &quot;Frame in which rotor housing is fixed&quot;;

protected 
  outer Modelica.Mechanics.MultiBody.World world;
  parameter Real e[3](each final unit=&quot;1&quot;)=Modelica.Math.Vectors.normalize(
                                       n,0.0) 
    &quot;Unit vector in direction of rotor axis, resolved in frame_a&quot;;
  parameter SI.Inertia nJ[3]=J*e;
  Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape cylinder(
    shapeType=&quot;cylinder&quot;,
    color=cylinderColor,
    specularCoefficient=specularCoefficient,
    length=cylinderLength,
    width=cylinderDiameter,
    height=cylinderDiameter,
    lengthDirection=n,
    widthDirection={0,1,0},
    extra=1,
    r_shape=r_center - e*(cylinderLength/2),
    r=frame_a.r_0,
    R=Frames.absoluteRotation(frame_a.R, Frames.planarRotation(e, phi, 0))) if 
       world.enableAnimation and animation;
equation 
  phi = flange_a.phi;
  phi = flange_b.phi;
  w = der(phi);
  a = der(w);

  w_a = Modelica.Mechanics.MultiBody.Frames.angularVelocity2(frame_a.R);
  if exact then
    J*a = flange_a.tau + flange_b.tau - nJ*der(w_a);
  else
    J*a = flange_a.tau + flange_b.tau;
  end if;

 /* Reaction torque:
        t = n*(J*a - flange_a.tau - flange_b.tau) + cross(w_a, nJ*w)

     Since
        J*a = flange_a.tau + flange_b.tau - nJ*der(w_a);

     the reaction torque can be simplified to
        t = n*(- nJ*der(w_a)) + cross(w_a, nJ*w)

  */
  frame_a.f = zeros(3);
  frame_a.t = cross(w_a, nJ*w)-e*(nJ*der(w_a));
end RotorWith3DEffects;</code></pre>
<hr />
<h1 id="modelica.mechanics.multibody.parts.bevelgear1d.housing-modelica.mechanics.multibody.parts.bevelgear1d.housing"><img src="Modelica.Mechanics.MultiBody.Parts.BevelGear1D.HousingI.png" alt="Modelica.Mechanics.MultiBody.Parts.BevelGear1D.Housing" /> <a href="Modelica_Mechanics_MultiBody_Parts.html#Modelica.Mechanics.MultiBody.Parts.BevelGear1D">Modelica.Mechanics.MultiBody.Parts.BevelGear1D</a>.Housing</h1>
<h2 id="connectors-15">Connectors</h2>
<table>
<col width="79%" />
<col width="9%" />
<col width="11%" />
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><a href="Modelica_Mechanics_MultiBody_Interfaces.html#Modelica.Mechanics.MultiBody.Interfaces.Frame_a">Frame_a</a></td>
<td align="left">frame_a</td>
<td align="left">
</td>
</tr>
</tbody>
</table>
<h2 id="modelica-definition-15">Modelica definition</h2>
<pre><code>encapsulated model Housing
  import Modelica;
  input Modelica.SIunits.Torque t[3];
  Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a;
equation 
  frame_a.f=zeros(3);
  frame_a.t=t;
end Housing;</code></pre>
<hr />
<p><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:30:35 2010.</p>
</body>
</html>
